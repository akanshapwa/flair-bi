var flairVisualizations =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://flairVisualizations/(webpack)/buildin/global.js?");

/***/ }),

/***/ "../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack://flairVisualizations/(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./fonts/FiraSansExtraCondensed-Bold.ttf":
/*!***********************************************!*\
  !*** ./fonts/FiraSansExtraCondensed-Bold.ttf ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var createFontFamily = __webpack_require__(/*! ttf-loader/lib/create-font-family */ \"./node_modules/ttf-loader/lib/create-font-family.js\");\n\nmodule.exports = createFontFamily({\n  ttf: __webpack_require__.p + \"./fonts/5c65c200251ccc5390381d828ca682b9.ttf\",\n  woff: __webpack_require__.p + \"./fonts/a46f1ed76a38c3d59ac88b0276d42d3f.woff\",\n});\n\n\n//# sourceURL=webpack://flairVisualizations/./fonts/FiraSansExtraCondensed-Bold.ttf?");

/***/ }),

/***/ "./fonts/FiraSansExtraCondensed-Light.ttf":
/*!************************************************!*\
  !*** ./fonts/FiraSansExtraCondensed-Light.ttf ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var createFontFamily = __webpack_require__(/*! ttf-loader/lib/create-font-family */ \"./node_modules/ttf-loader/lib/create-font-family.js\");\n\nmodule.exports = createFontFamily({\n  ttf: __webpack_require__.p + \"./fonts/2bc3dc29bb81a1830ab8a9e4b28827a1.ttf\",\n  woff: __webpack_require__.p + \"./fonts/916787c284e47d7afff86acd1159a14e.woff\",\n});\n\n\n//# sourceURL=webpack://flairVisualizations/./fonts/FiraSansExtraCondensed-Light.ttf?");

/***/ }),

/***/ "./fonts/FiraSansExtraCondensed-Regular.ttf":
/*!**************************************************!*\
  !*** ./fonts/FiraSansExtraCondensed-Regular.ttf ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var createFontFamily = __webpack_require__(/*! ttf-loader/lib/create-font-family */ \"./node_modules/ttf-loader/lib/create-font-family.js\");\n\nmodule.exports = createFontFamily({\n  ttf: __webpack_require__.p + \"./fonts/44d610a55aa6ca659e88f64dd82c6c0d.ttf\",\n  woff: __webpack_require__.p + \"./fonts/eebd3e3c4b08f204606a187f0650b814.woff\",\n});\n\n\n//# sourceURL=webpack://flairVisualizations/./fonts/FiraSansExtraCondensed-Regular.ttf?");

/***/ }),

/***/ "./fonts/FiraSansExtraCondensed-SemiBold.ttf":
/*!***************************************************!*\
  !*** ./fonts/FiraSansExtraCondensed-SemiBold.ttf ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var createFontFamily = __webpack_require__(/*! ttf-loader/lib/create-font-family */ \"./node_modules/ttf-loader/lib/create-font-family.js\");\n\nmodule.exports = createFontFamily({\n  ttf: __webpack_require__.p + \"./fonts/d41f88ab7afc39c47ad22924377ba590.ttf\",\n  woff: __webpack_require__.p + \"./fonts/1dc3d484e68b754a7886042de1184c9d.woff\",\n});\n\n\n//# sourceURL=webpack://flairVisualizations/./fonts/FiraSansExtraCondensed-SemiBold.ttf?");

/***/ }),

/***/ "./js/charts/clusteredverticalbar.js":
/*!*******************************************!*\
  !*** ./js/charts/clusteredverticalbar.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction clusteredverticalbar() {\n\n    /* These are the constant global variable for the function clusteredverticalbar.\n     */\n    var _NAME = 'clusteredverticalbar';\n\n    /* These are the private variables that is initialized by the arguments sent\n     * by the users and can be updated using public methods.\n     */\n\n    var _config,\n        _dimension,\n        _measure,\n        _xAxis,\n        _yAxis,\n        _xAxisColor,\n        _yAxisColor,\n        _xAxisLabel,\n        _yAxisLabel,\n        _legend,\n        _legendPosition,\n        _grid,\n        _dimensionDisplayName,\n        _measureShowValue = [],\n        _measureDisplayName = [],\n        _measureFontStyle = [],\n        _measureFontWeight = [],\n        _measureFontSize = [],\n        _measureNumberFormat = [],\n        _measureTextColor = [],\n        _measureDisplayColor = [],\n        _measureBorderColor = [],\n        _tooltip;\n\n    /* These are the common variables that is shared across the different private/public \n     * methods but is initialized/updated within the methods itself.\n     */\n    var _localSVG,\n        _localTotal = [],\n        _localXAxis,\n        _localYAxis,\n        _localXGrid,\n        _localYGrid,\n        _localData,\n        _localXLabels = [],\n        _localMin = 0,\n        _localMax = 0,\n        _localLegend,\n        _localTooltip;\n        // _localLabelStack;\n\n    /* These are the common private functions that is shared across the different private/public \n     * methods but is initialized beforehand.\n     */\n    var _xDimension = d3.scaleBand(),\n        _xDimensionGrid = d3.scaleLinear(),\n        _xMeasure = d3.scaleBand(),\n        _y = d3.scaleLinear();\n\n    /* -------------------------------------------------------------------------------- */\n    var _setConfigParams = function(config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.xAxis(config.xAxis);\n        this.yAxis(config.yAxis);\n        this.xAxisColor(config.xAxisColor);\n        this.yAxisColor(config.yAxisColor);\n        this.xAxisLabel(config.xAxisLabel);\n        this.yAxisLabel(config.yAxisLabel);\n        this.legend(config.legend);\n        this.legendPosition(config.legendPosition);\n        this.grid(config.grid);\n        this.dimensionDisplayName(config.dimensionDisplayName);\n        this.measureShowValue(config.measureShowValue);\n        this.measureDisplayName(config.measureDisplayName);\n        this.measureFontStyle(config.measureFontStyle);\n        this.measureFontWeight(config.measureFontWeight);\n        this.measureFontSize(config.measureFontSize);\n        this.measureNumberFormat(config.measureNumberFormat);\n        this.measureTextColor(config.measureTextColor);\n        this.measureDisplayColor(config.measureDisplayColor);\n        this.measureBorderColor(config.measureBorderColor);\n        this.tooltip(config.tooltip);\n    }\n\n    var _setAxisColor = function(axis, color) {\n        var path = axis.select('path'),\n            ticks = axis.selectAll('.tick');\n\n        path.style('stroke', color);\n\n        ticks.select('line')\n            .style('stroke', color);\n\n        ticks.select('text')\n            .style('fill', color);\n    }\n\n    /* Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the bar\n     * @param {function} chart Clustered Vertical Bar chart function\n     * @return {string} String encoded HTML data\n     */\n    var _buildTooltipData = function(datum, chart) {\n        var output = \"\";\n\n        output += \"<table><tr>\"\n            + \"<th>\" + (_dimensionDisplayName || _dimension[0]) + \": </th>\"\n            + \"<td>\" + datum[_dimension[0]] + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + (_measureDisplayName[_measure.indexOf(datum['measure'])] || datum['measure']) + \": </th>\"\n            + \"<td>\" + datum[datum['measure']] + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var _handleMouseOverFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'pointer');\n\n            var barGroup = container.selectAll('g.bar')\n                .filter(function(d1) {\n                    return (d1[_dimension[0]] === d[_dimension[0]]) && (d1['measure'] === d['measure']);\n                });\n\n            barGroup.select('rect:not(.bar-rect-mask)')\n                .style('fill', COMMON.HIGHLIGHTER)\n                .style('stroke', COMMON.HIGHLIGHTER);\n\n            barGroup.select('rect.bar-rect-mask')\n                .attr('visibility', 'visible');\n\n            if(tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            if(tooltip) {\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'default');\n\n            var barGroup = container.selectAll('g.bar')\n                .filter(function(d1) {\n                    return (d1[_dimension[0]] === d[_dimension[0]]) && (d1['measure'] === d['measure']);\n                });\n\n            barGroup.select('rect:not(.bar-rect-mask)')\n                .style('fill', function(d1, i1) {\n                    if(typeof _measureDisplayColor[i1] == 'undefined' || _measureDisplayColor[i1].trim() == '') {\n                        return COMMON.COLORSCALE(d1['measure']);\n                    }\n                    return _measureDisplayColor[i1];\n                })\n                .style('stroke', function(d1, i1) {\n                    if(typeof _measureBorderColor[i1] == 'undefined' || _measureBorderColor[i1].trim() == '') {\n                        return COMMON.COLORSCALE(d1['measure']);\n                    }\n                    return _measureBorderColor[i1];\n                });\n\n            barGroup.select('rect.bar-rect-mask')\n                .attr('visibility', 'hidden');\n            \n            if(tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    var _legendMouseOver = function(data) {\n        d3.selectAll('g.arc')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('fill', COMMON.HIGHLIGHTER);\n\n        d3.selectAll('g.arc-mask')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('visibility', 'visible');\n    }\n\n    var _legendMouseMove = function(data) {\n\n    }\n\n    var _legendMouseOut = function(data) {\n        d3.selectAll('g.arc')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('fill', function(d, i) {\n                return COMMON.COLORSCALE(d.data[_dimension[0]]);\n            });\n\n        d3.selectAll('g.arc-mask')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('visibility', 'hidden');\n    }\n\n    var _legendClick = function(data) {\n        if(_localLabelStack.indexOf(data[_dimension[0]]) < 0) {\n            _localLabelStack.push(data[_dimension[0]]);\n        } else {\n            _localLabelStack.splice(_localLabelStack.indexOf(data[_dimension[0]]), 1);\n        }\n\n        chart.update(_localData);\n    }\n\n    function chart(selection) {\n        _localSVG = selection;\n\n        selection.each(function(data) {\n            var svg = d3.select(this),\n                width = +svg.attr('width'),\n                height = +svg.attr('height'),\n                parentWidth = width - 2 * COMMON.PADDING,\n                parentHeight = height - 2 * COMMON.PADDING;\n\n            /* store the data in local variable */\n            _localData = data;\n\n            /* total sum of the measure values */\n            _localTotal = _measure.map(function(m) {\n                return {\n                    measure: m,\n                    positiveTotal: d3.sum(data.map(function(d) { return (d[m] >= 0) ? d[m] : 0; })),\n                    negativeTotal: d3.sum(data.map(function(d) { return (d[m] < 0) ? Math.abs(d[m]) : 0; }))\n                }\n            });\n\n            /* applying sort operation to the data */\n            // UTIL.sorter(data, _measure, _sort);\n\n            var container = svg.append('g')\n                .classed('container', true)\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            var legendWidth = 0,\n                legendHeight = 0,\n                plotWidth = parentWidth - (_yAxis ? COMMON.AXIS_THICKNESS : 0),\n                plotHeight = parentHeight - (_xAxis ? (COMMON.AXIS_THICKNESS / 1.5) : 0);\n\n            if(_legend) {\n                _localLegend = LEGEND.bind(chart);\n\n                var result = _localLegend(_measure, container, {\n                    width: parentWidth,\n                    height: parentHeight\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n\n                switch(_legendPosition) {\n                    case 'top':\n                    case 'bottom':\n                        plotHeight = plotHeight - legendHeight - (_xAxis ? (COMMON.AXIS_THICKNESS / 1.5) : 0);\n                        break;\n                    case 'right':\n                        plotWidth = plotWidth - legendWidth - (COMMON.AXIS_THICKNESS / 2)\n                        break;\n                    case 'left':\n                        plotWidth = plotWidth - legendWidth;\n                        break;\n                }\n            }\n\n            if(_tooltip) {\n                _localTooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            /* Label values for the dimension */\n            _localXLabels = data.map(function(d) {\n                return d[_dimension[0]];\n            });\n\n            /* Minimum and Maximum value of the measures */\n            _measure.forEach(function(m) {\n                var temp = d3.min(data, function(d) { return d[m]; });\n                _localMin = _localMin > temp ? temp : _localMin;\n\n                temp = d3.max(data, function(d) { return d[m]; });\n                _localMax = _localMax < temp ? temp : _localMax;\n            });\n            \n            _xDimension.domain(_localXLabels)\n                .rangeRound([0, plotWidth])\n                .padding([0]);\n\n            _xDimensionGrid.domain([0, _localXLabels.length])\n                .range([0, plotWidth]);\n\n            _xMeasure.domain(_measure)\n                .rangeRound([0, _xDimension.bandwidth()])\n                .padding([0.2]);\n\n            _y.domain([_localMin, _localMax])\n                .range([plotHeight, 0])\n                .nice();\n\n            var plot = container.append('g')\n                .attr('id', 'clusteredverticalbar-plot')\n                .attr('transform', function() {\n                    var translate = [0, 0];\n\n                    switch(_legendPosition) {\n                        case 'top':\n                            translate = [COMMON.AXIS_THICKNESS, (legendHeight + (_xAxis ? COMMON.AXIS_THICKNESS : 0) / 1.5)];\n                            break;\n                        case 'bottom':\n                        case 'right':\n                            translate = [(_yAxis ? COMMON.AXIS_THICKNESS : 0), 0];\n                            break;\n                        case 'left':\n                            translate = [(legendWidth + (_yAxis ? COMMON.AXIS_THICKNESS : 0)), 0]\n                    }\n\n                    return 'translate(' + translate.toString() + ')';\n                });\n\n            /* Axes Grid */\n            _localXGrid = d3.axisBottom()\n                .ticks(_localXLabels.length)\n                .tickFormat('')\n                .tickSize(-plotHeight);\n\n            _localYGrid = d3.axisLeft()\n                .tickFormat('')\n                .tickSize(-plotWidth);\n        \n            _localXGrid.scale(_xDimensionGrid);\n            _localYGrid.scale(_y);\n\n            plot.append('g')\n                .attr('class', 'x grid')\n                .attr('visibility', function() {\n                    return _grid ? 'visible' : 'hidden';\n                })\n                .attr('transform', 'translate(0, ' + plotHeight + ')')\n                .call(_localXGrid);\n\n            plot.append('g')\n                .attr('class', 'y grid')\n                .attr('visibility', function() {\n                    return _grid ? 'visible' : 'hidden';\n                })\n                .call(_localYGrid);\n\n            var clusterGroup = plot.append('g')\n                .attr('id', 'cluster-group')\n                .selectAll('.cluster')\n                .data(data)\n                .enter().append('g')\n                    .attr('id', function(d, i) {\n                        return 'cluster-group-' + i;\n                    })\n                    .classed('cluster', true)\n                    .attr('transform', function(d) {\n                        return 'translate(' + _xDimension(d[_dimension[0]]) + ', 0)';\n                    });\n\n            var barGroup = clusterGroup.selectAll('.bar')\n                .data(function(d) {\n                    return _measure.map(function(m) {\n                        var obj = {};\n                        obj[_dimension[0]] = d[_dimension[0]];\n                        obj[m] = d[m];\n                        obj['measure'] = m;\n                        return obj;\n                    });\n                })\n                .enter().append('g')\n                    .attr('id', function(d, i) {\n                        return 'bar-group-' + i;\n                    })\n                    .classed('bar', true);\n\n            var rect = barGroup.append('rect')\n                .attr('width', _xMeasure.bandwidth())\n                .attr('height', 0)\n                .attr('x', function(d, i) {\n                    return _xMeasure(d['measure']);\n                })\n                .attr('y', function(d, i) {\n                    return plotHeight;\n                })\n                .style('fill', function(d, i) {\n                    if(typeof _measureDisplayColor[i] == 'undefined' || _measureDisplayColor[i].trim() == '') {\n                        return COMMON.COLORSCALE(d['measure']);\n                    }\n                    return _measureDisplayColor[i];\n                })\n                .style('stroke', function(d, i) {\n                    if(typeof _measureBorderColor[i] == 'undefined' || _measureBorderColor[i].trim() == '') {\n                        return COMMON.COLORSCALE(d['measure']);\n                    }\n                    return _measureBorderColor[i];\n                })\n                .style('stroke-width', 1)\n                .on('mouseover', _handleMouseOverFn.call(chart, _localTooltip, svg))\n                .on('mousemove', _handleMouseMoveFn.call(chart, _localTooltip, svg))\n                .on('mouseout', _handleMouseOutFn.call(chart, _localTooltip, svg))\n                .on('click', function(d, i) {\n                    \n                });\n\n            rect.transition()\n                .duration(COMMON.DURATION)\n                .attr('height', function(d, i) {\n                    return plotHeight - _y(d[d['measure']]);\n                })\n                .attr('y', function(d, i) {\n                    return _y(d[d['measure']]);\n                });\n\n            var rectMask = barGroup.append('rect')\n                .classed('bar-rect-mask', true)\n                .attr('width', _xMeasure.bandwidth())\n                .attr('height', 1)\n                .attr('x', function(d, i) {\n                    return _xMeasure(d['measure']);\n                })\n                .attr('y', function(d, i) {\n                    return plotHeight;\n                })\n                .attr('visibility', 'hidden')\n                .style('fill', function(d, i) {\n                    if(typeof _measureDisplayColor[i] == 'undefined' || _measureDisplayColor[i].trim() == '') {\n                        return COMMON.COLORSCALE(d['measure']);\n                    }\n                    return _measureDisplayColor[i];\n                })\n                .style('stroke', function(d, i) {\n                    if(typeof _measureBorderColor[i] == 'undefined' || _measureBorderColor[i].trim() == '') {\n                        return COMMON.COLORSCALE(d['measure']);\n                    }\n                    return _measureBorderColor[i];\n                })\n                .style('stroke-width', 1);\n\n            rectMask.transition()\n                .duration(COMMON.DURATION)\n                .attr('y', function(d, i) {\n                    return _y(d[d['measure']]) - (COMMON.OFFSET / 3);\n                });\n\n            var text = barGroup.append('text')\n                .attr('x', function(d, i) {\n                    return _xMeasure(d['measure']) + (_xMeasure.bandwidth() / 2);\n                })\n                .attr('y', function(d, i) {\n                    return plotHeight;\n                })\n                .attr('dy', function(d, i) {\n                    return COMMON.OFFSET;\n                })\n                .attr('opacity', 0)\n                .attr('visibility', function(d, i) {\n                    return _measureShowValue[i] ? \"visible\" : \"hidden\";\n                })\n                .style('font-style', function(d, i) {\n                    return _measureFontStyle[i] || COMMON.DEFAULT_FONTSTYLE;\n                })\n                .style('font-weight', function(d, i) {\n                    return _measureFontWeight[i] || COMMON.DEFAULT_FONTWEIGHT;\n                })\n                .style('font-size', function(d, i) {\n                    return _measureFontSize[i] || COMMON.DEFAULT_FONTSIZE;\n                })\n                .style('fill', function(d, i) {\n                    if(typeof _measureTextColor[i] == 'undefined' || _measureTextColor[i].trim() == '') {\n                        return COMMON.DEFAULT_COLOR;\n                    }\n                    return _measureTextColor[i];\n                })\n                .style('text-anchor', 'middle');\n\n            text.transition()\n                .duration(COMMON.DURATION)\n                .attr('opacity', 1)\n                .attr('y', function(d, i) {\n                    return _y(d[d['measure']]);\n                })\n                .text(function(d, i) {\n                    var formatter = UTIL.getNumberFormatterFn(_measureNumberFormat[i]),\n                        value = d[d['measure']],\n                        lt = _localTotal.filter(function(lt) {\n                            return lt['measure'] == d['measure'];\n                        })[0],\n                        positiveTotal = lt['positiveTotal'],\n                        negativeTotal = lt['negativeTotal'];\n\n                    if(_measureNumberFormat[i] == 'percent') {\n                        value = (value >= 0) ? (value / positiveTotal) : (value / negativeTotal);\n                    }\n\n                    return formatter(UTIL.roundNumber(value, 2)).toUpperCase();\n                });\n\n            /* Axes */\n            var xAxisGroup,\n                yAxisGroup;\n\n            if(_xAxis) {\n                _localXAxis = d3.axisBottom(_xDimension)\n                    .tickSize(0)\n                    .tickPadding(10);\n\n                xAxisGroup = plot.append('g')\n                    .attr('class', 'x axis')\n                    .attr('visibility', function() {\n                        return 'visible';\n                    })\n                    .attr('transform', 'translate(0, ' + plotHeight + ')')\n                    .call(_localXAxis);\n\n                xAxisGroup.append('g')\n                    .attr('class', 'label')\n                    .attr('transform', function() {\n                        return 'translate(' + (plotWidth) + ', ' + (COMMON.AXIS_THICKNESS / 1.5) + ')';\n                    })\n                    .append('text')\n                        .style('text-anchor', 'end')\n                        .style('font-weight', 'bold')\n                        .style('fill', _xAxisColor)\n                        .text(_xAxisLabel);\n\n                _setAxisColor(xAxisGroup, _xAxisColor);\n            }\n\n            if(_yAxis) {\n                _localYAxis = d3.axisLeft(_y)\n                    .tickSize(0)\n                    .tickPadding(8)\n                    .tickFormat(function(d) {\n                        return UTIL.shortScale(2)(d);\n                    });\n\n                yAxisGroup = plot.append('g')\n                    .attr('class', 'y axis')\n                    .attr('visibility', function() {\n                        return 'visible';\n                    })\n                    .call(_localYAxis);\n\n                yAxisGroup.append('g')\n                    .attr('class', 'label')\n                    .attr('transform', function() {\n                        return 'translate(' + (-COMMON.AXIS_THICKNESS / 1.15) + ', ' + '0)';\n                    })\n                    .append('text')\n                        .attr('transform', 'rotate(-90)')\n                        .style('text-anchor', 'end')\n                        .style('font-weight', 'bold')\n                        .style('fill', _yAxisColor)\n                        .text(_yAxisLabel);\n\n                _setAxisColor(yAxisGroup, _yAxisColor);\n            }\n        });\n    }\n\n    /**\n     * Private method that delegates legend interactions to respective controllers\n     *\n     * @param {object} event Mouseevent instance\n     * @param {object} datum Record of the data binded to the legend item\n     * @return {undefined}\n     */\n    chart._legendInteraction = function(event, data) {\n        switch(event) {\n            case 'mouseover':\n                _legendMouseOver(data);\n                break;\n            case 'mousemove':\n                _legendMouseMove(data);\n                break;\n            case 'mouseout':\n                _legendMouseOut(data);\n                break;\n            case 'click':\n                _legendClick(data);\n                break;\n        }\n    }\n\n    chart._getName = function() {\n        return _NAME;\n    }\n\n    chart.update = function(data) {\n        var svg = _localSVG,\n            width = +svg.attr('width'),\n            height = +svg.attr('height'),\n            parentWidth = width - 2 * COMMON.PADDING,\n            parentHeight = height - 2 * COMMON.PADDING,\n            filteredData,\n            _localMin = 0,\n            _localMax = 0;\n\n        /* store the data in local variable */\n        _localData = data;\n\n        /* Label values for the dimension */\n        _localXLabels = data.map(function(d) {\n            return d[_dimension[0]];\n        });\n\n        /* Minimum and Maximum value of the measures */\n        _measure.forEach(function(m) {\n            var temp = d3.min(data, function(d) { return d[m]; });\n            _localMin = _localMin > temp ? temp : _localMin;\n\n            temp = d3.max(data, function(d) { return d[m]; });\n            _localMax = _localMax < temp ? temp : _localMax;\n        });\n        \n        /* Update the axes scales */\n        _xDimension.domain(_localXLabels);\n        _xDimensionGrid.domain([0, _localXLabels.length]);\n        _xMeasure.rangeRound([0, _xDimension.bandwidth()]);\n        _y.domain([_localMin, _localMax])\n            .nice();\n\n        if(_legend) {\n            svg.select('.legend').remove();\n            \n            _localLegend(_measure, svg.select('g'), {\n                width: parentWidth,\n                height: parentHeight\n                // labelStack: _localLabelStack\n            });\n        }\n\n        var clusterGroup = svg.selectAll('.cluster')\n            .data(data);\n            \n        clusterGroup.enter().append('g')\n            .attr('id', function(d, i) {\n                return 'cluster-group-' + i;\n            })\n            .classed('cluster', true)\n            .attr('transform', function(d) {\n                return 'translate(' + _xDimension(d[_dimension[0]]) + ', 0)';\n            });\n\n        var barGroup = clusterGroup.selectAll('.bar')\n            .data(function(d) {\n                return _measure.map(function(m) {\n                    var obj = {};\n                    obj[_dimension[0]] = d[_dimension[0]];\n                    obj[m] = d[m];\n                    obj['measure'] = m;\n                    return obj;\n                });\n            })\n            .enter().append('g')\n                .attr('id', function(d, i) {\n                    return 'bar-group-' + i;\n                })\n                .classed('bar', true);\n\n        var rect = barGroup.append('rect')\n            .attr('width', _xMeasure.bandwidth())\n            .attr('height', 0)\n            .style('fill', function(d, i) {\n                if(typeof _measureDisplayColor[i] == 'undefined' || _measureDisplayColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureDisplayColor[i];\n            })\n            .style('stroke', function(d, i) {\n                if(typeof _measureBorderColor[i] == 'undefined' || _measureBorderColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureBorderColor[i];\n            })\n            .style('stroke-width', 1)\n            .on('mouseover', _handleMouseOverFn.call(chart, _localTooltip, svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, _localTooltip, svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, _localTooltip, svg))\n            .on('click', function(d, i) {\n                \n            });\n\n        var text = barGroup.append('text')\n            .attr('y', function(d, i) {\n                return plotHeight;\n            })\n            .attr('dy', function(d, i) {\n                return COMMON.OFFSET;\n            })\n            .attr('opacity', 0)\n            .attr('visibility', function(d, i) {\n                return _measureShowValue[i];\n            })\n            .style('font-style', function(d, i) {\n                return _measureFontStyle[i] || COMMON.DEFAULT_FONTSTYLE;\n            })\n            .style('font-weight', function(d, i) {\n                return _measureFontWeight[i] || COMMON.DEFAULT_FONTWEIGHT;\n            })\n            .style('font-size', function(d, i) {\n                return _measureFontSize[i] || COMMON.DEFAULT_FONTSIZE;\n            })\n            .style('fill', function(d, i) {\n                if(typeof _measureTextColor[i] == 'undefined' || _measureTextColor[i].trim() == '') {\n                    return COMMON.DEFAULT_COLOR;\n                }\n                return _measureTextColor[i];\n            })\n            .style('text-anchor', 'middle');\n\n        var rectMask = barGroup.append('rect')\n            .classed('bar-rect-mask', true)\n            .attr('width', _xMeasure.bandwidth())\n            .attr('height', 1)\n            .attr('visibility', 'hidden')\n            .style('fill', function(d, i) {\n                if(typeof _measureDisplayColor[i] == 'undefined' || _measureDisplayColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureDisplayColor[i];\n            })\n            .style('stroke', function(d, i) {\n                if(typeof _measureBorderColor[i] == 'undefined' || _measureBorderColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureBorderColor[i];\n            })\n            .style('stroke-width', 1);\n\n        clusterGroup.merge(clusterGroup)\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('transform', function(d) {\n                return 'translate(' + _xDimension(d[_dimension[0]]) + ', 0)';\n            });\n\n        clusterGroup.selectAll('.bar').select('rect:not(.bar-rect-mask)')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('height', function(d, i) {\n                return _y(0) - _y(d[d['measure']]);\n            })\n            .attr('width', _xMeasure.bandwidth())\n            .attr('x', function(d, i) {\n                return _xMeasure(d['measure']);\n            })\n            .attr('y', function(d, i) {\n                return _y(d[d['measure']]);\n            });\n\n        clusterGroup.selectAll('.bar').select('rect.bar-rect-mask')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('width', _xMeasure.bandwidth())\n            .attr('x', function(d, i) {\n                return _xMeasure(d['measure']);\n            })\n            .attr('y', function(d, i) {\n                return _y(d[d['measure']]) - (COMMON.OFFSET / 3);\n            });\n\n        clusterGroup.selectAll('.bar').select('text')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('opacity', 1)\n            .attr('x', function(d, i) {\n                return _xMeasure(d['measure']) + (_xMeasure.bandwidth() / 2);\n            })\n            .attr('y', function(d, i) {\n                return _y(d[d['measure']]);\n            })\n            .text(function(d, i) {\n                var formatter = UTIL.getNumberFormatterFn(_measureNumberFormat[i]),\n                    value = d[d['measure']],\n                    lt = _localTotal.filter(function(lt) {\n                        return lt['measure'] == d['measure'];\n                    })[0],\n                    positiveTotal = lt['positiveTotal'],\n                    negativeTotal = lt['negativeTotal'];\n\n                if(_measureNumberFormat[i] == 'percent') {\n                    value = (value >= 0) ? (value / positiveTotal) : (value / negativeTotal);\n                }\n\n                return formatter(UTIL.roundNumber(value, 2)).toUpperCase();\n            });\n\n        clusterGroup.exit().selectAll('rect:not(.bar-rect-mask)')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('height', 0)\n            .attr('y', _y(0))\n            .remove();\n\n        clusterGroup.exit().selectAll('text')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('y', _y(0))\n            .remove();\n\n        /* Update Axes */\n        var xAxisGroup,\n            yAxisGroup;\n\n        if(_xAxis) {\n            xAxisGroup = svg.select('.x.axis')\n                .transition()\n                .duration(COMMON.DURATION)\n                .call(_localXAxis);\n\n            _setAxisColor(xAxisGroup, _xAxisColor);\n        }\n           \n        if(_yAxis) {\n            yAxisGroup = svg.select('.y.axis')\n                .transition()\n                .duration(COMMON.DURATION)\n                .call(_localYAxis);\n\n            _setAxisColor(yAxisGroup, _yAxisColor);\n        }\n\n        /* Update Axes Grid */\n        _localXGrid.ticks(_localXLabels.length);\n\n        svg.select('.x.grid')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('visibility', function() {\n                return _grid ? 'visible' : 'hidden';\n            })\n            .call(_localXGrid);\n\n        svg.select('.y.grid')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('visibility', function() {\n                return _grid ? 'visible' : 'hidden';\n            })\n            .call(_localYGrid);\n    }\n\n    chart.config = function(value) {\n        if(!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function(value) {\n        if(!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function(value) {\n        if(!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.xAxis = function(value) {\n        if(!arguments.length) {\n            return _xAxis;\n        }\n        _xAxis = value;\n        return chart;\n    }\n\n    chart.yAxis = function(value) {\n        if(!arguments.length) {\n            return _yAxis;\n        }\n        _yAxis = value;\n        return chart;\n    }\n\n    chart.xAxisColor = function(value) {\n        if(!arguments.length) {\n            return _xAxisColor;\n        }\n        _xAxisColor = value;\n        return chart;\n    }\n\n    chart.yAxisColor = function(value) {\n        if(!arguments.length) {\n            return _yAxisColor;\n        }\n        _yAxisColor = value;\n        return chart;\n    }\n    \n    chart.xAxisLabel = function(value) {\n        if(!arguments.length) {\n            return _xAxisLabel;\n        }\n        _xAxisLabel = value;\n        return chart;\n    }\n\n    chart.yAxisLabel = function(value) {\n        if(!arguments.length) {\n            return _yAxisLabel;\n        }\n        _yAxisLabel = value;\n        return chart;\n    }\n\n    chart.legend = function(value) {\n        if(!arguments.length) {\n            return _legend;\n        }\n        _legend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function(value) {\n        if(!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.grid = function(value) {\n        if(!arguments.length) {\n            return _grid;\n        }\n        _grid = value;\n        return chart;\n    }\n\n    chart.dimensionDisplayName = function(value) {\n        if(!arguments.length) {\n            return _dimensionDisplayName;\n        }\n        _dimensionDisplayName = value;\n        return chart;\n    }\n\n    /**\n     * ClusteredVerticalBar Measure Showvalue accessor function\n     *\n     * @param {boolean|array(boolean)|null} value Measure Showvalue value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {boolean|array(boolean)|function}\n     */\n    chart.measureShowValue = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureShowValue, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure Displayname accessor function\n     *\n     * @param {string|array(string)|null} value Measure Displayname value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureDisplayName = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureDisplayName, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure FontStyle accessor function\n     *\n     * @param {string|array(string)|null} value Measure FontStyle value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureFontStyle = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureFontStyle, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure FontWeight accessor function\n     *\n     * @param {number|array(number)|null} value Measure FontWeight value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {number|array(number)|function}\n     */\n    chart.measureFontWeight = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureFontWeight, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure FontSize accessor function\n     *\n     * @param {number|array(number)|null} value Measure FontSize value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {number|array(number)|function}\n     */\n    chart.measureFontSize = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureFontSize, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure NumberFormat accessor function\n     *\n     * @param {string|array(string)|null} value Measure NumberFormat value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureNumberFormat = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureNumberFormat, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure TextColor accessor function\n     *\n     * @param {string|array(string)|null} value Measure TextColor value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureTextColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureTextColor, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure DisplayColor accessor function\n     *\n     * @param {string|array(string)|null} value Measure DisplayColor value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureDisplayColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureDisplayColor, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure BorderColor accessor function\n     *\n     * @param {string|array(string)|null} value Measure BorderColor value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureBorderColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureBorderColor, value, measure, _measure);\n    }\n\n    chart.tooltip = function(value) {\n        if(!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = clusteredverticalbar;\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/clusteredverticalbar.js?");

/***/ }),

/***/ "./js/charts/combo.js":
/*!****************************!*\
  !*** ./js/charts/combo.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction combo() {\n\n    var _NAME = 'combo';\n\n    var _config,\n        _dimension,\n        _measure,\n        _showLegend,\n        _legendPosition,\n        _sort,\n        _tooltip,\n        _showXaxis,\n        _showYaxis,\n        _showXaxisLabel,\n        _showYaxisLabel,\n        _xAxisColor,\n        _yAxisColor,\n        _showGrid,\n        _stacked,\n        _displayName,\n        _legendData,\n        _comboChartType,\n        _showValues,\n        _displayNameForMeasure,\n        _fontStyle,\n        _fontWeight,\n        _numberFormat,\n        _textColor,\n        _displayColor,\n        _borderColor,\n        _fontSize,\n        _lineType,\n        _pointType,\n        _originalData;\n\n    var _local_svg, _Local_data;\n    var x0, x1, y;\n\n    var parentWidth, parentHeight, plotWidth, plotHeight;\n\n    var legendSpace = 20, axisLabelSpace = 20, offsetX = 16, offsetY = 3, div;\n\n    var filter = false, filterData = [];\n\n    var measuresBar = [], measuresLine = [];\n\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.showLegend(config.showLegend);\n        this.legendPosition(config.legendPosition);\n\n        this.showXaxis(config.showXaxis);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showYaxisLabel(config.showYaxisLabel);\n        this.xAxisColor(config.xAxisColor);\n        this.yAxisColor(config.yAxisColor);\n        this.displayName(config.displayName);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showValues(config.showValues);\n        this.displayNameForMeasure(config.displayNameForMeasure);\n        this.fontStyle(config.fontStyle);\n        this.fontWeight(config.fontWeight);\n        this.numberFormat(config.numberFormat);\n        this.textColor(config.textColor);\n        this.displayColor(config.displayColor);\n        this.borderColor(config.borderColor);\n        this.fontSize(config.fontSize);\n        this.comboChartType(config.comboChartType)\n        this.lineType(config.lineType);\n        this.pointType(config.pointType)\n        this.legendData(config.displayColor, config.measure);\n    }\n    var getPointType = function (index) {\n        var symbol = null;\n\n        switch (_pointType[index].toLowerCase()) {\n            case \"rectrounded\":\n                symbol = d3.symbolDiamond;\n                break;\n\n            case \"rectrot\":\n                symbol = d3.symbolDiamond;\n                break;\n\n            case \"star\":\n                symbol = d3.symbolStar;\n                break;\n\n            case \"triangle\":\n                symbol = d3.symbolTriangle;\n                break;\n\n            case \"circle\":\n                symbol = d3.symbolCircle;\n                break;\n\n            case \"cross\":\n                symbol = d3.symbolCross;\n                break;\n\n            case \"crossrot\":\n                symbol = d3.symbolCross;\n                break;\n\n            case \"dash\":\n                symbol = d3.symbolWye;\n                break;\n\n            case \"line\":\n                symbol = d3.symbolWye;\n                break;\n\n            case \"rect\":\n                symbol = d3.symbolSquare;\n                break;\n\n            default:\n                symbol = d3.symbolCircle;\n        }\n\n        return symbol;\n    }\n\n    var getXLabels = function (data) {\n        return data.map(function (d) { return d[_dimension[0]]; })\n    }\n\n    var _buildTooltipData = function (datum, chart) {\n        var output = \"\";\n        var dimension = datum.dimension != undefined ? datum.dimension : datum.data[_dimension[0]],\n            measure = datum.id != undefined ? datum.id : datum.tag,\n            measurevalue = datum._measure != undefined ? datum._measure : datum.data[datum.tag];\n        output += \"<table><tr>\"\n            + \"<th>\" + _dimension[0] + \": </th>\"\n            + \"<td>\" + dimension + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + measure + \": </th>\"\n            + \"<td>\" + measurevalue + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var onLassoStart = function (lasso, chart) {\n        return function () {\n            if (filter) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', true)\n                    .classed('selected', false);\n            }\n        }\n    }\n\n    var onLassoDraw = function (lasso, chart) {\n        return function () {\n            filter = true;\n            lasso.items().selectAll('rect')\n                .classed('selected', false);\n\n            lasso.possibleItems().selectAll('rect')\n                .classed('not_possible', false)\n                .classed('possible', true);\n\n            lasso.notPossibleItems().selectAll('rect')\n                .classed('not_possible', true)\n                .classed('possible', false);\n        }\n    }\n\n    var onLassoEnd = function (lasso, chart) {\n        return function () {\n            var data = lasso.selectedItems().data();\n            if (!filter) {\n                return;\n            }\n            if (data.length > 0) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', false)\n                    .classed('possible', false);\n            }\n\n            lasso.selectedItems().selectAll('rect')\n                .classed('selected', true)\n\n            lasso.notSelectedItems().selectAll('rect');\n\n            var confirm = d3.select('.confirm')\n                .style('visibility', 'visible');\n\n            var _filter = [];\n            var keys = UTIL.getMeasureList(data[0].data, _dimension);\n            data.forEach(function (d) {\n\n                var obj = new Object();\n                var temp = d.data[_dimension[0]];\n                var searchObj = _filter.find(o => o[_dimension[0]] === temp);\n                if (searchObj == undefined) {\n                    obj[_dimension[0]] = d.data[_dimension[0]];\n                    for (var index = 0; index < keys.length; index++) {\n                        obj[keys[index]] = d.data[keys[index]];\n                    }\n                    _filter.push(obj)\n                }\n            });\n            if (_filter.length > 0) {\n                filterData = _filter;\n            }\n        }\n    }\n\n    var applyFilter = function (chart) {\n        return function () {\n            if (filterData.length > 0) {\n                chart.update(filterData);\n            }\n        }\n    }\n\n    var clearFilter = function () {\n        return function () {\n            chart.update(_originalData);\n        }\n    }\n\n    var _handleMouseOverFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'pointer')\n                .style('cursor', 'pointer')\n                .style('fill', COMMON.HIGHLIGHTER);\n            var border = UTIL.getDisplayColor(_measure.indexOf(d.measure), _displayColor)\n            if (tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container, border);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            if (tooltip) {\n                var border = UTIL.getDisplayColor(_measure.indexOf(d.tag), _displayColor)\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container, border);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'default')\n                .style('fill', function (d1, i) {\n                    return UTIL.getDisplayColor(_measure.indexOf(d1.tag), _displayColor);\n                })\n                .style('stroke', function (d1, i) {\n                    return UTIL.getBorderColor(_measure.indexOf(d1.tag), _borderColor);\n                });\n\n            if (tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    function chart(selection) {\n        _local_svg = selection;\n\n        selection.each(function (data) {\n            chart._Local_data = _originalData = data;\n            var margin = {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 45\n            };\n\n            var div = d3.select(this).node().parentNode;\n\n            var svg = d3.select(this),\n                width = div.clientWidth,\n                height = div.clientHeight;\n\n            parentWidth = width - 2 * COMMON.PADDING - margin.left;\n            parentHeight = (height - 2 * COMMON.PADDING - axisLabelSpace * 2);\n\n            svg.attr('width', width)\n                .attr('height', height)\n\n            d3.select(div).append('div')\n                .attr('class', 'sort_selection');\n\n            d3.select(div).append('div')\n                .attr('class', 'arrow-down');\n\n            var str = UTIL.createAlert($(div).attr('id'), _measure);\n            $(div).append(str);\n\n            $(document).on('click', 'svg', function (e) {\n                if ($(\"#myonoffswitch\").prop('checked') == false) {\n                    var element = e.target\n                    if (element.tagName == \"svg\") {\n                        $('#Modal_' + $(div).attr('id') + ' .measure').val('')\n                        $('#Modal_' + $(div).attr('id') + ' .threshold').val('')\n                        $('#Modal_' + $(div).attr('id') + ' .measure').attr('disabled', false)\n                        $('#Modal_' + $(div).attr('id')).modal('toggle');\n                    }\n                }\n            });\n\n            $(document).on('click', '#Modal_' + $(div).attr('id') + ' .ThresholdSubmit', function (e) {\n                var newValue = $('#Modal_' + $(div).attr('id') + ' .threshold').val();\n                var obj = new Object()\n                obj.measure = $('#Modal_' + $(div).attr('id') + ' .measure').val()\n                obj.threshold = newValue;\n                threshold.push(obj);\n                $('#Modal_' + $(div).attr('id')).modal('toggle');\n            });\n\n            var container = svg.append('g')\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            var legendWidth = 0,\n                legendHeight = 0,\n                legendBreakCount;\n\n            plotWidth = parentWidth;\n            plotHeight = parentHeight;\n\n            if (_showLegend) {\n                var clusteredverticalbarLegend = LEGEND.bind(chart);\n\n                var result = clusteredverticalbarLegend(_legendData, container, {\n                    width: parentWidth,\n                    height: parentHeight,\n                    legendBreakCount: legendBreakCount\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n                legendBreakCount = result.legendBreakCount;\n\n                switch (_legendPosition) {\n                    case 'top':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace;\n                        break;\n                    case 'bottom':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace * 2;\n                        break;\n                    case 'right':\n                    case 'left':\n                        plotWidth = parentWidth - legendWidth;\n                        break;\n                }\n\n                if ((_legendPosition == 'top') || (_legendPosition == 'bottom')) {\n                    plotWidth = parentWidth;\n                    plotHeight = parentHeight - 3 * axisLabelSpace;\n                    legendSpace = 20;\n                } else if ((_legendPosition == 'left') || (_legendPosition == 'right')) {\n                    var legend = _local_svg.selectAll('.item');\n                    legendSpace = legend.node().parentNode.getBBox().width;\n                    plotWidth = (parentWidth - legendSpace) - margin.left + axisLabelSpace;\n                    plotHeight = parentHeight;\n\n                    legend.attr('transform', function (d, i) {\n                        if (_legendPosition == 'left') {\n                            return 'translate(0, ' + i * 20 + ')';\n\n                        }\n                        else if (_legendPosition == 'right') {\n                            return 'translate(' + (parentWidth - legendSpace + axisLabelSpace) + ', ' + i * 20 + ')';\n                        }\n                    });\n                }\n            }\n            else {\n                legendSpace = 0;\n                plotWidth = parentWidth;\n                plotHeight = parentHeight;\n            }\n\n            if (_tooltip) {\n                tooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n            chart.drawViz = function (element) {\n                var me = this;\n\n                element.append('rect')\n                    .attr('width', x1.bandwidth())\n                    .style('fill', function (d, i) {\n                        return UTIL.getDisplayColor(_measure.indexOf(d['tag']), _displayColor);\n                    })\n                    .style('stroke', function (d, i) {\n                        return UTIL.getBorderColor(_measure.indexOf(d['tag']), _borderColor);\n                    })\n                    .style('stroke-width', 1)\n                    .attr('x', function (d, i) {\n                        return x1(measuresBar[i]);\n                    })\n                    .attr('y', function (d, i) {\n                        if ((d['data'][measuresBar[i]] === null) || (isNaN(d['data'][measuresBar[i]]))) {\n                            return 0;\n                        } else if (d['data'][measuresBar[i]] > 0) {\n                            return y(d['data'][measuresBar[i]]);\n                        }\n\n                        return y(0);\n                    })\n                    .attr('height', function (d, i) {\n                        if ((d['data'][measuresBar[i]] === null) || (isNaN(d['data'][measuresBar[i]]))) return 0;\n                        return Math.abs(y(0) - y(d['data'][measuresBar[i]]));\n                    })\n                    .on('mouseover', _handleMouseOverFn.call(chart, tooltip, svg))\n                    .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, svg))\n                    .on('mouseout', _handleMouseOutFn.call(chart, tooltip, svg))\n                    .on('click', function (d) {\n                        if ($(\"#myonoffswitch\").prop('checked') == false) {\n                            $('#Modal_' + $(div).attr('id') + ' .measure').val(d.measure);\n                            $('#Modal_' + $(div).attr('id') + ' .threshold').val('');\n                            $('#Modal_' + $(div).attr('id') + ' .measure').attr('disabled', true);;\n                            $('#Modal_' + $(div).attr('id')).modal('toggle');\n                        }\n                        else {\n                            var confirm = d3.select('.confirm')\n                                .style('visibility', 'visible');\n                            var _filter = chart._Local_data.filter(function (d1) {\n                                return d.data[_dimension[0]] === d1[_dimension[0]]\n                            })\n                            var rect = d3.select(this);\n                            if (rect.classed('selected')) {\n                                rect.classed('selected', false);\n                                filterData.map(function (val, i) {\n                                    if (val[_dimension[0]] == d[_dimension[0]]) {\n                                        filterData.splice(i, 1)\n                                    }\n                                })\n                            } else {\n                                rect.classed('selected', true);\n                                var isExist = filterData.filter(function (val) {\n                                    if (val[_dimension[0]] == d[_dimension[0]]) {\n                                        return val\n                                    }\n                                })\n                                if (isExist.length == 0) {\n                                    filterData.push(_filter[0]);\n                                }\n                            }\n                        }\n                    })\n            }\n            chart.drawPlot = function (data) {\n                var me = this;\n                _Local_data = data;\n                var keys = UTIL.getMeasureList(data[0], _dimension);\n\n                measuresBar = [],\n                    measuresLine = [];\n                keys.forEach(function (m, i) {\n                    if (_comboChartType[_measure.indexOf(m)] == \"bar\") {\n                        measuresBar.push(m);\n                    } else {\n                        measuresLine.push(m);\n                    }\n                });\n\n                var xLabels = getXLabels(data);\n\n                var plot = container.append('g')\n                    .attr('class', 'combo-plot')\n                    .classed('plot', true)\n                    .attr('transform', function () {\n                        if (_legendPosition == 'top') {\n                            return 'translate(' + margin.left + ', ' + parseInt(legendSpace * 2 + (20 * parseInt(legendBreakCount))) + ')';\n                        } else if (_legendPosition == 'bottom') {\n                            return 'translate(' + margin.left + ', 0)';\n                        } else if (_legendPosition == 'left') {\n                            return 'translate(' + (legendSpace + margin.left + axisLabelSpace) + ', 0)';\n                        } else if (_legendPosition == 'right') {\n                            return 'translate(' + margin.left + ', 0)';\n                        }\n                    });\n\n                var content = plot.append('g')\n                    .attr('class', 'chart')\n\n                var labelStack = [];\n\n                x0 = d3.scaleBand()\n                    .domain(xLabels)\n                    .rangeRound([0, plotWidth])\n                    .padding([0.2]);\n\n                x1 = d3.scaleBand()\n                    .domain(measuresBar)\n                    .rangeRound([0, x0.bandwidth()])\n                    .padding([0.2]);\n\n                y = d3.scaleLinear()\n                    .range([plotHeight, 0]);\n\n                y.domain([0, d3.max(data, function (d) {\n                    return d3.max(keys, function (key) {\n                        return parseInt(d[key]);\n                    });\n                })]).nice();\n\n                var tickLength = d3.scaleLinear()\n                    .domain([22, 34])\n                    .range([4, 6]);\n\n                var areaGenerator = d3.area()\n                    .curve(d3.curveLinear)\n                    .x(function (d, i) {\n                        return x0(d['data'][_dimension[0]]) + x0.bandwidth() / 2;\n                    })\n                    .y0(plotHeight)\n                    .y1(function (d) {\n                        return y(d['data'][d['tag']]);\n                    });\n\n                var lineGenerator = d3.line()\n                    .curve(d3.curveLinear)\n                    .x(function (d, i) {\n                        return x0(d['data'][_dimension[0]]) + x0.bandwidth() / 2;\n                    })\n                    .y(function (d, i) {\n                        return y(d['data'][d['tag']]);\n                    });\n\n                var clusterBar = content.selectAll('.cluster_bar')\n                    .data(data)\n                    .enter().append('g')\n                    .attr('class', 'cluster_bar')\n                    .attr('transform', function (d) {\n                        return 'translate(' + x0(d[_dimension[0]]) + ', 0)';\n                    });\n\n                var bar = clusterBar.selectAll('g.bar')\n                    .data(function (d) {\n                        return measuresBar\n                            .filter(function (m) { return labelStack.indexOf(m) == -1; })\n                            .map(function (m) { return { \"tag\": m, \"data\": d }; });\n                    })\n                    .enter().append('g')\n                    .attr('class', 'bar');\n\n                chart.drawViz(bar)\n\n                var clusterLine = content.selectAll('.cluster_line')\n                    .data(measuresLine.filter(function (m) { return labelStack.indexOf(m) == -1; }))\n                    .enter().append('g')\n                    .attr('class', 'cluster_line');\n\n                var area = clusterLine.append('path')\n                    .datum(function (d, i) {\n                        return data.map(function (datum) { return { \"tag\": d, \"data\": datum }; });\n                    })\n                    .attr('class', 'area')\n                    .attr('fill', function (d, i) {\n                        return UTIL.getDisplayColor(_measure.indexOf(d[0]['tag']), _displayColor);\n                    })\n                    .attr('visibility', function (d, i) {\n                        if (_lineType[(_measure.indexOf(d[0]['tag']))] == \"area\") {\n                            return 'visible'\n                        }\n                        else {\n                            return 'hidden';\n                        }\n\n                    })\n                    .style('fill-opacity', 0.5)\n                    .attr('stroke', 'none')\n                    .attr('d', areaGenerator);\n\n                var line = clusterLine.append('path')\n                    .datum(function (d, i) {\n                        return data.map(function (datum) { return { \"tag\": d, \"data\": datum }; });\n                    })\n                    .attr('class', 'line')\n                    .attr('fill', 'none')\n                    .attr('stroke', function (d, i) {\n                        return UTIL.getBorderColor(_measure.indexOf(d[0]['tag']), _borderColor);\n                    })\n                    .attr('stroke-linejoin', 'round')\n                    .attr('stroke-linecap', 'round')\n                    .attr('stroke-width', 1)\n                    .on(\"mouseover\", function (d) {\n                        d3.select(this)\n                            .style(\"stroke-width\", \"2.5px\")\n                            .style(\"cursor\", \"pointer\");\n                    })\n                    .on(\"mouseout\", function (d) {\n                        d3.select(this)\n                            .style(\"stroke-width\", \"1.5px\")\n                            .style(\"cursor\", \"none\");\n                    })\n                    .attr('d', lineGenerator);\n\n                var point = clusterLine.selectAll('point')\n                    .data(function (d, i) {\n                        return data.map(function (datum) { return { \"tag\": d, \"data\": datum }; });\n                    })\n                    .enter().append('path')\n                    .attr('class', 'point')\n                    .attr('fill', function (d, i) {\n                        return UTIL.getDisplayColor(_measure.indexOf(d.tag), _displayColor);\n                    })\n                    .attr('d', function (d, i) {\n                        return d3.symbol()\n                            .type(getPointType(_measure.indexOf(d.tag)))\n                            .size(40)();\n                    })\n                    .attr('transform', function (d) {\n                        return 'translate('\n                            + (x0(d['data'][_dimension[0]]) + x0.bandwidth() / 2)\n                            + ',' + y(d['data'][d['tag']]) + ')';\n                    })\n                    .on('mouseover', _handleMouseOverFn.call(chart, tooltip, svg))\n                    .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, svg))\n                    .on('mouseout', _handleMouseOutFn.call(chart, tooltip, svg));\n\n                plot.append(\"g\")\n                    .attr(\"class\", \"x_axis\")\n                    .attr(\"transform\", \"translate(0,\" + plotHeight + \")\")\n                    .call(d3.axisBottom(x0))\n                    .append(\"text\")\n                    .attr(\"x\", plotWidth / 2)\n                    .attr(\"y\", 2 * axisLabelSpace)\n                    .attr(\"dy\", \"0.32em\")\n                    .attr(\"fill\", \"#000\")\n                    .attr(\"font-weight\", \"bold\")\n                    .style('text-anchor', 'middle')\n                    .style('visibility', UTIL.getVisibility(_showXaxisLabel))\n                    .text(function () {\n                        return _displayName;\n                    });\n\n                plot.append(\"g\")\n                    .attr(\"class\", \"y_axis\")\n                    .call(d3.axisLeft(y).ticks(null, \"s\"))\n                    .append(\"text\")\n                    .attr(\"x\", plotHeight / 2)\n                    .attr(\"y\", 2 * axisLabelSpace)\n                    .attr(\"transform\", function (d) { return \"rotate(\" + 90 + \")\"; })\n                    .attr(\"dy\", \"0.32em\")\n                    .style('visibility', UTIL.getVisibility(_showYaxisLabel))\n                    .attr(\"font-weight\", \"bold\")\n                    .style('text-anchor', 'middle')\n                    .text(function () {\n                        return _displayNameForMeasure.map(function (p) { return p; }).join(', ');\n                    });\n\n                UTIL.setAxisColor(svg, _yAxisColor, _xAxisColor, _showYaxis, _showXaxis, _showYaxis, _showXaxis);\n                svg.select('g.combo-sort').remove();\n                var sortButton = container.append('g')\n                    .attr('class', 'combo-sort')\n                    .attr('transform', function () {\n                        return 'translate(0, ' + parseInt((parentHeight - 2 * COMMON.PADDING + 20 + (legendBreakCount * 20))) + ')';\n                    })\n\n                var ascendingSort = sortButton.append('svg:text')\n                    .attr('fill', '#afafaf')\n                    .attr('cursor', 'pointer')\n                    .style('font-family', 'FontAwesome')\n                    .style('font-size', 12)\n                    .attr('transform', function () {\n                        return 'translate(' + (parentWidth - 3 * offsetX) + ', ' + 2 * axisLabelSpace + ')';\n                    })\n                    .style('text-anchor', 'end')\n                    .text(function () {\n                        return \"\\uf161\";\n                    })\n                    .on('click', UTIL.toggleSortSelection(me, 'ascending', chart.drawPlot, svg, keys, _Local_data))\n\n\n                var descendingSort = sortButton.append('svg:text')\n                    .attr('fill', '#afafaf')\n                    .attr('cursor', 'pointer')\n                    .style('font-family', 'FontAwesome')\n                    .style('font-size', 12)\n                    .attr('transform', function () {\n                        return 'translate(' + (parentWidth - 1.5 * offsetX) + ', ' + 2 * axisLabelSpace + ')';\n                    })\n                    .style('text-anchor', 'end')\n                    .text(function () {\n                        return \"\\uf160\";\n                    })\n                    .on('click', UTIL.toggleSortSelection(me, 'descending', chart.drawPlot, svg, keys, _Local_data))\n\n                var resetSort = sortButton.append('svg:text')\n                    .attr('fill', '#afafaf')\n                    .attr('cursor', 'pointer')\n                    .style('font-family', 'FontAwesome')\n                    .style('font-size', 12)\n                    .attr('transform', function () {\n                        return 'translate(' + parentWidth + ', ' + 2 * axisLabelSpace + ')';\n                    })\n                    .style('text-anchor', 'end')\n                    .text(function () {\n                        return \"\\uf0c9\";\n                    })\n                    .on('click', function () {\n                        d3.select(me.parentElement).select('.combo-plot').remove();\n                        chart.drawPlot.call(me, _Local_data);\n                    });\n\n                d3.select(div).select('.btn-primary')\n                    .on('click', applyFilter(chart));\n\n                d3.select(div).select('.btn-default')\n                    .on('click', clearFilter());\n\n                var lasso = d3.lasso()\n                    .hoverSelect(true)\n                    .closePathSelect(true)\n                    .closePathDistance(100)\n                    .items(bar)\n                    .targetArea(svg);\n\n                lasso.on('start', onLassoStart(lasso, chart))\n                    .on('draw', onLassoDraw(lasso, chart))\n                    .on('end', onLassoEnd(lasso, chart));\n\n                svg.call(lasso);\n            }\n\n            chart.drawPlot.call(this, data)\n        });\n    }\n\n    chart._legendInteraction = function (event, data) {\n        var clustered = d3.selectAll('g.bar')\n            .filter(function (d) {\n                return d.tag === data;\n            });\n\n        var line = d3.selectAll('.line')\n            .filter(function (d, i) {\n                return d[i].tag === data;\n            });\n\n        if (event === 'mouseover') {\n            clustered.select('rect')\n                .style('fill', COMMON.HIGHLIGHTER);\n            line\n                .style(\"stroke-width\", \"2.5px\")\n                .style('stroke', COMMON.HIGHLIGHTER);\n\n        } else if (event === 'mousemove') {\n            // do something\n        } else if (event === 'mouseout') {\n            clustered.select('rect')\n                .style('fill', function (d, i) {\n                    return UTIL.getDisplayColor(_measure.indexOf(d.tag), _displayColor);\n                });\n            line\n                .style(\"stroke-width\", \"1.5px\")\n                .style('stroke', function (d, i) {\n                    return UTIL.getBorderColor(_measure.indexOf(d[0]['tag']), _borderColor);\n                });\n        } else if (event === 'click') {\n\n        }\n    }\n\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.update = function (data) {\n\n        chart._Local_data = data,\n            svg = _local_svg;\n        filterData = [];\n        var xLabels = getXLabels(data);\n        var keys = Object.keys(data[0]);\n\n        keys.splice(keys.indexOf(_dimension[0]), 1);\n        measuresBar = [], measuresLine = [];\n        keys.forEach(function (m, i) {\n            if (_comboChartType[_measure.indexOf(m)] == \"bar\") {\n                measuresBar.push(m);\n            } else {\n                measuresLine.push(m);\n            }\n        });\n\n        x0 = d3.scaleBand()\n            .domain(xLabels)\n            .rangeRound([0, plotWidth])\n            .padding([0.2]);\n\n        x1 = d3.scaleBand()\n            .domain(measuresBar)\n            .rangeRound([0, x0.bandwidth()])\n            .padding([0.2]);\n\n        y = d3.scaleLinear()\n            .range([plotHeight, 0]);\n\n        y.domain([0, d3.max(data, function (d) {\n            return d3.max(keys, function (key) {\n                return parseInt(d[key]);\n            });\n        })]).nice();\n\n        var plot = svg.select('.plot')\n        var chartploat = svg.select('.chart')\n        var labelStack = [];\n\n        var areaGenerator = d3.area()\n            .curve(d3.curveLinear)\n            .x(function (d, i) {\n                return x0(d['data'][_dimension[0]]) + x0.bandwidth() / 2;\n            })\n            .y0(plotHeight)\n            .y1(function (d) {\n                return y(d['data'][d.tag[0].tag]);\n            });\n\n        var lineGenerator = d3.line()\n            .curve(d3.curveLinear)\n            .x(function (d, i) {\n                return x0(d['data'][_dimension[0]]) + x0.bandwidth() / 2;\n            })\n            .y(function (d, i) {\n                return y(d['data'][d.tag[0].tag])!=undefined?y(d['data'][d.tag[0].tag]):y(d.tag[0].tag[0].tag);\n            });\n\n        var area = plot.selectAll('path.area')\n            .datum(function (d, i) {\n                return data.map(function (datum) { return { \"tag\": d, \"data\": datum }; });\n            })\n            .attr('d', areaGenerator);\n\n        plot.selectAll('path.point').remove()\n\n\n        var line = plot.selectAll('path.line')\n            .datum(function (d, i) {\n                return data.map(function (datum) { return { \"tag\": d, \"data\": datum }; });\n            })\n            .attr('d', lineGenerator);\n\n        var clusterBar = chartploat.selectAll('g.cluster_bar')\n            .data(data)\n\n        clusterBar.enter().append('g')\n            .attr('class', 'cluster_bar')\n            .attr('transform', function (d) {\n                return 'translate(' + x0(d[_dimension[0]]) + ', 0)';\n            });\n\n        clusterBar.exit().remove();\n\n        clusterBar = plot.selectAll('g.cluster_bar');\n\n        var bar = clusterBar.selectAll('g.bar')\n            .data(function (d) {\n                return measuresBar\n                    .filter(function (m) { return labelStack.indexOf(m) == -1; })\n                    .map(function (m) { return { \"tag\": m, \"data\": d }; });\n            })\n\n        bar.select('rect')\n            .attr('width', x1.bandwidth())\n            .style('stroke-width', 1)\n            .attr('x', function (d, i) {\n                return x1(measuresBar[measuresBar.indexOf(d.tag)]);\n            })\n            .attr('y', function (d, i) {\n                if ((d[\"data\"][d.tag] === null) || (isNaN(d[\"data\"][d.tag]))) {\n                    return 0;\n                } else if (d[\"data\"][d.tag]> 0) {\n                    return y(d[\"data\"][d.tag]);\n                }\n                return y(0);\n            })\n            .attr('height', function (d, i) {\n                return Math.abs(y(0) - y(d[\"data\"][d.tag]));\n            })\n            .classed('selected', false)\n            .classed('possible', false);\n\n\n        var newBars = bar.enter().append('g')\n            .attr('class', 'bar');\n\n        chart.drawViz(newBars)\n\n        d3.selectAll('g.cluster_bar')\n            .attr('transform', function (d) {\n                return 'translate(' + x0(d[_dimension[0]]) + ', 0)';\n            });\n\n        plot.select('.x_axis')\n            .transition()\n            .duration(1000)\n            .call(d3.axisBottom(x0));\n\n        plot.select('.y_axis')\n            .transition()\n            .duration(1000)\n            .call(d3.axisLeft(y).ticks(null, \"s\"));\n\n        UTIL.setAxisColor(svg, _yAxisColor, _xAxisColor, _showYaxis, _showXaxis);\n        UTIL.displayThreshold(threshold, data, keys);\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.showLegend = function (value) {\n        if (!arguments.length) {\n            return _showLegend;\n        }\n        _showLegend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function (value) {\n        if (!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.sort = function (value) {\n        if (!arguments.length) {\n            return _sort;\n        }\n        _sort = value;\n        return chart;\n    }\n\n    chart.tooltip = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    chart.showXaxis = function (value) {\n        if (!arguments.length) {\n            return _showXaxis;\n        }\n        _showXaxis = value;\n        return chart;\n    }\n\n    chart.showYaxis = function (value) {\n        if (!arguments.length) {\n            return _showYaxis;\n        }\n        _showYaxis = value;\n        return chart;\n    }\n\n    chart.showXaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showXaxisLabel;\n        }\n        _showXaxisLabel = value;\n        return chart;\n    }\n\n    chart.showYaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showYaxisLabel;\n        }\n        _showYaxisLabel = value;\n        return chart;\n    }\n\n    chart.xAxisColor = function (value) {\n        if (!arguments.length) {\n            return _xAxisColor;\n        }\n        _xAxisColor = value;\n        return chart;\n    }\n\n    chart.yAxisColor = function (value) {\n        if (!arguments.length) {\n            return _yAxisColor;\n        }\n        _yAxisColor = value;\n        return chart;\n    }\n\n    chart.showGrid = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _showGrid = value;\n        return chart;\n    }\n\n    chart.stacked = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _stacked = value;\n        return chart;\n    }\n\n    chart.displayName = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _displayName = value;\n        return chart;\n    }\n\n    chart.legendData = function (measureConfig, measureName) {\n        _legendData = {\n            measureConfig: measureConfig,\n            measureName: measureName\n        }\n        return _legendData;\n    }\n\n    chart.showValues = function (value) {\n        if (!arguments.length) {\n            return _showValues;\n        }\n        _showValues = value;\n        return chart;\n    }\n\n    chart.displayNameForMeasure = function (value) {\n        if (!arguments.length) {\n            return _displayNameForMeasure;\n        }\n        _displayNameForMeasure = value;\n        return chart;\n    }\n\n    chart.fontStyle = function (value) {\n        if (!arguments.length) {\n            return _fontStyle;\n        }\n        _fontStyle = value;\n        return chart;\n    }\n\n    chart.fontWeight = function (value) {\n        if (!arguments.length) {\n            return _fontWeight;\n        }\n        _fontWeight = value;\n        return chart;\n    }\n\n    chart.numberFormat = function (value) {\n        if (!arguments.length) {\n            return _numberFormat;\n        }\n        _numberFormat = value;\n        return chart;\n    }\n\n    chart.textColor = function (value) {\n        if (!arguments.length) {\n            return _textColor;\n        }\n        _textColor = value;\n        return chart;\n    }\n\n    chart.displayColor = function (value) {\n        if (!arguments.length) {\n            return _displayColor;\n        }\n        _displayColor = value;\n        return chart;\n    }\n\n    chart.borderColor = function (value) {\n        if (!arguments.length) {\n            return _borderColor;\n        }\n        _borderColor = value;\n        return chart;\n    }\n\n    chart.fontSize = function (value) {\n        if (!arguments.length) {\n            return _fontSize;\n        }\n        _fontSize = value;\n        return chart;\n    }\n\n    chart.comboChartType = function (value) {\n        if (!arguments.length) {\n            return _comboChartType;\n        }\n        _comboChartType = value;\n        return chart;\n    }\n\n    chart.lineType = function (value) {\n        if (!arguments.length) {\n            return _lineType;\n        }\n        _lineType = value;\n        return chart;\n    }\n    chart.pointType = function (value) {\n        if (!arguments.length) {\n            return _pointType;\n        }\n        _pointType = value;\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = combo;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/combo.js?");

/***/ }),

/***/ "./js/charts/donut.js":
/*!****************************!*\
  !*** ./js/charts/donut.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction donut() {\n\n    var _NAME = 'donut';\n\n    var _config,\n        _dimension,\n        _measure,\n        _showLegend,\n        _legendPosition,\n        _showValueAs,\n        _valueAsArc,\n        _valuePosition,\n        _sort,\n        _tooltip;\n\n    var _local_svg,\n        _Local_data,\n        _local_total = 0,\n        _local_transition_time = 500,\n        _local_transition_map = d3.map(),\n        _local_sorted_measure_value = [],\n        _local_tooltip;\n\n    var filter = false,\n        filterData = [];\n\n    var _pie = d3.pie()\n        .sort(null);\n\n    var _arc = d3.arc()\n        .innerRadius(0);\n\n    var _arcMask = d3.arc();\n\n    var _labelArc = d3.arc();\n\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.showLegend(config.showLegend);\n        this.legendPosition(config.legendPosition);\n        this.showValueAs(config.showValueAs);\n        this.valueAsArc(config.valueAsArc);\n        this.valuePosition(config.valuePosition);\n    }\n\n    /**\n     * Period function that stretches the rendering process\n     *\n     * @param {number} extraDuration Additional duration value in milliseconds\n     * @return {function} Accessor function that computes the duration period\n     */\n    var _durationFn = function (extraDuration) {\n        if (extraDuration === void 0) { extraDuration = 0; }\n\n        if (isNaN(+extraDuration)) {\n            throw new TypeError('Not a number');\n        }\n\n        return function (d, i) {\n            var t = _local_transition_map.get(d.value);\n\n            if (!t) {\n                t = _local_transition_time * (d.value / _local_total)\n                _local_transition_map.set(d.value, t);\n            }\n\n            return (t + extraDuration);\n        }\n    }\n\n    /**\n     * Delay function that delays the start of rendering process\n     *\n     * @param {number} extraDelay Additional delay value in milliseconds\n     * @return {function} Accessor function that computes the delay period\n     */\n    var _delayFn = function (extraDelay) {\n        if (extraDelay === void 0) { extraDelay = 0; }\n\n        if (isNaN(+extraDelay)) {\n            throw new TypeError('TypeError: Not a number');\n        }\n\n        return function (d, i) {\n            var i = _local_sorted_measure_value.indexOf(d.value),\n                t = 0;\n\n            while (i > 0) {\n                i--;\n                t += _local_transition_map.get(_local_sorted_measure_value[i]);\n            }\n\n            return (t + extraDelay);\n        }\n    }\n\n    /**\n     * Gives the value of hypotenuse using pythagorous theorem\n     *\n     * @param {number} x Value of perpendicular\n     * @param {number} y Value of base\n     * @return {number} Value of hypotenuse\n     */\n    var _pythagorousTheorem = function (x, y) {\n        if (isNaN(+x) || isNaN(+y)) {\n            throw new Error('TypeError: Not a number');\n            return 0;\n        }\n\n        return Math.sqrt(Math.pow(+x, 2) + Math.pow(+y, 2));\n    }\n\n    /**\n     * Label function to provide the label to be shown\n     *\n     * @return {function} Accessor function that identifies the label text\n     */\n    var _labelFn = function () {\n        return function (d, i) {\n            var result;\n\n            switch (_showValueAs) {\n                case 'label':\n                    result = d.data[_dimension[0]];\n                    break;\n                case 'value':\n                    result = d.data[_measure[0]];\n                    break;\n                case 'percentage':\n                    result = (100 * d.data[_measure[0]] / _local_total).toFixed(2) + ' %';\n                    break;\n                default:\n                    result = d.data[_dimension[0]];\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the arc\n     * @param {function} chart Pie chart function\n     * @return {string} String encoded HTML data\n     */\n    var _buildTooltipData = function (datum, chart) {\n        var output = \"\";\n\n        output += \"<table><tr>\"\n            + \"<th>\" + chart.dimension() + \": </th>\"\n            + \"<td>\" + datum[chart.dimension()] + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + chart.measure() + \": </th>\"\n            + \"<td>\" + datum[chart.measure()] + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var onLassoStart = function (lasso, chart) {\n        return function () {\n            if (filter) {\n                lasso.items().selectAll('path')\n                    .classed('not_possible', true)\n                    .classed('selected', false);\n            }\n        }\n    }\n\n    var onLassoDraw = function (lasso, chart) {\n        return function () {\n            filter = true;\n            lasso.items().selectAll('path')\n                .classed('selected', false);\n\n            lasso.possibleItems().selectAll('path')\n                .classed('not_possible', false)\n                .classed('possible', true);\n\n            lasso.notPossibleItems().selectAll('path')\n                .classed('not_possible', true)\n                .classed('possible', false);\n        }\n    }\n\n    var onLassoEnd = function (lasso, chart) {\n        return function () {\n            var data = lasso.selectedItems().data();\n            if (!filter) {\n                return;\n            }\n            if (data.length > 0) {\n                lasso.items().selectAll('path')\n                    .classed('not_possible', false)\n                    .classed('possible', false);\n            }\n\n            lasso.selectedItems().selectAll('path')\n                .classed('selected', true)\n\n            lasso.notSelectedItems().selectAll('path');\n\n            var confirm = d3.select('.confirm')\n                .style('visibility', 'visible');\n\n            var _filter = [];\n            data.forEach(function (d) {\n                var obj = new Object();\n                obj[chart.dimension()] = d.data[chart.dimension()]\n                obj[chart.measure()] = d.data[chart.measure()]\n                _filter.push(obj)\n            });\n            if (_filter.length > 0) {\n                filterData = _filter;\n            }\n        }\n    }\n\n    var applyFilter = function (chart) {\n        return function () {\n            if (filterData.length > 0) {\n                chart.update(filterData);\n            }\n        }\n    }\n\n    var _handleMouseOverFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'pointer');\n\n            var arcGroup = container.selectAll('g.arc')\n                .filter(function (d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcGroup.select('path')\n                .style('fill', COMMON.HIGHLIGHTER);\n\n            var arcMaskGroup = container.selectAll('g.arc-mask')\n                .filter(function (d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcMaskGroup.select('path')\n                .style('visibility', 'visible');\n\n            if (tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d.data, me), container);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            if (tooltip) {\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d.data, me), container);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'default');\n\n            var arcGroup = container.selectAll('g.arc')\n                .filter(function (d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcGroup.select('path')\n                .style('fill', function (d1, i) {\n                    return COMMON.COLORSCALE(d1.data[_dimension[0]]);\n                });\n\n            var arcMaskGroup = container.selectAll('g.arc-mask')\n                .filter(function (d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcMaskGroup.select('path')\n                .style('visibility', 'hidden');\n\n            if (tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    function chart(selection) {\n        _local_svg = selection;\n\n        selection.each(function (data) {\n            chart._Local_data = data;\n            var svg = d3.select(this),\n                width = +svg.attr('width'),\n                height = +svg.attr('height'),\n                parentWidth = width - 2 * COMMON.PADDING,\n                parentHeight = height - 2 * COMMON.PADDING,\n                outerRadius,\n                tooltip;\n\n            /* total sum of the measure values */\n            _local_total = d3.sum(data.map(function (d) { return d[_measure[0]]; }));\n\n            /* applying sort operation to the data */\n            UTIL.sorter(data, _measure, _sort);\n\n            /* extracting measure values only from the data */\n            _local_sorted_measure_value = data.map(function (d) { return +d[_measure[0]]; })\n\n            var container = svg.append('g')\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            var legendWidth = 0,\n                legendHeight = 0,\n                plotWidth = parentWidth,\n                plotHeight = parentHeight;\n\n            if (_showLegend) {\n                var donutLegend = LEGEND.bind(chart);\n\n                var result = donutLegend(data, container, {\n                    width: parentWidth,\n                    height: parentHeight\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n\n                switch (_legendPosition) {\n                    case 'top':\n                    case 'bottom':\n                        plotHeight = parentHeight - legendHeight;\n                        break;\n                    case 'right':\n                    case 'left':\n                        plotWidth = parentWidth - legendWidth;\n                        break;\n                }\n            }\n\n            if (_tooltip) {\n                tooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            chart.drawPlot = function (data) {\n                var me = this;\n                _Local_data = data;\n\n                outerRadius = Math.min(plotWidth, plotHeight) / 2.25;\n                var innerRadius = outerRadius * .5;\n\n                /* setting the outerradius of the arc */\n                _arc.outerRadius(outerRadius);\n                _arc.innerRadius(innerRadius);\n\n                /* setting the innerradius and outerradius of the masking arc */\n                _arcMask.outerRadius(outerRadius * 1.02)\n                    .innerRadius(outerRadius * 1.01);\n\n                /* setting the outerradius and innerradius of the arc */\n                _labelArc.outerRadius(outerRadius)\n                    .innerRadius(outerRadius * 0.8);\n\n                var plot = container.append('g')\n                    .attr('id', 'pie-plot')\n                    .classed('plot', true)\n                    .attr('transform', function () {\n                        var translate = [0, 0];\n\n                        switch (_legendPosition) {\n                            case 'top':\n                                translate = [(plotWidth / 2), legendHeight + (plotHeight / 2)];\n                                break;\n                            case 'bottom':\n                            case 'right':\n                                translate = [(plotWidth / 2), (plotHeight / 2)];\n                                break;\n                            case 'left':\n                                translate = [legendWidth + (plotWidth / 2), (plotHeight / 2)]\n                        }\n\n                        return 'translate(' + translate.toString() + ')';\n                    });\n\n                var pieMask = plot.append('g')\n                    .selectAll('.arc-mask')\n                    .data(_pie(data))\n                    .enter().append('g')\n                    .attr('id', function (d, i) {\n                        return 'arc-mask-group-' + i;\n                    })\n                    .attr('class', 'arc-mask')\n                    .append('path')\n                    .attr('id', function (d, i) {\n                        return 'arc-mask-path-' + i;\n                    })\n                    .attr('d', _arcMask)\n                    .style('visibility', 'hidden')\n                    .style('fill', function (d) {\n                        return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                    })\n\n                var pieArcGroup = plot.append('g')\n                    .selectAll('.arc')\n                    .data(_pie(data))\n                    .enter().append('g')\n                    .attr('id', function (d, i) {\n                        return 'arc-group-' + i;\n                    })\n                    .attr('class', 'arc')\n\n                var pieArcPath = pieArcGroup.append('path')\n                    .attr('id', function (d, i) {\n                        return 'arc-path-' + i;\n                    })\n                    .style('fill', function (d) {\n                        return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                    })\n                    .on('mouseover', _handleMouseOverFn.call(chart, tooltip, svg))\n                    .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, svg))\n                    .on('mouseout', _handleMouseOutFn.call(chart, tooltip, svg))\n                    .on('click', function (d, i) {\n                        var confirm = d3.select('.confirm')\n                            .style('visibility', 'visible');\n                        filter = false;\n                        var filter = {};\n                        var point = d3.select(this);\n                        if (point.classed('selected')) {\n                            point.classed('selected', false);\n                        } else {\n                            point.classed('selected', true);\n                        }\n                        var obj = new Object();\n                        obj[chart.dimension()] = d.data[chart.dimension()]\n                        obj[chart.measure()] = d.data[chart.measure()]\n                        filterData.push(obj)\n                    });\n\n                pieArcPath.transition()\n                    .duration(_durationFn())\n                    .delay(_delayFn())\n                    .attrTween('d', function (d) {\n                        var i = d3.interpolate(d.startAngle + 0.1, d.endAngle);\n                        return function (t) {\n                            d.endAngle = i(t);\n                            return _arc(d)\n                        }\n                    });\n\n                var pieLabel;\n\n                if (_valueAsArc) {\n                    pieLabel = pieArcGroup.append('text')\n                        .attr('dy', function (d, i) {\n                            if (_valuePosition == 'inside') {\n                                return 10;\n                            } else {\n                                return -5;\n                            }\n                        })\n\n                    pieLabel.append('textPath')\n                        .attr('xlink:href', function (d, i) {\n                            return '#arc-path-' + i;\n                        })\n                        .attr('text-anchor', function () {\n                            return 'middle';\n                        })\n                        .transition()\n                        .delay(_delayFn(200))\n                        .on('start', function () {\n                            d3.select(this).attr('startOffset', function (d) {\n                                var length = pieArcPath.nodes()[d.index].getTotalLength(),\n                                    diff = d.endAngle - d.startAngle,\n                                    x = 2 * (outerRadius - innerRadius) + diff * innerRadius;\n\n                                return 50 * (length - x) / length + \"%\";\n                            })\n                                .text(_labelFn())\n                                .filter(function (d, i) {\n                                    var diff = d.endAngle - d.startAngle;\n                                    return outerRadius * diff - 5 < this.getComputedTextLength();\n                                })\n                                .remove();\n                        });\n                } else {\n                    var pieArcTextGroup = plot.selectAll('.arc-text')\n                        .data(_pie(data))\n                        .enter().append('g')\n                        .attr('id', function (d, i) {\n                            return 'arc-text-group-' + i;\n                        })\n                        .attr('class', 'arc-text');\n\n                    pieLabel = pieArcTextGroup.append('text')\n                        .attr('transform', function (d) {\n                            var centroid = _labelArc.centroid(d),\n                                x = centroid[0],\n                                y = centroid[1],\n                                h = _pythagorousTheorem(x, y);\n\n                            if (_valuePosition == 'inside') {\n                                return 'translate('\n                                    + outerRadius * (x / h) * 0.85\n                                    + ', '\n                                    + outerRadius * (y / h) * 0.85\n                                    + ')';\n                            } else {\n                                return 'translate('\n                                    + outerRadius * (x / h) * 1.05\n                                    + ', '\n                                    + outerRadius * (y / h) * 1.05\n                                    + ')';\n                            }\n                        })\n                        .attr('dy', '0.35em')\n                        .attr('text-anchor', function (d) {\n                            if (_valuePosition == 'inside') {\n                                return 'middle';\n                            } else {\n                                return (d.endAngle + d.startAngle) / 2 > Math.PI\n                                    ? 'end' : (d.endAngle + d.startAngle) / 2 < Math.PI\n                                        ? 'start' : 'middle';\n                            }\n                        })\n                        .transition()\n                        .delay(_delayFn(200))\n                        .on('start', function () {\n                            d3.select(this).text(_labelFn())\n                                .filter(function (d) {\n                                    /* length of arc = angle in radians * radius */\n                                    var diff = d.endAngle - d.startAngle;\n                                    return outerRadius * diff < this.getComputedTextLength();\n                                })\n                                .remove();\n                        });\n                }\n\n                svg.select('g.lasso').remove()\n                var lasso = d3.lasso()\n                    .hoverSelect(true)\n                    .closePathSelect(true)\n                    .closePathDistance(100)\n                    .items(pieArcGroup)\n                    .targetArea(plot);\n\n                lasso.on('start', onLassoStart(lasso, chart))\n                    .on('draw', onLassoDraw(lasso, chart))\n                    .on('end', onLassoEnd(lasso, chart));\n\n                d3.select('.confirm')\n                    .on('click', applyFilter(chart));\n\n                plot.call(lasso);\n            }\n            chart.drawPlot.call(this, data);\n        });\n    }\n\n    /**\n     * Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the arc\n     * @param {function} chart Pie chart function\n     * @return {string} String encoded HTML data\n     */\n    chart._legendInteraction = function (event, data) {\n        var arcGroup = d3.selectAll('g.arc')\n            .filter(function (d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            });\n\n        if (event === 'mouseover') {\n            arcGroup.select('path')\n                .style('fill', COMMON.HIGHLIGHTER);\n        } else if (event === 'mousemove') {\n            // do something\n        } else if (event === 'mouseout') {\n            arcGroup.select('path')\n                .style('fill', function (d, i) {\n                    return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                });\n        } else if (event === 'click') {\n\n        }\n    }\n\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    var _mergeForTransition = function (fData, sData) {\n        var secondSet = d3.set();\n\n        sData.forEach(function (d) {\n            secondSet.add(d[_dimension[0]]);\n        });\n\n        var onlyFirst = fData.filter(function (d) {\n            return !secondSet.has(d[_dimension[0]]);\n        })\n            .map(function (d) {\n                var obj = {};\n\n                obj[_dimension[0]] = d[_dimension[0]];\n                obj[_measure[0]] = 0;\n\n                return obj;\n            });\n\n        return d3.merge([sData, onlyFirst])\n            .sort(function (a, b) {\n                return a[_measure[0]] > b[_measure] ? _sort\n                    : a[_measure[0]] < b[_measure] ? -_sort\n                        : 0;\n            })\n    }\n\n    chart.update = function (data) {\n        var svg = _local_svg;\n        filter = false;\n        filterData = [];\n        var key = function (d) {\n            return d.data[_dimension[0]];\n        };\n\n        var prevData = svg.selectAll('g.arc')\n            .data().map(function (d) { return d.data });\n\n        if (prevData.length == 0) {\n            prevData = data;\n        }\n\n        var oldFilteredData = _mergeForTransition(data, prevData),\n            newFilteredData = _mergeForTransition(prevData, data);\n\n        d3.selectAll('path.selected').classed('selected', false);\n\n        var pieArcGroup = svg.selectAll('g.arc')\n            .data(_pie(oldFilteredData), key)\n            .enter()\n            .insert('g')\n            .attr('id', function (d, i) {\n                return 'arc-group-' + i;\n            })\n            .attr('class', 'arc');\n\n        var pieArcPath = pieArcGroup.append('path')\n            .attr('id', function (d, i) {\n                return 'arc-path-' + i;\n            })\n            .style('fill', function (d) {\n                return COMMON.COLORSCALE(d.data[_dimension[0]]);\n            })\n            .each(function (d) {\n                this._current = d;\n            });\n\n        pieArcGroup = svg.selectAll('g.arc')\n            .data(_pie(newFilteredData), key);\n\n        pieArcGroup.select('path')\n            .transition().duration(1000)\n            .attrTween('d', function (d) {\n                var interpolate = d3.interpolate(this._current, d);\n                var _this = this;\n                return function (t) {\n                    _this._current = interpolate(t);\n                    return _arc(_this._current);\n                };\n            });\n\n        pieArcGroup = svg.selectAll('g.arc')\n            .data(_pie(data), key);\n\n        pieArcGroup.exit()\n            .transition()\n            .delay(1000)\n            .duration(0)\n            .remove();\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        _pie.value(function (d) { return d[_measure[0]]; });\n        return chart;\n    }\n\n    chart.showLegend = function (value) {\n        if (!arguments.length) {\n            return _showLegend;\n        }\n        _showLegend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function (value) {\n        if (!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.showValueAs = function (value) {\n        if (!arguments.length) {\n            return _showValueAs;\n        }\n        _showValueAs = value;\n        return chart;\n    }\n\n    chart.valueAsArc = function (value) {\n        if (!arguments.length) {\n            return _valueAsArc;\n        }\n        _valueAsArc = value;\n        return chart;\n    }\n\n    chart.valuePosition = function (value) {\n        if (!arguments.length) {\n            return _valuePosition;\n        }\n        _valuePosition = value;\n        return chart;\n    }\n\n    chart.sort = function (value) {\n        if (!arguments.length) {\n            return _sort;\n        }\n        _sort = value;\n        return chart;\n    }\n\n    chart.tooltip = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = donut;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/donut.js?");

/***/ }),

/***/ "./js/charts/heatmap.js":
/*!******************************!*\
  !*** ./js/charts/heatmap.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction heatmap() {\n\n    var _NAME = 'heatmap';\n\n    var _config,\n        _dimension,\n        _measure,\n        dimLabelColor,\n        displayName,\n        fontStyleForDimension,\n        fontWeightForDimension,\n        fontSizeForDimension,\n\n        showValues = [],\n        displayNameForMeasure = [],\n        showIcon = [],\n        valuePosition = [],\n        iconName = [],\n        iconFontWeight = [],\n        iconColor = [],\n        iconPosition = [],\n        showIcon = [],\n        colourCoding = [],\n        valueTextColour = [],\n        fontStyleForMeasure = [],\n        fontWeightForMeasure = [],\n        numberFormat = [],\n        fontSizeForMeasure = [];\n\n    var _local_svg, _Local_data, _originalData, _localLabelStack = [];\n    var width, height, cellWidth, cellHeight;\n    var margin = {\n        top: 30,\n        right: 15,\n        bottom: 15,\n        left: 45\n    };\n    var yScale = d3.scaleBand(),\n        xScale = d3.scaleBand();\n\n\n    var filter = false, filterData = [];\n\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.dimLabelColor(config.dimLabelColor);\n        this.displayName(config.displayName);\n        this.fontStyleForDimension(config.fontStyleForDimension);\n        this.fontWeightForDimension(config.fontWeightForDimension);\n        this.fontSizeForDimension(config.fontSizeForDimension);\n        this.showValues(config.showValues);\n        this.displayNameForMeasure(config.displayNameForMeasure);\n        this.showIcon(config.showIcon);\n        this.valuePosition(config.valuePosition);\n        this.iconName(config.iconName);\n        this.iconFontWeight(config.iconFontWeight);\n        this.iconColor(config.iconColor);\n        this.iconPosition(config.iconPosition);\n        this.showIcon(config.showIcon)\n        this.colourCoding(config.colourCoding);\n        this.valueTextColour(config.valueTextColour);\n        this.fontStyleForMeasure(config.fontStyleForMeasure);\n        this.fontWeightForMeasure(config.fontWeightForMeasure);\n        this.numberFormat(config.numberFormat);\n        this.fontSizeForMeasure(config.fontSizeForMeasure);\n    }\n\n    var _buildTooltipData = function (datum, chart) {\n        var output = \"\";\n\n        output += \"<table><tr>\"\n            + \"<th>\" + chart.dimension() + \": </th>\"\n            + \"<td>\" + datum.y + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + datum.x + \": </th>\"\n            + \"<td>\" + datum.val + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var _handleMouseOverFn = function (tooltip, container) {\n        var me = this;\n        return function (d, i) {\n            d3.select(this).select('rect').style('cursor', 'pointer')\n                .style('cursor', 'pointer')\n                .style('fill-opacity', .5);\n            var border = d3.select(this).attr('fill');\n            if (tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container, border);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            if (tooltip) {\n                var border = getFillColor(d);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me, border), container, border);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).select('rect').style('cursor', 'default')\n                .style('fill', function (d1, i) {\n                    return getFillColor(d);\n                })\n                .style('fill-opacity', 1);\n\n            if (tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n\n    var transformData = function (data) {\n        var me = this;\n        var result = [];\n        var x, y, val;\n\n        data.forEach(function (d) {\n            d3.range(_measure.length).forEach(function (j) {\n                x = _measure[j];\n                y = d[_dimension];\n                val = d[_measure[j]] || 0;\n                result.push({\n                    x: x,\n                    y: y,\n                    column: j,\n                    val: val\n                });\n            })\n        });\n\n        return result;\n    }\n\n\n    var getFillColor = function (data) {\n        var colorProp = colourCoding[_measure.indexOf(data.x)],\n            val = data.val,\n            result;\n\n        if (isNaN(val)) {\n            return colorProp.filter(function (c) { return c.hasOwnProperty('default'); })[0]['color'];\n        }\n\n        colorProp.some(function (c) {\n            if (c.hasOwnProperty('upto')) {\n                if (val <= c.upto) {\n                    result = c.color;\n                    return true;\n                }\n            } else {\n                result = c.color;\n                return true;\n            }\n        });\n\n        return result || \"#efefef\";\n    }\n    var getIconPosition = function (data, width) {\n        var iconProp = iconPosition[_measure.indexOf(data.x)]\n        var padding = 4;\n\n        var offset;\n\n        switch (iconProp) {\n            case 'left':\n                offset = 0 + padding;\n                break;\n            case 'center':\n                offset = width / 2 - 2 * padding;\n                break;\n            case 'right':\n                offset = width - 5 * padding;\n                break;\n        }\n\n        return offset;\n    }\n    var getValuePosition = function (data, width) {\n        var valPosition = valuePosition[_measure.indexOf(data.x)];\n        var padding = 4;\n\n        var offset;\n\n        switch (valPosition) {\n            case 'left':\n                offset = 0 + padding;\n                break;\n            case 'center':\n                offset = width / 2;\n                break;\n            case 'right':\n                offset = width - padding;\n                break;\n        }\n\n        return offset;\n    }\n    var getValueTextAnchor = function (data) {\n        var valPosition = valuePosition[_measure.indexOf(data.x)];\n\n        var anchor;\n\n        switch (valPosition) {\n            case 'left':\n                anchor = 'start';\n                break;\n            case 'center':\n                anchor = 'middle';\n                break;\n            case 'right':\n                anchor = 'end';\n                break;\n        }\n\n        return anchor;\n    }\n\n    var onLassoStart = function (lasso, chart) {\n        return function () {\n            if (filter) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', true)\n                    .classed('selected', false);\n            }\n        }\n    }\n\n    var onLassoDraw = function (lasso, chart) {\n        return function () {\n            filter = true;\n            lasso.items().selectAll('rect')\n                .classed('selected', false);\n\n            lasso.possibleItems().selectAll('rect')\n                .classed('not_possible', false)\n                .classed('possible', true);\n\n            lasso.notPossibleItems().selectAll('rect')\n                .classed('not_possible', true)\n                .classed('possible', false);\n        }\n    }\n\n    var onLassoEnd = function (lasso, chart) {\n        return function () {\n            var data = lasso.selectedItems().data();\n            debugger\n            if (!filter) {\n                return;\n            }\n            if (data.length > 0) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', false)\n                    .classed('possible', false);\n            }\n\n            lasso.selectedItems().selectAll('rect')\n                .classed('selected', true)\n\n            lasso.notSelectedItems().selectAll('rect');\n\n            var confirm = d3.select('.confirm')\n                .style('visibility', 'visible');\n\n            var _filter = [];\n            if (data.length > 0) {\n                data.forEach(function (d) {\n                    var temp = d.y;\n                    var searchObj = _filter.find(o => o[_dimension[0]] === temp);\n                    if (searchObj == undefined) {\n                        var tempData = _localData.filter(function (val) {\n                            return val[_dimension[0]] === d.y\n                        })\n                        _filter.push(tempData[0])\n                    }\n                })\n                if (_filter.length > 0) {\n                    filterData = _filter;\n                }\n            }\n        }\n    }\n\n    var applyFilter = function (chart) {\n        return function () {\n            if (filterData.length > 0) {\n                chart.update(filterData);\n            }\n        }\n    }\n\n    var clearFilter = function () {\n        return function () {\n            chart.update(_originalData);\n        }\n    }\n\n    var drawViz = function (element) {\n        element.append('rect')\n            .attr('rx', '3px')\n            .attr('ry', '3px')\n            .attr('class', 'bordered')\n            .style('stroke', '#ffffff')\n            .style('stroke-width', '2px')\n            .attr('width', cellWidth - 1)\n            .attr('height', cellHeight - 1)\n            .transition()\n            .ease(d3.easeQuadIn)\n            .duration(500)\n            .styleTween('fill', function (d) {\n                return d3.interpolateRgb('transparent', getFillColor(d));\n            });\n\n        element.on('mouseover', _handleMouseOverFn.call(chart, tooltip, _local_svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, _local_svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, tooltip, _local_svg))\n            .on('click', function (d) {\n                var confirm = d3.select('.confirm')\n                    .style('visibility', 'visible');\n                var _filter = _localData.filter(function (d1) {\n                    return d.y === d1[_dimension[0]]\n                })\n                var rect = d3.select(this).select('rect');\n                if (rect.classed('selected')) {\n                    rect.classed('selected', false);\n                    filterData.map(function (val, i) {\n                        if (val[_dimension[0]] == d[_dimension[0]]) {\n                            filterData.splice(i, 1)\n                        }\n                    })\n                } else {\n                    rect.classed('selected', true);\n                    var isExist = filterData.filter(function (val) {\n                        if (val[_dimension[0]] == d[_dimension[0]]) {\n                            return val\n                        }\n                    })\n                    if (isExist.length == 0) {\n                        filterData.push(_filter[0]);\n                    }\n                }\n            });\n\n        element.append('foreignObject')\n            .attr('x', function (d) {\n                return getIconPosition(d, cellWidth);\n            })\n            .attr('y', function (d) {\n                return cellHeight - 20;\n            })\n            .attr('visibility', function (d) {\n                return UTIL.getVisibility(showIcon[_measure.indexOf(d.x)]);\n            })\n            .html(function (d) {\n                return '<i class=\"' + iconName[_measure.indexOf(d.x)] + '\" aria-hidden=\"true\" style=\"font-weight:' + iconFontWeight[_measure.indexOf(d.x)] + ';color:' + iconColor[_measure.indexOf(d.x)] + '\"></i>';\n            });\n\n        element.append('text')\n            .attr('x', function (d) {\n                return getValuePosition(d, cellWidth);\n            })\n            .attr('y', function (d) {\n                return cellHeight / 2;\n            })\n            .text(function (d) {\n                var si = numberFormat[_measure.indexOf(d.x)],\n                    nf = UTIL.getNumberFormatter(si),\n                    value;\n\n                if (si == \"Percent\") {\n                    // value = nf(d.val / me.helper.measuresTotal[d.x]);\n                } else {\n                    value = nf(d.val);\n                }\n\n                if (value.indexOf(\"G\") != -1) {\n                    value = value.slice(0, -1) + \"B\";\n                }\n\n                return value;\n            })\n            .style('fill', function (d) {\n                return valueTextColour[_measure.indexOf(d.x)];\n            })\n            .attr('text-anchor', function (d) {\n                return getValueTextAnchor(d);\n            })\n            .attr('visibility', function (d) {\n                return showValues[_measure.indexOf(d.x)];\n            })\n            .style('font-style', function (d) {\n                return fontStyleForMeasure[_measure.indexOf(d.x)];\n            })\n            .style('font-weight', function (d) {\n                return fontWeightForMeasure[_measure.indexOf(d.x)];\n            })\n            .style('font-size', function (d) {\n                return fontSizeForMeasure[_measure.indexOf(d.x)];\n            });\n    }\n\n    function chart(selection) {\n        _local_svg = selection;\n\n        selection.each(function (data) {\n\n            var div = d3.select(this).node().parentNode;\n            _local_svg = d3.select(this);\n\n            width = div.clientWidth\n            height = div.clientHeight\n\n            var svg = d3.select(this);\n\n            svg.selectAll('g').remove();\n\n\n            var plot = svg.attr('width', width)\n                .attr('height', height)\n                .append('g')\n                .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n\n            /* store the data in local variable */\n            _localData = _originalData = data;\n            var me = this;\n            svg.selectAll('g').remove();\n\n            var plot = svg.attr('width', width)\n                .attr('height', height)\n                .append('g')\n                .attr('class', 'plot')\n                .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n\n            var yElement = d3.set(data.map(function (item) { return item[_dimension[0]]; })).values();\n            var xElement = d3.map();\n\n            for (var i = 0; i < _measure.length; i++) {\n                xElement.set(i, _measure[i]);\n            }\n\n            cellWidth = parseInt((width - margin.left - margin.right) / _measure.length),\n                cellHeight = parseInt((height - margin.top - margin.bottom) / data.length);\n            var offset = 6;\n            var dimLabel = plot.selectAll('.dimLabel')\n                .data(yElement)\n                .enter().append('text')\n                .attr('class', 'dimLabel')\n                .text(function (d) { return d; })\n                .text(function (d) {\n                    return d;\n                })\n                .attr('x', 0)\n                .attr('y', function (d, i) { return i * cellHeight; })\n                .attr('fill', dimLabelColor)\n                .style('font-style', fontStyleForDimension)\n                .style('font-weight', fontWeightForDimension)\n                .style('font-size', fontSizeForDimension)\n                .style('text-anchor', 'end')\n                .attr('transform', 'translate(' + -offset + ',' + cellHeight / 1.75 + ')');\n\n            var mesLabel = plot.selectAll('.mesLabel')\n                .data(xElement.values().map(function (mes) {\n                    return displayNameForMeasure[_measure.indexOf(mes)];\n                }))\n                .enter().append('text')\n                .attr('class', 'mesLabel')\n                .text(function (d) { return d; })\n                .text(function (d) {\n                    return UTIL.title(d);\n                })\n                .attr('x', function (d, i) { return i * cellWidth; })\n                .attr('y', 0)\n                .style('text-anchor', 'middle')\n                .attr('transform', 'translate(' + cellWidth / 2 + ', -6)');\n\n            yScale\n                .domain(yElement)\n                .range([0, yElement.length * cellHeight]);\n\n            xScale\n                .domain(xElement.entries().map(function (element) {\n                    return element.key + '_' + element.value;\n                }))\n                .range([0, xElement.size() * cellWidth]);\n\n            data = transformData(data);\n            if (_tooltip) {\n                tooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            var cell = plot.selectAll(\".node\")\n                .data(data)\n                .enter().append('g')\n                .attr('transform', function (d) {\n                    return 'translate(' + xScale(d.column + '_' + d.x) + ',' + yScale(d.y) + ')';\n                })\n                .attr('class', 'node')\n\n\n            drawViz(cell);\n\n            d3.select(div).select('.btn-primary')\n                .on('click', applyFilter(chart));\n\n            d3.select(div).select('.btn-default')\n                .on('click', clearFilter());\n\n            var lasso = d3.lasso()\n                .hoverSelect(true)\n                .closePathSelect(true)\n                .closePathDistance(100)\n                .items(cell)\n                .targetArea(svg);\n\n            lasso.on('start', onLassoStart(lasso, chart))\n                .on('draw', onLassoDraw(lasso, chart))\n                .on('end', onLassoEnd(lasso, chart));\n\n            _local_svg.call(lasso);\n        })\n\n    }\n\n    chart.update = function (data) {\n        _Local_data = data;\n        filterData = [];\n\n        var yElement = d3.set(data.map(function (item) { return item[_dimension[0]]; })).values();\n        var xElement = d3.map();\n\n        for (var i = 0; i < _measure.length; i++) {\n            xElement.set(i, _measure[i]);\n        }\n\n        cellWidth = parseInt((width - margin.left - margin.right) / _measure.length),\n            cellHeight = parseInt((height - margin.top - margin.bottom) / data.length);\n        var offset = 6;\n        var plot = _local_svg.select('.plot');\n\n        plot.selectAll('.dimLabel').remove()\n\n        var dimLabel = plot.selectAll('.dimLabel')\n            .data(yElement)\n            .enter().append('text')\n            .attr('class', 'dimLabel')\n            .text(function (d) { return d; })\n            .text(function (d) {\n                return d;\n            })\n            .attr('x', 0)\n            .attr('y', function (d, i) { return i * cellHeight; })\n            .attr('fill', dimLabelColor)\n            .style('font-style', fontStyleForDimension)\n            .style('font-weight', fontWeightForDimension)\n            .style('font-size', fontSizeForDimension)\n            .style('text-anchor', 'end')\n            .attr('transform', 'translate(' + -offset + ',' + cellHeight / 1.75 + ')');\n\n        yScale\n            .domain(yElement)\n            .range([0, yElement.length * cellHeight]);\n\n        xScale\n            .domain(xElement.entries().map(function (element) {\n                return element.key + '_' + element.value;\n            }))\n            .range([0, xElement.size() * cellWidth]);\n\n        data = transformData(data);\n\n        var cell = plot.selectAll(\".node\")\n            .data(data)\n\n        var newCell = cell.enter().append('g')\n            .attr('class', 'node')\n            .attr('transform', function (d) {\n                return 'translate(' + xScale(d.column + '_' + d.x) + ',' + yScale(d.y) + ')';\n            });\n\n        cell.exit().remove();\n\n        cell = plot.selectAll('.node');\n\n        cell.select('rect')\n            .attr('rx', '3px')\n            .attr('ry', '3px')\n            .attr('class', 'bordered')\n            .style('stroke', '#ffffff')\n            .style('stroke-width', '2px')\n            .attr('width', cellWidth - 1)\n            .attr('height', cellHeight - 1)\n            .transition()\n            .ease(d3.easeQuadIn)\n            .duration(500)\n            .styleTween('fill', function (d) {\n                return d3.interpolateRgb('transparent', getFillColor(d));\n            });\n\n\n        cell.select('text')\n            .attr('x', function (d) {\n                return getValuePosition(d, cellWidth);\n            })\n            .attr('y', function (d) {\n                return cellHeight / 2;\n            })\n            .text(function (d) {\n                var si = numberFormat[_measure.indexOf(d.x)],\n                    nf = UTIL.getNumberFormatter(si),\n                    value;\n\n                if (si == \"Percent\") {\n                    // value = nf(d.val / me.helper.measuresTotal[d.x]);\n                } else {\n                    value = nf(d.val);\n                }\n\n                if (value.indexOf(\"G\") != -1) {\n                    value = value.slice(0, -1) + \"B\";\n                }\n\n                return value;\n            })\n            .style('fill', function (d) {\n                return valueTextColour[_measure.indexOf(d.x)];\n            })\n            .attr('text-anchor', function (d) {\n                return getValueTextAnchor(d);\n            })\n            .attr('visibility', function (d) {\n                return showValues[_measure.indexOf(d.x)];\n            })\n            .style('font-style', function (d) {\n                return fontStyleForMeasure[_measure.indexOf(d.x)];\n            })\n            .style('font-weight', function (d) {\n                return fontWeightForMeasure[_measure.indexOf(d.x)];\n            })\n            .style('font-size', function (d) {\n                return fontSizeForMeasure[_measure.indexOf(d.x)];\n            });\n\n        cell.on('mouseover', _handleMouseOverFn.call(chart, tooltip, _local_svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, _local_svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, tooltip, _local_svg))\n            .on('click', function (d) {\n                var confirm = d3.select('.confirm')\n                    .style('visibility', 'visible');\n                var _filter = _localData.filter(function (d1) {\n                    return d.y === d1[_dimension[0]]\n                })\n                var rect = d3.select(this).select('rect');\n                if (rect.classed('selected')) {\n                    rect.classed('selected', false);\n                    filterData.map(function (val, i) {\n                        if (val[_dimension[0]] == d[_dimension[0]]) {\n                            filterData.splice(i, 1)\n                        }\n                    })\n                } else {\n                    rect.classed('selected', true);\n                    var isExist = filterData.filter(function (val) {\n                        if (val[_dimension[0]] == d[_dimension[0]]) {\n                            return val\n                        }\n                    })\n                    if (isExist.length == 0) {\n                        filterData.push(_filter[0]);\n                    }\n                }\n            });\n\n        newCell.append('rect')\n            .attr('rx', '3px')\n            .attr('ry', '3px')\n            .attr('class', 'bordered')\n            .style('stroke', '#ffffff')\n            .style('stroke-width', '2px')\n            .attr('width', cellWidth - 1)\n            .attr('height', cellHeight - 1)\n            .transition()\n            .ease(d3.easeQuadIn)\n            .duration(500)\n            .styleTween('fill', function (d) {\n                return d3.interpolateRgb('transparent', getFillColor(d));\n            });\n\n        newCell.append('text')\n            .attr('x', function (d) {\n                return getValuePosition(d, cellWidth);\n            })\n            .attr('y', function (d) {\n                return cellHeight / 2;\n            })\n            .text(function (d) {\n                var si = numberFormat[_measure.indexOf(d.x)],\n                    nf = UTIL.getNumberFormatter(si),\n                    value;\n\n                if (si == \"Percent\") {\n                    // value = nf(d.val / me.helper.measuresTotal[d.x]);\n                } else {\n                    value = nf(d.val);\n                }\n\n                if (value.indexOf(\"G\") != -1) {\n                    value = value.slice(0, -1) + \"B\";\n                }\n\n                return value;\n            })\n            .style('fill', function (d) {\n                return valueTextColour[_measure.indexOf(d.x)];\n            })\n            .attr('text-anchor', function (d) {\n                return getValueTextAnchor(d);\n            })\n            .attr('visibility', function (d) {\n                return showValues[_measure.indexOf(d.x)];\n            })\n            .style('font-style', function (d) {\n                return fontStyleForMeasure[_measure.indexOf(d.x)];\n            })\n            .style('font-weight', function (d) {\n                return fontWeightForMeasure[_measure.indexOf(d.x)];\n            })\n            .style('font-size', function (d) {\n                return fontSizeForMeasure[_measure.indexOf(d.x)];\n            });\n\n        plot.selectAll('.node')\n            .attr('transform', function (d) {\n                return 'translate(' + xScale(d.column + '_' + d.x) + ',' + yScale(d.y) + ')';\n            });\n    }\n\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.tooltip = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    chart.dimLabelColor = function (value) {\n        if (!arguments.length) {\n            return dimLabelColor;\n        }\n        dimLabelColor = value;\n        return chart;\n    }\n\n    chart.displayName = function (value) {\n        if (!arguments.length) {\n            return displayName;\n        }\n        displayName = value;\n        return chart;\n    }\n\n    chart.fontWeightForDimension = function (value) {\n        if (!arguments.length) {\n            return fontWeightForDimension;\n        }\n        fontWeightForDimension = value;\n        return chart;\n    }\n\n    chart.fontSizeForDimension = function (value) {\n        if (!arguments.length) {\n            return fontSizeForDimension;\n        }\n        fontSizeForDimension = value;\n        return chart;\n    }\n\n    chart.fontStyleForDimension = function (value) {\n        if (!arguments.length) {\n            return fontStyleForDimension;\n        }\n        fontStyleForDimension = value;\n        return chart;\n    }\n\n    chart.showValues = function (value, measure) {\n        return UTIL.baseAccessor.call(showValues, value, measure, _measure);\n    }\n    chart.displayNameForMeasure = function (value, measure) {\n        return UTIL.baseAccessor.call(displayNameForMeasure, value, measure, _measure);\n    }\n    chart.showIcon = function (value, measure) {\n        return UTIL.baseAccessor.call(showIcon, value, measure, _measure);\n    }\n    chart.valuePosition = function (value, measure) {\n        return UTIL.baseAccessor.call(valuePosition, value, measure, _measure);\n    }\n    chart.iconName = function (value, measure) {\n        return UTIL.baseAccessor.call(iconName, value, measure, _measure);\n    }\n    chart.iconFontWeight = function (value, measure) {\n        return UTIL.baseAccessor.call(iconFontWeight, value, measure, _measure);\n    }\n    chart.iconColor = function (value, measure) {\n        return UTIL.baseAccessor.call(iconColor, value, measure, _measure);\n    }\n    chart.iconPosition = function (value, measure) {\n        return UTIL.baseAccessor.call(iconPosition, value, measure, _measure);\n    }\n    chart.showIcon = function (value, measure) {\n        return UTIL.baseAccessor.call(showIcon, value, measure, _measure);\n    }\n\n    chart.colourCoding = function (value, measure) {\n        if (!arguments.length) {\n            return colourCoding;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            colourCoding = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return colourCoding[index];\n        } else {\n            colourCoding[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n    }\n    chart.valueTextColour = function (value, measure) {\n        return UTIL.baseAccessor.call(valueTextColour, value, measure, _measure);\n    }\n    chart.fontStyleForMeasure = function (value, measure) {\n        return UTIL.baseAccessor.call(fontStyleForMeasure, value, measure, _measure);\n    }\n    chart.fontWeightForMeasure = function (value, measure) {\n        return UTIL.baseAccessor.call(fontWeightForMeasure, value, measure, _measure);\n    }\n    chart.numberFormat = function (value, measure) {\n        return UTIL.baseAccessor.call(numberFormat, value, measure, _measure);\n    }\n    chart.fontSizeForMeasure = function (value, measure) {\n        return UTIL.baseAccessor.call(fontSizeForMeasure, value, measure, _measure);\n    }\n    return chart;\n}\n\nmodule.exports = heatmap;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/heatmap.js?");

/***/ }),

/***/ "./js/charts/infographics.js":
/*!***********************************!*\
  !*** ./js/charts/infographics.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction infographics() {\n\n    /* These are the constant global variable for the function kpi.\n     */\n    var _NAME = 'infographics';\n\n    /* These are the private variables that is initialized by the arguments sent\n     * by the users and can be updated using public methods.\n     */\n\n    var _config,\n        _dimension,\n        _measure,\n        _chartType,\n        _chartDisplayColor,\n        _chartBorderColor,\n        _kpiDisplayName,\n        _kpiAlignment,\n        _kpiBackgroundColor,\n        _kpiNumberFormat,\n        _kpiFontStyle,\n        _kpiFontWeight,\n        _kpiFontSize,\n        _kpiColor,\n        _kpiColorExpression,\n        _kpiIcon,\n        _kpiIconFontWeight,\n        _kpiIconColor,\n        _kpiIconExpression,\n        _tooltip;\n\n    /* These are the common variables that is shared across the different private/public \n     * methods but is initialized/updated within the methods itself.\n     */\n    var _localDiv,\n        _localTotal = 0,\n        _localPrevKpiValue = 0,\n        _localData,\n        _localXLabels = [],\n        _localMin,\n        _localMax,\n        _localTooltip;\n\n    /* These are the common private functions that is shared across the different private/public \n     * methods but is initialized beforehand.\n     */\n    var _x = d3.scalePoint(),\n        _y = d3.scaleLinear(),\n        _line = d3.line(),\n        _area = d3.area();\n\n    /* -------------------------------------------------------------------------------- */\n    var _setConfigParams = function(config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.chartType(config.chartType);\n        this.chartDisplayColor(config.chartDisplayColor);\n        this.chartBorderColor(config.chartBorderColor);\n        this.kpiDisplayName(config.kpiDisplayName);\n        this.kpiAlignment(config.kpiAlignment);\n        this.kpiBackgroundColor(config.kpiBackgroundColor);\n        this.kpiNumberFormat(config.kpiNumberFormat);\n        this.kpiFontStyle(config.kpiFontStyle);\n        this.kpiFontWeight(config.kpiFontWeight);\n        this.kpiFontSize(config.kpiFontSize);\n        this.kpiColor(config.kpiColor);\n        this.kpiColorExpression(config.kpiColorExpression);\n        this.kpiIcon(config.kpiIcon);\n        this.kpiIconFontWeight(config.kpiIconFontWeight);\n        this.kpiIconColor(config.kpiIconColor);\n        this.kpiIconExpression(config.kpiIconExpression);\n        this.tooltip(config.tooltip);\n    }\n\n    var _getKpiDisplayName = function() {\n        if(_kpiDisplayName.trim() == '') {\n            return _measure;\n        }\n\n        return _kpiDisplayName;\n    }\n\n    var _getKpi = function(value, endValue) {\n        var numberOutput = \"\",\n            iconOutput = \"\";\n\n        var style = {\n            'font-style': _kpiFontStyle || COMMON.DEFAULT_FONTSTYLE,\n            'font-weight': _kpiFontWeight || COMMON.DEFAULT_FONTWEIGHT,\n            'font-size': _kpiFontSize || COMMON.DEFAULT_FONTSIZE,\n            'color': _kpiColor || COMMON.DEFAULT_COLOR\n        };\n\n        if(_kpiColorExpression) {\n            style['color'] = UTIL.expressionEvaluator(_kpiColorExpression, endValue, 'color');\n        }\n\n        style = JSON.stringify(style);\n        style = style.replace(/[\"{}]/g, '').replace(/,/g, ';');\n\n        numberOutput += \"<span style='\" + style + \"'>\"\n            + UTIL.getNumberFormatterFn(_kpiNumberFormat)(UTIL.roundNumber(value, 0)).toUpperCase()\n            + \"</span>\";\n\n        var iconStyle = {\n            'font-weight': _kpiIconFontWeight || COMMON.DEFAULT_FONTWEIGHT,\n            'color': _kpiIconColor || COMMON.DEFAULT_COLOR,\n            'font-size': _kpiFontSize || COMMON.DEFAULT_FONTSIZE\n        };\n\n        if(_kpiIconExpression) {\n            _kpiIcon = UTIL.expressionEvaluator(_kpiIconExpression, endValue, 'icon');\n            iconStyle['color'] = UTIL.expressionEvaluator(_kpiIconExpression, endValue, 'color');\n        }\n\n        iconStyle = JSON.stringify(iconStyle);\n        iconStyle = iconStyle.replace(/[\"{}]/g, '').replace(/,/g, ';');\n\n        iconOutput += \"<i class=\\\"\" + _kpiIcon + \"\\\" style=\\\"\" + iconStyle + \"\\\" aria-hidden=\\\"true\\\"></i>\";\n\n        return numberOutput + \"&nbsp;\" + iconOutput;\n    }\n\n    /* Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the arc\n     * @param {function} chart Pie chart function\n     * @return {string} String encoded HTML data\n     */\n    var _buildTooltipData = function(datum, chart) {\n        var output = \"\";\n\n        output += \"<table><tr>\"\n            + \"<th>\" + chart.dimension() + \": </th>\"\n            + \"<td>\" + datum[chart.dimension()] + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + chart.measure() + \": </th>\"\n            + \"<td>\" + datum[chart.measure()] + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var _handleMouseOverFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'pointer');\n\n            var point = container.selectAll('.infographics-point')\n                .filter(function(d1) {\n                    return d1[_dimension[0]] === d[_dimension[0]];\n                });\n\n            point.style('stroke-width', 2);\n            \n            if(tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            if(tooltip) {\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'default');\n\n            var point = container.selectAll('.infographics-point')\n                .filter(function(d1) {\n                    return d1[_dimension[0]] === d[_dimension[0]];\n                });\n\n            point.style('stroke-width', 0);\n            \n            if(tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    function chart(selection) {\n        _localDiv = selection;\n\n        selection.each(function(data) {\n            var infographics = d3.select(this),\n                width = parseInt(infographics.style('width')),\n                height = parseInt(infographics.style('height')),\n                parentWidth = width - 2 * COMMON.MARGIN,\n                parentHeight = height - 2 * COMMON.MARGIN;\n\n            /* total sum of the measure values */\n            _localTotal = d3.sum(data.map(function(d) { return d[_measure[0]]; }));\n\n            /* store the data in local variable */\n            _localData = data;\n\n            var container = infographics.append('div')\n                .classed('container', true)\n                .style('width', parentWidth)\n                .style('height', parentHeight)\n                .style('margin', COMMON.MARGIN);\n\n            var graphics = container.append('svg')\n                .attr('id', 'graphics');\n\n            var info = container.append('div')\n                .attr('id', 'info');\n\n            var tooltip = container.append('div')\n                .attr('id', 'tooltip');\n\n            if(_tooltip) {\n                _localTooltip = tooltip;\n            }\n\n            /* Label values for the dimension */\n            _localXLabels = data.map(function(d) {\n                return d[_dimension[0]];\n            });\n\n            /* Minimum and Maximum value of the measures */\n            _localMin = d3.min(data, function(d) { return d[_measure[0]]; });\n            _localMax = d3.max(data, function(d) { return d[_measure[0]]; });\n            \n            _x.domain(_localXLabels)\n                .range([0, parentWidth]);\n\n            _y.domain([_localMin, _localMax])\n                .range([parentHeight, 0]);\n\n            _line.x(function(d) {\n                    return _x(d[_dimension[0]]);\n                })\n                .y(function(d) {\n                    return _y(d[_measure[0]]);\n                });\n\n            _area.x(function(d) {\n                    return _x(d[_dimension[0]]);\n                })\n                .y0(parentHeight)\n                .y1(function(d) {\n                    return _y(d[_measure[0]]);\n                });\n\n            var plot = graphics.append('g')\n                .attr('id', 'infographics-plot');\n\n            plot.append('path')\n                .classed('infographics-line', true)\n                .style('fill', 'none')\n                .style('stroke', _chartBorderColor)\n                .style('stroke-linejoin', 'round')\n                .style('stroke-linecap', 'round')\n                .style('stroke-width', 4)\n                .attr('d', _line)\n                .transition()\n                .duration(COMMON.DURATION)\n                .attrTween('stroke-dasharray', function() {\n                    var l = this.getTotalLength(),\n                        interpolator = d3.interpolateString('0,' + l, l + ',' + l);\n\n                    return function(t) {\n                        return interpolator(t);\n                    }\n                });\n\n            plot.append('path')\n                .classed('infographics-area', true)\n                .style('fill', _chartDisplayColor)\n                .style('stroke-width', 0)\n                .style('opacity', 0)\n                .attr('d', _area)\n                .transition()\n                .duration(COMMON.DURATION)\n                .styleTween('opacity', function() {\n                    var interpolator = d3.interpolateNumber(0, 1);\n\n                    return function(t) {\n                        return interpolator(t);\n                    }\n                });\n\n            plot.append('g')\n                .attr('id', 'infographics-point-group')\n                .selectAll('.infographics-point')\n                .data(data)\n                .enter().append('circle')\n                    .classed('infographics-point', true)\n                    .attr('cx', function(d, i) {\n                        return _x(d[_dimension[0]]);\n                    })\n                    .attr('cy', function(d, i) {\n                        return _y(d[_measure[0]]);\n                    })\n                    .attr('r', 4)\n                    .style('fill', _chartBorderColor)\n                    .style('stroke', d3.hsl(_chartBorderColor).darker(1).toString())\n                    .style('stroke-width', 0)\n                    .on('mouseover', _handleMouseOverFn.call(chart, _localTooltip, infographics))\n                    .on('mousemove', _handleMouseMoveFn.call(chart, _localTooltip, infographics))\n                    .on('mouseout', _handleMouseOutFn.call(chart, _localTooltip, infographics))\n                    .on('click', function(d, i) {\n                        \n                    });\n                \n            var measure = info.append('div')\n                .classed('measure', true)\n                .style('justify-content', _kpiAlignment);\n\n            var parent = measure.append('div')\n                .classed('parent', true);\n                \n            parent.append('div')\n                .attr('id', 'kpi-label')\n                .classed('child', true)\n                .html(_getKpiDisplayName())\n                .style('font-size', '1.2em')\n                .style('padding-left', '5px');\n\n            parent.append('div')\n                .attr('id', 'kpi-measure')\n                .classed('child', true)\n                .style('font-size', _kpiFontSize)\n                .style('border-radius', function(d, i1) {\n                    return COMMON.BORDER_RADIUS + 'px';\n                })\n                .style('background-color', function(d, i1) {\n                    return _kpiBackgroundColor || 'transparent';\n                })\n                .style('padding', function(d, i1) {\n                    return (_kpiFontStyle == 'oblique')\n                        ? '3px 8px'\n                        : '3px 0px';\n                })\n                .transition()\n                .ease(d3.easeQuadIn)\n                .duration(COMMON.DURATION)\n                .delay(0)\n                .tween('html', function() {\n                    var me = d3.select(this),\n                        i = d3.interpolateNumber(_localPrevKpiValue, _localTotal);\n\n                    _localPrevKpiValue = _localTotal;\n\n                    return function(t) {\n                        me.html(_getKpi(i(t), _localTotal));\n                    }\n                });\n        });\n    }\n\n    chart._getName = function() {\n        return _NAME;\n    }\n\n    chart.update = function(data) {\n        var div = _localDiv;\n\n        /* store the data in local variable */\n        _localData = data;\n\n        /* total sum of the measure values */\n        _localTotal = d3.sum(data.map(function(d) { return d[_measure[0]]; }));\n\n        /* Label values for the dimension */\n        _localXLabels = data.map(function(d) {\n            return d[_dimension[0]];\n        });\n\n        /* Minimum and Maximum value of the measures */\n        _localMin = d3.min(data, function(d) { return d[_measure[0]]; });\n        _localMax = d3.max(data, function(d) { return d[_measure[0]]; });\n        \n        /* Update the axes scales */\n        _x.domain(_localXLabels);\n        _y.domain([_localMin, _localMax]);\n\n        var plot = div.select('#infographics-plot')\n            .data([data]);\n\n        plot.select('path.infographics-line')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('d', _line)\n            .attr('stroke-dasharray', 'none');\n\n        plot.select('path.infographics-area')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('d', _area);\n\n        plot.selectAll('.infographics-point')\n            .data(function(d) { return d; })\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('cx', function(d, i) {\n                return _x(d[_dimension[0]]);\n            })\n            .attr('cy', function(d, i) {\n                return _y(d[_measure[0]]);\n            });\n\n        div.select('#kpi-measure')\n            .transition()\n            .ease(d3.easeQuadIn)\n            .duration(500)\n            .delay(0)\n            .tween('html', function() {\n                var me = d3.select(this),\n                    i = d3.interpolateNumber(_localPrevKpiValue, _localTotal);\n\n                _localPrevKpiValue = _localTotal;\n\n                return function(t) {\n                    me.html(_getKpi(i(t), _localTotal));\n                }\n            });\n    }\n\n    chart.config = function(value) {\n        if(!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function(value) {\n        if(!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function(value) {\n        if(!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.chartType = function(value) {\n        if(!arguments.length) {\n            return _chartType;\n        }\n        _chartType = value;\n        return chart;\n    }\n\n    chart.chartBorderColor = function(value) {\n        if(!arguments.length) {\n            return _chartBorderColor;\n        }\n        _chartBorderColor = value;\n        return chart;\n    }\n\n    chart.chartDisplayColor = function(value) {\n        if(!arguments.length) {\n            return _chartDisplayColor;\n        }\n        _chartDisplayColor = value;\n        return chart;\n    }\n    \n    chart.kpiDisplayName = function(value) {\n        if(!arguments.length) {\n            return _kpiDisplayName;\n        }\n        _kpiDisplayName = value;\n        return chart;\n    }\n\n    chart.kpiAlignment = function(value) {\n        if(!arguments.length) {\n            return _kpiAlignment;\n        }\n        _kpiAlignment = value;\n        return chart;\n    }\n\n    chart.kpiBackgroundColor = function(value) {\n        if(!arguments.length) {\n            return _kpiBackgroundColor;\n        }\n        _kpiBackgroundColor = value;\n        return chart;\n    }\n\n    chart.kpiNumberFormat = function(value) {\n        if(!arguments.length) {\n            return _kpiNumberFormat;\n        }\n        _kpiNumberFormat = value;\n        return chart;\n    }\n\n    chart.kpiFontStyle = function(value) {\n        if(!arguments.length) {\n            return _kpiFontStyle;\n        }\n        _kpiFontStyle = value;\n        return chart;\n    }\n\n    chart.kpiFontWeight = function(value) {\n        if(!arguments.length) {\n            return _kpiFontWeight;\n        }\n        _kpiFontWeight = value;\n        return chart;\n    }\n\n    chart.kpiFontSize = function(value) {\n        if(!arguments.length) {\n            return _kpiFontSize;\n        }\n        _kpiFontSize = value;\n        return chart;\n    }\n\n    chart.kpiColor = function(value) {\n        if(!arguments.length) {\n            return _kpiColor;\n        }\n        _kpiColor = value;\n        return chart;\n    }\n\n    chart.kpiColorExpression = function(value) {\n        if(!arguments.length) {\n            return _kpiColorExpression;\n        }\n        _kpiColorExpression = UTIL.getExpressionConfig(value, ['color']);\n        return chart;\n    }\n\n    chart.kpiIcon = function(value) {\n        if(!arguments.length) {\n            return _kpiIcon;\n        }\n        _kpiIcon = value;\n        return chart;\n    }\n\n    chart.kpiIconFontWeight = function(value) {\n        if(!arguments.length) {\n            return _kpiIconFontWeight;\n        }\n        _kpiIconFontWeight = value;\n        return chart;\n    }\n\n    chart.kpiIconColor = function(value) {\n        if(!arguments.length) {\n            return _kpiIconColor;\n        }\n        _kpiIconColor = value;\n        return chart;\n    }\n\n    chart.kpiIconExpression = function(value) {\n        if(!arguments.length) {\n            return _kpiIconExpression;\n        }\n        _kpiIconExpression = UTIL.getExpressionConfig(value, ['icon', 'color']);\n        return chart;\n    }\n\n    chart.tooltip = function(value) {\n        if(!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = infographics;\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/infographics.js?");

/***/ }),

/***/ "./js/charts/kpi.js":
/*!**************************!*\
  !*** ./js/charts/kpi.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction kpi() {\n\n    /* These are the constant global variable for the function kpi.\n     */\n    var _NAME = 'kpi';\n\n    /* These are the private variables that is initialized by the arguments sent\n     * by the users and can be updated using public methods.\n     */\n\n    var _config,\n        _dimension,\n        _measure,\n        /* Initialization of these variable is important, otherwise Windows object\n         * will be sent during calling of baseAccessor function\n         */\n        _kpiDisplayName = [],\n        _kpiAlignment = [],\n        _kpiBackgroundColor = [],\n        _kpiNumberFormat = [],\n        _kpiFontStyle = [],\n        _kpiFontWeight = [],\n        _kpiFontSize = [],\n        _kpiColor = [],\n        _kpiColorExpression = [],\n        _kpiIcon = [],\n        _kpiIconFontWeight = [],\n        _kpiIconColor = [],\n        _kpiIconExpression = [];\n\n    /* These are the common variables that is shared across the different private/public \n     * methods but is initialized/updated within the methods itself.\n     */\n    var _localDiv,\n        _localTotal = [],\n        _localPrevKpiValue = [0, 0],\n        _localData,\n        _localLabelFontSize = [1.2, 0.9];\n\n    /* These are the common private functions that is shared across the different private/public \n     * methods but is initialized beforehand.\n     */\n\n\n    /* -------------------------------------------------------------------------------- */\n    var _setConfigParams = function(config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.kpiDisplayName(config.kpiDisplayName);\n        this.kpiAlignment(config.kpiAlignment);\n        this.kpiBackgroundColor(config.kpiBackgroundColor);\n        this.kpiNumberFormat(config.kpiNumberFormat);\n        this.kpiFontStyle(config.kpiFontStyle);\n        this.kpiFontWeight(config.kpiFontWeight);\n        this.kpiFontSize(config.kpiFontSize);\n        this.kpiColor(config.kpiColor);\n        this.kpiColorExpression(config.kpiColorExpression);\n        this.kpiIcon(config.kpiIcon);\n        this.kpiIconFontWeight(config.kpiIconFontWeight);\n        this.kpiIconColor(config.kpiIconColor);\n        this.kpiIconExpression(config.kpiIconExpression);\n    }\n\n    /**\n     * Gives label for a particular measure\n     *\n     * @param {number} index Index for a particular measure\n     * @return {string}\n     */\n    var _getKpiDisplayName = function(index) {\n        if(_kpiDisplayName[index].trim() == '') {\n            return _measure[index];\n        }\n\n        return _kpiDisplayName[index];\n    }\n\n    /**\n     * HTML data for the KPI value\n     *\n     * @param {number} value Accumulated value of the measure\n     * @param {number} endValue End value upto which the transition should occur\n     * @param {nummber} index Index of the measure for which the HTML output of the KPI is required\n     * @return {string}\n     */\n    var _getKpi = function(value, endValue, index) {\n        var numberOutput = \"\",\n            iconOutput = \"\";\n\n        var style = {\n            'font-style': _kpiFontStyle[index] || COMMON.DEFAULT_FONTSTYLE,\n            'font-weight': _kpiFontWeight[index] || COMMON.DEFAULT_FONTWEIGHT,\n            'font-size': _kpiFontSize[index] || COMMON.DEFAULT_FONTSIZE,\n            'color': _kpiColor[index] || COMMON.DEFAULT_COLOR\n        };\n\n        if(_kpiColorExpression[index].length) {\n            style['color'] = UTIL.expressionEvaluator(_kpiColorExpression[index], endValue, 'color');\n        }\n\n        style = JSON.stringify(style);\n        style = style.replace(/[\"{}]/g, '').replace(/,/g, ';');\n\n        numberOutput += \"<span style='\" + style + \"'>\"\n            + UTIL.getNumberFormatterFn(_kpiNumberFormat[index])(UTIL.roundNumber(value, 0)).toUpperCase()\n            + \"</span>\";\n\n        var iconStyle = {\n            'font-weight': _kpiIconFontWeight[index] || COMMON.DEFAULT_FONTWEIGHT,\n            'color': _kpiIconColor[index] || COMMON.DEFAULT_COLOR,\n            'font-size': _kpiFontSize[index] || COMMON.DEFAULT_FONTSIZE\n        };\n\n        if(_kpiIconExpression[index].length) {\n            _kpiIcon[index] = UTIL.expressionEvaluator(_kpiIconExpression[index], endValue, 'icon');\n            iconStyle['color'] = UTIL.expressionEvaluator(_kpiIconExpression[index], endValue, 'color');\n        }\n\n        iconStyle = JSON.stringify(iconStyle);\n        iconStyle = iconStyle.replace(/[\"{}]/g, '').replace(/,/g, ';');\n\n        iconOutput += \"<i class=\\\"\" + _kpiIcon[index] + \"\\\" style=\\\"\" + iconStyle + \"\\\" aria-hidden=\\\"true\\\"></i>\";\n\n        return index ? (iconOutput + \"&nbsp;\" + numberOutput)\n            : (numberOutput + \"&nbsp;\" + iconOutput);\n    }\n\n    function chart(selection) {\n        _localDiv = selection;\n\n        selection.each(function(data) {\n            var kpi = d3.select(this),\n                width = parseInt(kpi.style('width')),\n                height = parseInt(kpi.style('height'));\n\n            /* total sum of the measure values */\n            _localTotal = _measure.map(function(m) {\n                return d3.sum(data.map(function(d) { return d[m]; }));\n            });\n\n            /* store the data in local variable */\n            _localData = data;\n\n            var container = kpi.append('div')\n                .classed('container', true)\n                .style('width', width - 2 * COMMON.PADDING)\n                .style('height', height - 2 * COMMON.PADDING)\n                .style('padding', COMMON.PADDING);\n\n            _measure.forEach(function(m, i) {\n                var measure = container.append('div')\n                    .classed('measure', true)\n                    .style('align-items', function(d, i1) {\n                        return i ? 'center' : 'flex-end';\n                    })\n                    .style('justify-content', _kpiAlignment[i])\n                        .append('div')\n                        .classed('parent', true);\n\n                measure.append('div')\n                    .attr('id', function(d, i1) {\n                        return 'kpi-label-' + i;\n                    })\n                    .classed('child', true)\n                    .html(_getKpiDisplayName(i))\n                    .style('font-size', function(d, i1) {\n                        return _localLabelFontSize[i] + 'em';\n                    })\n                    .style('padding-left', '5px')\n                    .style('text-align', function(d, i1) {\n                        return i ? 'right' : 'left';\n                    });\n\n                measure.insert('div', (function() {\n                        return i ? ':first-child' : null;\n                    })())\n                    .attr('id', function(d, i1) {\n                        return 'kpi-measure-' + i;\n                    })\n                    .classed('child', true)\n                    .style('font-size', _kpiFontSize[i])\n                    .style('border-radius', function(d, i1) {\n                        return COMMON.BORDER_RADIUS + 'px';\n                    })\n                    .style('background-color', function(d, i1) {\n                        return _kpiBackgroundColor[i] || 'transparent';\n                    })\n                    .style('padding', function(d, i1) {\n                        return (_kpiFontStyle[i] == 'oblique' && i)\n                            ? '3px 8px'\n                            : '3px 0px';\n                    })\n                    .transition()\n                    .ease(d3.easeQuadIn)\n                    .duration(1000)\n                    .delay(0)\n                    .tween('html', function() {\n                        var me = d3.select(this),\n                            interpolator = d3.interpolateNumber(_localPrevKpiValue[i], _localTotal[i]);\n\n                        _localPrevKpiValue[i] = _localTotal[i];\n                        \n                        return function(t) {\n                            me.html(_getKpi(interpolator(t), _localTotal[i], i));\n                        }\n                    });\n            });\n        });\n    }\n\n    chart._getName = function() {\n        return _NAME;\n    }\n\n    chart.update = function(data) {\n        var div = _localDiv;\n\n        /* store the data in local variable */\n        _localData = data;\n\n        /* total sum of the measure values */\n        _localTotal = _measure.map(function(m) {\n            return d3.sum(data.map(function(d) { return d[m]; }));\n        });\n\n        _measure.forEach(function(m, i) {\n            d3.select('#kpi-measure-' + i)\n                .transition()\n                .ease(d3.easeQuadIn)\n                .duration(500)\n                .delay(0)\n                .tween('html', function() {\n                    var me = d3.select(this),\n                        interpolator = d3.interpolateNumber(_localPrevKpiValue[i], _localTotal[i]);\n\n                    _localPrevKpiValue[i] = _localTotal[i];\n\n                    return function(t) {\n                        me.html(_getKpi(interpolator(t), _localTotal[i], i));\n                    }\n                });\n        });\n    }\n\n    chart.config = function(value) {\n        if(!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function(value) {\n        if(!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function(value) {\n        if(!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n    \n    /**\n     * KPI Displayname accessor function\n     *\n     * @param {string|array(string)|null} value Displayname value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiDisplayName = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiDisplayName, value, measure, _measure);\n    }\n\n    /**\n     * KPI Alignment accessor function\n     *\n     * @param {string|array(string)|null} value Alignment value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiAlignment = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiAlignment, value, measure, _measure);\n    }\n\n    /**\n     * KPI Background Color accessor function\n     *\n     * @param {string|array(string)|null} value Background Color value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiBackgroundColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiBackgroundColor, value, measure, _measure);\n    }\n\n    /**\n     * KPI Number Format accessor function\n     *\n     * @param {string|array(string)|null} value Number Format value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiNumberFormat = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiNumberFormat, value, measure, _measure);\n    }\n\n    /**\n     * KPI Font Style accessor function\n     *\n     * @param {string|array(string)|null} value Font Style value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiFontStyle = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiFontStyle, value, measure, _measure);\n    }\n\n    /**\n     * KPI Font Weight accessor function\n     *\n     * @param {string|array(string)|null} value Font Weight value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiFontWeight = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiFontWeight, value, measure, _measure);\n    }\n\n    /**\n     * KPI Font Size accessor function\n     *\n     * @param {string|array(string)|null} value Font Size value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiFontSize = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiFontSize, value, measure, _measure);\n    }\n\n    /**\n     * KPI Font Color accessor function\n     *\n     * @param {string|array(string)|null} value Font Color value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiColor, value, measure, _measure);\n    }\n\n    /**\n     * KPI Font Color Expression accessor function\n     *\n     * @param {string|array(string)|null} value Font Color Expression value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiColorExpression = function(value, measure) {\n        if(!arguments.length) {\n            /**\n             * Getter method call with no arguments\n             * E.g. <chart>.kpiColorExpression() ==> [<item1>, <item2>]\n             */\n            return _kpiColorExpression;\n        }\n\n        if(value instanceof Array && measure == void 0) {\n            /**\n             * Setter method call with only value argument\n             * E.g. <chart>.kpiColorExpression([<item1>, <item2>]) ==> <chart_function>\n             */\n            _kpiColorExpression = value.map(function(v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if(index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if(value == void 0) {\n            /**\n             * Getter method call with only measure argument\n             * E.g. <chart>.kpiColorExpression(<measure>) ==> <item>\n             */\n            return _kpiColorExpression[index];\n        } else {\n            /**\n             * Setter method call with both value and measure arguments\n             * E.g. <chart>.kpiColorExpression(<item>, <measure>) ==> <chart_function>\n             */\n            _kpiColorExpression[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n\n        return chart;\n    }\n\n    /**\n     * KPI Icon accessor function\n     *\n     * @param {string|array(string)|null} value Icon value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiIcon = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiIcon, value, measure, _measure);\n    }\n\n    /**\n     * KPI Icon Font Weight accessor function\n     *\n     * @param {string|array(string)|null} value Icon Font Weight value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiIconFontWeight = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiIconFontWeight, value, measure, _measure);\n    }\n\n    /**\n     * KPI Icon Color accessor function\n     *\n     * @param {string|array(string)|null} value Icon Color value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiIconColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_kpiIconColor, value, measure, _measure);\n    }\n\n    /**\n     * KPI Icon Color Expression accessor function\n     *\n     * @param {string|array(string)|null} value Icon Color Expression value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.kpiIconExpression = function(value, measure) {\n        if(!arguments.length) {\n            /**\n             * Getter method call with no arguments\n             * E.g. <chart>.kpiIconExpression() ==> [<item1>, <item2>]\n             */\n            return _kpiIconExpression;\n        }\n\n        if(value instanceof Array && measure == void 0) {\n            /**\n             * Setter method call with only value argument\n             * E.g. <chart>.kpiIconExpression([<item1>, <item2>]) ==> <chart_function>\n             */\n            _kpiIconExpression = value.map(function(v) {\n                return UTIL.getExpressionConfig(v, ['icon', 'color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if(index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if(value == void 0) {\n            /**\n             * Getter method call with only measure argument\n             * E.g. <chart>.kpiIconExpression(<measure>) ==> <item>\n             */\n            return _kpiIconExpression[index];\n        } else {\n            /**\n             * Setter method call with both value and measure arguments\n             * E.g. <chart>.kpiIconExpression(<item>, <measure>) ==> <chart_function>\n             */\n            _kpiIconExpression[index] = UTIL.getExpressionConfig(value, ['icon', 'color']);\n        }\n\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = kpi;\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/kpi.js?");

/***/ }),

/***/ "./js/charts/line.js":
/*!***************************!*\
  !*** ./js/charts/line.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction line() {\n\n    /* These are the constant global variable for the function line.\n     */\n    var _NAME = 'line';\n\n    /* These are the private variables that is initialized by the arguments sent\n     * by the users and can be updated using public methods.\n     */\n\n    var _config,\n        _dimension,\n        _measure,\n        _xAxis,\n        _yAxis,\n        _xAxisColor,\n        _yAxisColor,\n        _xAxisLabel,\n        _yAxisLabel,\n        _legend,\n        _legendPosition,\n        _grid,\n        _stacked,\n        _dimensionDisplayName,\n        _measureShowValue = [],\n        _measureDisplayName = [],\n        _measureFontStyle = [],\n        _measureFontWeight = [],\n        _measureFontSize = [],\n        _measureNumberFormat = [],\n        _measureTextColor = [],\n        _measureDisplayColor = [],\n        _measureBorderColor = [],\n        _measureLineType = [],\n        _measurePointType = [],\n        _tooltip;\n\n    /* These are the common variables that is shared across the different private/public \n     * methods but is initialized/updated within the methods itself.\n     */\n    var _localSVG,\n        _localTotal = [],\n        _localXAxis,\n        _localYAxis,\n        _localXGrid,\n        _localYGrid,\n        _localData,\n        _localXLabels = [],\n        _localMin = 0,\n        _localMax = 0,\n        _localLegend,\n        _localTooltip;\n        // _localLabelStack;\n\n    /* These are the common private functions that is shared across the different private/public \n     * methods but is initialized beforehand.\n     */\n    var _x = d3.scalePoint()\n            .padding(0.5),\n        _xGrid = d3.scaleLinear(),\n        _y = d3.scaleLinear(),\n        _line = d3.line(),\n        _area = d3.area();\n\n    /* -------------------------------------------------------------------------------- */\n    var _setConfigParams = function(config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.xAxis(config.xAxis);\n        this.yAxis(config.yAxis);\n        this.xAxisColor(config.xAxisColor);\n        this.yAxisColor(config.yAxisColor);\n        this.xAxisLabel(config.xAxisLabel);\n        this.yAxisLabel(config.yAxisLabel);\n        this.legend(config.legend);\n        this.legendPosition(config.legendPosition);\n        this.grid(config.grid);\n        this.stacked(config.stacked);\n        this.dimensionDisplayName(config.dimensionDisplayName);\n        this.measureShowValue(config.measureShowValue);\n        this.measureDisplayName(config.measureDisplayName);\n        this.measureFontStyle(config.measureFontStyle);\n        this.measureFontWeight(config.measureFontWeight);\n        this.measureFontSize(config.measureFontSize);\n        this.measureNumberFormat(config.measureNumberFormat);\n        this.measureTextColor(config.measureTextColor);\n        this.measureDisplayColor(config.measureDisplayColor);\n        this.measureBorderColor(config.measureBorderColor);\n        this.measureLineType(config.measureLineType);\n        this.measurePointType(config.measurePointType);\n        this.tooltip(config.tooltip);\n    }\n\n    var _setAxisColor = function(axis, color) {\n        var path = axis.select('path'),\n            ticks = axis.selectAll('.tick');\n\n        path.style('stroke', color);\n\n        ticks.select('line')\n            .style('stroke', color);\n\n        ticks.select('text')\n            .style('fill', color);\n    }\n\n    /* Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the bar\n     * @param {function} chart Line Vertical Bar chart function\n     * @return {string} String encoded HTML data\n     */\n    var _buildTooltipData = function(datum, chart) {\n        var output = \"\";\n\n        output += \"<table><tr>\"\n            + \"<th>\" + (_dimensionDisplayName || _dimension[0]) + \": </th>\"\n            + \"<td>\" + datum[_dimension[0]] + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + (_measureDisplayName[_measure.indexOf(datum['measure'])] || datum['measure']) + \": </th>\"\n            + \"<td>\" + datum[datum['measure']] + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    /* Returns the D3 symbol for the given point shape\n     *\n     * @param {string} pointType Name of the point shape\n     * @return {object} D3 symbol\n     */\n    var _getSymbolForPointType = function(pointType) {\n        var symbol = null;\n\n        switch(pointType.toLowerCase()) {\n            case \"rectrounded\":\n                symbol = d3.symbolDiamond;\n                break;\n\n            case \"rectrot\":\n                symbol = d3.symbolDiamond;\n                break;\n\n            case \"star\":\n                symbol = d3.symbolStar;\n                break;\n\n            case \"triangle\":\n                symbol = d3.symbolTriangle;\n                break;\n\n            case \"circle\":\n                symbol = d3.symbolCircle;\n                break;\n\n            case \"cross\":\n                symbol = d3.symbolCross;\n                break;\n\n            case \"crossrot\":\n                symbol = d3.symbolCross;\n                break;\n\n            case \"dash\":\n                symbol = d3.symbolWye;\n                break;\n\n            case \"line\":\n                symbol = d3.symbolWye;\n                break;\n\n            case \"rect\":\n                symbol = d3.symbolSquare;\n                break;\n\n            default:\n                symbol = d3.symbolCircle;\n        }\n\n        return symbol;\n    }\n\n    var _handleMouseOverFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'pointer');\n\n            var barGroup = container.selectAll('g.bar')\n                .filter(function(d1) {\n                    return (d1[_dimension[0]] === d[_dimension[0]]) && (d1['measure'] === d['measure']);\n                });\n\n            barGroup.select('rect:not(.bar-rect-mask)')\n                .style('fill', COMMON.HIGHLIGHTER)\n                .style('stroke', COMMON.HIGHLIGHTER);\n\n            barGroup.select('rect.bar-rect-mask')\n                .attr('visibility', 'visible');\n\n            if(tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            if(tooltip) {\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'default');\n\n            var barGroup = container.selectAll('g.bar')\n                .filter(function(d1) {\n                    return (d1[_dimension[0]] === d[_dimension[0]]) && (d1['measure'] === d['measure']);\n                });\n\n            barGroup.select('rect:not(.bar-rect-mask)')\n                .style('fill', function(d1, i1) {\n                    if(typeof _measureDisplayColor[i1] == 'undefined' || _measureDisplayColor[i1].trim() == '') {\n                        return COMMON.COLORSCALE(d1['measure']);\n                    }\n                    return _measureDisplayColor[i1];\n                })\n                .style('stroke', function(d1, i1) {\n                    if(typeof _measureBorderColor[i1] == 'undefined' || _measureBorderColor[i1].trim() == '') {\n                        return COMMON.COLORSCALE(d1['measure']);\n                    }\n                    return _measureBorderColor[i1];\n                });\n\n            barGroup.select('rect.bar-rect-mask')\n                .attr('visibility', 'hidden');\n            \n            if(tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    var _legendMouseOver = function(data) {\n        d3.selectAll('g.arc')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('fill', COMMON.HIGHLIGHTER);\n\n        d3.selectAll('g.arc-mask')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('visibility', 'visible');\n    }\n\n    var _legendMouseMove = function(data) {\n\n    }\n\n    var _legendMouseOut = function(data) {\n        d3.selectAll('g.arc')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('fill', function(d, i) {\n                return COMMON.COLORSCALE(d.data[_dimension[0]]);\n            });\n\n        d3.selectAll('g.arc-mask')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('visibility', 'hidden');\n    }\n\n    var _legendClick = function(data) {\n        if(_localLabelStack.indexOf(data[_dimension[0]]) < 0) {\n            _localLabelStack.push(data[_dimension[0]]);\n        } else {\n            _localLabelStack.splice(_localLabelStack.indexOf(data[_dimension[0]]), 1);\n        }\n\n        chart.update(_localData);\n    }\n\n    function chart(selection) {\n        _localSVG = selection;\n\n        selection.each(function(data) {\n            var svg = d3.select(this),\n                width = +svg.attr('width'),\n                height = +svg.attr('height'),\n                parentWidth = width - 2 * COMMON.PADDING,\n                parentHeight = height - 2 * COMMON.PADDING;\n\n            /* store the data in local variable */\n            _localData = data;\n\n            /* total sum of the measure values */\n            _localTotal = _measure.map(function(m) {\n                return {\n                    measure: m,\n                    positiveTotal: d3.sum(data.map(function(d) { return (d[m] >= 0) ? d[m] : 0; })),\n                    negativeTotal: d3.sum(data.map(function(d) { return (d[m] < 0) ? Math.abs(d[m]) : 0; }))\n                }\n            });\n\n            /* applying sort operation to the data */\n            // UTIL.sorter(data, _measure, _sort);\n\n            var container = svg.append('g')\n                .classed('container', true)\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            var legendWidth = 0,\n                legendHeight = 0,\n                plotWidth = parentWidth - (_yAxis ? COMMON.AXIS_THICKNESS : 0),\n                plotHeight = parentHeight - (_xAxis ? (COMMON.AXIS_THICKNESS / 1.5) : 0);\n\n            if(_legend) {\n                _localLegend = LEGEND.bind(chart);\n\n                var result = _localLegend(_measure, container, {\n                    width: parentWidth,\n                    height: parentHeight\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n\n                switch(_legendPosition) {\n                    case 'top':\n                    case 'bottom':\n                        plotHeight = plotHeight - legendHeight - (_xAxis ? (COMMON.AXIS_THICKNESS / 1.5) : 0);\n                        break;\n                    case 'right':\n                        plotWidth = plotWidth - legendWidth - (COMMON.AXIS_THICKNESS / 2)\n                        break;\n                    case 'left':\n                        plotWidth = plotWidth - legendWidth;\n                        break;\n                }\n            }\n\n            if(_tooltip) {\n                _localTooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            /* Label values for the dimension */\n            _localXLabels = data.map(function(d) {\n                return d[_dimension[0]];\n            });\n\n            /* Minimum and Maximum value of the measures */\n            _measure.forEach(function(m) {\n                var temp = d3.min(data, function(d) { return d[m]; });\n                _localMin = _localMin > temp ? temp : _localMin;\n\n                temp = d3.max(data, function(d) { return d[m]; });\n                _localMax = _localMax < temp ? temp : _localMax;\n            });\n            \n            _x.domain(_localXLabels)\n                .rangeRound([0, plotWidth]);\n\n            _xGrid.domain([0, _localXLabels.length])\n                .range([0, plotWidth]);\n\n            _y.domain([_localMin, _localMax])\n                .range([plotHeight, 0])\n                .nice();\n\n            _line.x(function(d) {\n                    return _x(d[_dimension[0]]);\n                })\n                .y(function(d) {\n                    return _y(d[d['measure']]);\n                });\n\n            _area.x(function(d) {\n                    return _x(d[_dimension[0]]);\n                })\n                .y0(plotHeight)\n                .y1(function(d) {\n                    return _y(d[d['measure']]);\n                });\n\n            var plot = container.append('g')\n                .attr('id', 'line-plot')\n                .attr('transform', function() {\n                    var translate = [0, 0];\n\n                    switch(_legendPosition) {\n                        case 'top':\n                            translate = [COMMON.AXIS_THICKNESS, (legendHeight + (_xAxis ? COMMON.AXIS_THICKNESS : 0) / 1.5)];\n                            break;\n                        case 'bottom':\n                        case 'right':\n                            translate = [(_yAxis ? COMMON.AXIS_THICKNESS : 0), 0];\n                            break;\n                        case 'left':\n                            translate = [(legendWidth + (_yAxis ? COMMON.AXIS_THICKNESS : 0)), 0]\n                    }\n\n                    return 'translate(' + translate.toString() + ')';\n                });\n\n            /* Axes Grid */\n            _localXGrid = d3.axisBottom()\n                .ticks(_localXLabels.length)\n                .tickFormat('')\n                .tickSize(-plotHeight);\n\n            _localYGrid = d3.axisLeft()\n                .tickFormat('')\n                .tickSize(-plotWidth);\n        \n            _localXGrid.scale(_xGrid);\n            _localYGrid.scale(_y);\n\n            plot.append('g')\n                .attr('class', 'x grid')\n                .attr('visibility', function() {\n                    return _grid ? 'visible' : 'hidden';\n                })\n                .attr('transform', 'translate(0, ' + plotHeight + ')')\n                .call(_localXGrid);\n\n            plot.append('g')\n                .attr('class', 'y grid')\n                .attr('visibility', function() {\n                    return _grid ? 'visible' : 'hidden';\n                })\n                .call(_localYGrid);\n\n            var cluster = plot.selectAll('.cluster')\n                .data(_measure)\n                .enter().append('g')\n                    .classed('cluster', true);\n\n            var lineGroup = cluster.append('g')\n                .attr('id', function(d, i) {\n                    return 'line-group-' + i;\n                })\n                .classed('line', true);\n\n            lineGroup.append('path')\n                .datum(function(m, i) {\n                    var clone = jQuery.extend(true, [], data); // deep copy\n\n                    return clone.map(function(d) {\n                        d['measure'] = m;\n                        return d;\n                    });\n                })\n                .style('fill', 'none')\n                .style('stroke', function(d, i) {\n                    if(typeof _measureBorderColor[i] == 'undefined' || _measureBorderColor[i].trim() == '') {\n                        return COMMON.COLORSCALE(_measure[i]);\n                    }\n                    return _measureBorderColor[i];\n                })\n                .style('stroke-linejoin', 'round')\n                .style('stroke-linecap', 'round')\n                .style('stroke-width', 3)\n                .attr('d', _line)\n                .transition()\n                .duration(COMMON.DURATION)\n                .attrTween('stroke-dasharray', function() {\n                    var l = this.getTotalLength(),\n                        interpolator = d3.interpolateString('0,' + l, l + ',' + l);\n\n                    return function(t) {\n                        return interpolator(t);\n                    }\n                });\n\n            lineGroup.append('path')\n                .datum(function(m, i) {\n                    var clone = jQuery.extend(true, [], data); // deep copy\n\n                    return clone.map(function(d) {\n                        d['measure'] = m;\n                        return d;\n                    });\n                })\n                .style('fill', function(d, i) {\n                    if(typeof _measureDisplayColor[i] == 'undefined' || _measureDisplayColor[i].trim() == '') {\n                        return COMMON.COLORSCALE(_measure[i]);\n                    }\n                    return _measureDisplayColor[i];\n                })\n                .style('stroke-width', 0)\n                .style('fill-opacity', 0.3)\n                .style('opacity', 0)\n                .attr('d', _area)\n                .transition()\n                .duration(COMMON.DURATION)\n                .styleTween('opacity', function() {\n                    var interpolator = d3.interpolateNumber(0, 1);\n\n                    return function(t) {\n                        return interpolator(t);\n                    }\n                });\n\n            lineGroup.selectAll('.line-point')\n                .data(function(m, i) {\n                    var clone = jQuery.extend(true, [], data); // deep copy\n\n                    return clone.map(function(d) {\n                        d['measure'] = m;\n                        return d;\n                    });\n                })\n                .enter().append('path')\n                    .classed('line-point', true)\n                    .style('fill', function(d, i) {\n                        var index = _measure.indexOf(d['measure']);\n\n                        if(typeof _measureDisplayColor[index] == 'undefined' || _measureDisplayColor[index].trim() == '') {\n                            return COMMON.COLORSCALE(_measure[index]);\n                        }\n                        return _measureDisplayColor[index];\n                    })\n                    .attr('d', function(d, i) {\n                        var index = _measure.indexOf(d['measure']);\n                        return d3.symbol()\n                            .type(_getSymbolForPointType(_measurePointType[index]))\n                            .size(40)();\n                    })\n                    .attr('transform', function(d) {\n                        return 'translate(' + _x(d[_dimension[0]]) + ',' + _y(d[d['measure']]) + ')';\n                    })\n                    .on('mouseover', _handleMouseOverFn.call(chart, _localTooltip, svg))\n                    .on('mousemove', _handleMouseMoveFn.call(chart, _localTooltip, svg))\n                    .on('mouseout', _handleMouseOutFn.call(chart, _localTooltip, svg))\n                    .on('click', function(d, i) {\n                        \n                    });\n\n            var text = lineGroup.selectAll('.line-text')\n                .data(function(m, i) {\n                    var clone = jQuery.extend(true, [], data); // deep copy\n\n                    return clone.map(function(d) {\n                        d['measure'] = m;\n                        return d;\n                    });\n                })\n                .enter().append('text')\n                .classed('line-text', true)\n                .attr('x', function(d, i) {\n                    return _x(d[_dimension[0]]);\n                })\n                .attr('y', function(d, i) {\n                    return plotHeight;\n                })\n                .attr('dy', function(d, i) {\n                    return -COMMON.OFFSET;\n                })\n                .attr('opacity', 0)\n                .attr('visibility', function(d, i) {\n                    var index = _measure.indexOf(d['measure']);\n\n                    return _measureShowValue[index] ? \"visible\" : \"hidden\";\n                })\n                .style('font-style', function(d, i) {\n                    var index = _measure.indexOf(d['measure']);\n\n                    return _measureFontStyle[index] || COMMON.DEFAULT_FONTSTYLE;\n                })\n                .style('font-weight', function(d, i) {\n                    var index = _measure.indexOf(d['measure']);\n\n                    return _measureFontWeight[index] || COMMON.DEFAULT_FONTWEIGHT;\n                })\n                .style('font-size', function(d, i) {\n                    var index = _measure.indexOf(d['measure']);\n\n                    return _measureFontSize[index] || COMMON.DEFAULT_FONTSIZE;\n                })\n                .style('fill', function(d, i) {\n                    var index = _measure.indexOf(d['measure']);\n\n                    if(typeof _measureTextColor[index] == 'undefined' || _measureTextColor[index].trim() == '') {\n                        return COMMON.DEFAULT_COLOR;\n                    }\n                    return _measureTextColor[index];\n                })\n                .style('text-anchor', 'middle');\n\n            text.transition()\n                .duration(COMMON.DURATION)\n                .attr('opacity', 1)\n                .attr('y', function(d, i) {\n                    return _y(d[d['measure']]);\n                })\n                .text(function(d, i) {\n                    var index = _measure.indexOf(d['measure']);\n\n                    var formatter = UTIL.getNumberFormatterFn(_measureNumberFormat[index]),\n                        value = d[d['measure']],\n                        lt = _localTotal.filter(function(lt) {\n                            return lt['measure'] == d['measure'];\n                        })[0],\n                        positiveTotal = lt['positiveTotal'],\n                        negativeTotal = lt['negativeTotal'];\n\n                    if(_measureNumberFormat[index] == 'percent') {\n                        value = (value >= 0) ? (value / positiveTotal) : (value / negativeTotal);\n                    }\n\n                    return formatter(UTIL.roundNumber(value, 2)).toUpperCase();\n                });\n\n            /* Axes */\n            var xAxisGroup,\n                yAxisGroup;\n\n            if(_xAxis) {\n                _localXAxis = d3.axisBottom(_x)\n                    .tickSize(0)\n                    .tickPadding(10);\n\n                xAxisGroup = plot.append('g')\n                    .attr('class', 'x axis')\n                    .attr('visibility', function() {\n                        return 'visible';\n                    })\n                    .attr('transform', 'translate(0, ' + plotHeight + ')')\n                    .call(_localXAxis);\n\n                xAxisGroup.append('g')\n                    .attr('class', 'label')\n                    .attr('transform', function() {\n                        return 'translate(' + (plotWidth) + ', ' + (COMMON.AXIS_THICKNESS / 1.5) + ')';\n                    })\n                    .append('text')\n                        .style('text-anchor', 'end')\n                        .style('font-weight', 'bold')\n                        .style('fill', _xAxisColor)\n                        .text(_xAxisLabel);\n\n                _setAxisColor(xAxisGroup, _xAxisColor);\n            }\n\n            if(_yAxis) {\n                _localYAxis = d3.axisLeft(_y)\n                    .tickSize(0)\n                    .tickPadding(8)\n                    .tickFormat(function(d) {\n                        return UTIL.shortScale(2)(d);\n                    });\n\n                yAxisGroup = plot.append('g')\n                    .attr('class', 'y axis')\n                    .attr('visibility', function() {\n                        return 'visible';\n                    })\n                    .call(_localYAxis);\n\n                yAxisGroup.append('g')\n                    .attr('class', 'label')\n                    .attr('transform', function() {\n                        return 'translate(' + (-COMMON.AXIS_THICKNESS / 1.15) + ', ' + '0)';\n                    })\n                    .append('text')\n                        .attr('transform', 'rotate(-90)')\n                        .style('text-anchor', 'end')\n                        .style('font-weight', 'bold')\n                        .style('fill', _yAxisColor)\n                        .text(_yAxisLabel);\n\n                _setAxisColor(yAxisGroup, _yAxisColor);\n            }\n        });\n    }\n\n    /**\n     * Private method that delegates legend interactions to respective controllers\n     *\n     * @param {object} event Mouseevent instance\n     * @param {object} datum Record of the data binded to the legend item\n     * @return {undefined}\n     */\n    chart._legendInteraction = function(event, data) {\n        switch(event) {\n            case 'mouseover':\n                _legendMouseOver(data);\n                break;\n            case 'mousemove':\n                _legendMouseMove(data);\n                break;\n            case 'mouseout':\n                _legendMouseOut(data);\n                break;\n            case 'click':\n                _legendClick(data);\n                break;\n        }\n    }\n\n    chart._getName = function() {\n        return _NAME;\n    }\n\n    chart.update = function(data) {\n        var svg = _localSVG,\n            width = +svg.attr('width'),\n            height = +svg.attr('height'),\n            parentWidth = width - 2 * COMMON.PADDING,\n            parentHeight = height - 2 * COMMON.PADDING,\n            filteredData,\n            _localMin = 0,\n            _localMax = 0;\n\n        /* store the data in local variable */\n        _localData = data;\n\n        /* Label values for the dimension */\n        _localXLabels = data.map(function(d) {\n            return d[_dimension[0]];\n        });\n\n        /* Minimum and Maximum value of the measures */\n        _measure.forEach(function(m) {\n            var temp = d3.min(data, function(d) { return d[m]; });\n            _localMin = _localMin > temp ? temp : _localMin;\n\n            temp = d3.max(data, function(d) { return d[m]; });\n            _localMax = _localMax < temp ? temp : _localMax;\n        });\n        \n        /* Update the axes scales */\n        _x.domain(_localXLabels);\n        _xGrid.domain([0, _localXLabels.length]);\n        _y.domain([_localMin, _localMax])\n            .nice();\n\n        if(_legend) {\n            svg.select('.legend').remove();\n            \n            _localLegend(_measure, svg.select('g'), {\n                width: parentWidth,\n                height: parentHeight\n                // labelStack: _localLabelStack\n            });\n        }\n\n        var clusterGroup = svg.selectAll('.cluster')\n            .data(data);\n            \n        clusterGroup.enter().append('g')\n            .attr('id', function(d, i) {\n                return 'cluster-group-' + i;\n            })\n            .classed('cluster', true)\n            .attr('transform', function(d) {\n                return 'translate(' + _x(d[_dimension[0]]) + ', 0)';\n            });\n\n        var barGroup = clusterGroup.selectAll('.bar')\n            .data(function(d) {\n                return _measure.map(function(m) {\n                    var obj = {};\n                    obj[_dimension[0]] = d[_dimension[0]];\n                    obj[m] = d[m];\n                    obj['measure'] = m;\n                    return obj;\n                });\n            })\n            .enter().append('g')\n                .attr('id', function(d, i) {\n                    return 'bar-group-' + i;\n                })\n                .classed('bar', true);\n\n        var rect = barGroup.append('rect')\n            .attr('width', _xMeasure.bandwidth())\n            .attr('height', 0)\n            .style('fill', function(d, i) {\n                if(typeof _measureDisplayColor[i] == 'undefined' || _measureDisplayColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureDisplayColor[i];\n            })\n            .style('stroke', function(d, i) {\n                if(typeof _measureBorderColor[i] == 'undefined' || _measureBorderColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureBorderColor[i];\n            })\n            .style('stroke-width', 1)\n            .on('mouseover', _handleMouseOverFn.call(chart, _localTooltip, svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, _localTooltip, svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, _localTooltip, svg))\n            .on('click', function(d, i) {\n                \n            });\n\n        var text = barGroup.append('text')\n            .attr('y', function(d, i) {\n                return plotHeight;\n            })\n            .attr('dy', function(d, i) {\n                return COMMON.OFFSET;\n            })\n            .attr('opacity', 0)\n            .attr('visibility', function(d, i) {\n                return _measureShowValue[i];\n            })\n            .style('font-style', function(d, i) {\n                return _measureFontStyle[i] || COMMON.DEFAULT_FONTSTYLE;\n            })\n            .style('font-weight', function(d, i) {\n                return _measureFontWeight[i] || COMMON.DEFAULT_FONTWEIGHT;\n            })\n            .style('font-size', function(d, i) {\n                return _measureFontSize[i] || COMMON.DEFAULT_FONTSIZE;\n            })\n            .style('fill', function(d, i) {\n                if(typeof _measureTextColor[i] == 'undefined' || _measureTextColor[i].trim() == '') {\n                    return COMMON.DEFAULT_COLOR;\n                }\n                return _measureTextColor[i];\n            })\n            .style('text-anchor', 'middle');\n\n        var rectMask = barGroup.append('rect')\n            .classed('bar-rect-mask', true)\n            .attr('width', _xMeasure.bandwidth())\n            .attr('height', 1)\n            .attr('visibility', 'hidden')\n            .style('fill', function(d, i) {\n                if(typeof _measureDisplayColor[i] == 'undefined' || _measureDisplayColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureDisplayColor[i];\n            })\n            .style('stroke', function(d, i) {\n                if(typeof _measureBorderColor[i] == 'undefined' || _measureBorderColor[i].trim() == '') {\n                    return COMMON.COLORSCALE(d['measure']);\n                }\n                return _measureBorderColor[i];\n            })\n            .style('stroke-width', 1);\n\n        clusterGroup.merge(clusterGroup)\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('transform', function(d) {\n                return 'translate(' + _x(d[_dimension[0]]) + ', 0)';\n            });\n\n        clusterGroup.selectAll('.bar').select('rect:not(.bar-rect-mask)')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('height', function(d, i) {\n                return _y(0) - _y(d[d['measure']]);\n            })\n            .attr('width', _xMeasure.bandwidth())\n            .attr('x', function(d, i) {\n                return _xMeasure(d['measure']);\n            })\n            .attr('y', function(d, i) {\n                return _y(d[d['measure']]);\n            });\n\n        clusterGroup.selectAll('.bar').select('rect.bar-rect-mask')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('width', _xMeasure.bandwidth())\n            .attr('x', function(d, i) {\n                return _xMeasure(d['measure']);\n            })\n            .attr('y', function(d, i) {\n                return _y(d[d['measure']]) - (COMMON.OFFSET / 3);\n            });\n\n        clusterGroup.selectAll('.bar').select('text')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('opacity', 1)\n            .attr('x', function(d, i) {\n                return _xMeasure(d['measure']) + (_xMeasure.bandwidth() / 2);\n            })\n            .attr('y', function(d, i) {\n                return _y(d[d['measure']]);\n            })\n            .text(function(d, i) {\n                var formatter = UTIL.getNumberFormatterFn(_measureNumberFormat[i]),\n                    value = d[d['measure']],\n                    lt = _localTotal.filter(function(lt) {\n                        return lt['measure'] == d['measure'];\n                    })[0],\n                    positiveTotal = lt['positiveTotal'],\n                    negativeTotal = lt['negativeTotal'];\n\n                if(_measureNumberFormat[i] == 'percent') {\n                    value = (value >= 0) ? (value / positiveTotal) : (value / negativeTotal);\n                }\n\n                return formatter(UTIL.roundNumber(value, 2)).toUpperCase();\n            });\n\n        clusterGroup.exit().selectAll('rect:not(.bar-rect-mask)')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('height', 0)\n            .attr('y', _y(0))\n            .remove();\n\n        clusterGroup.exit().selectAll('text')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('y', _y(0))\n            .remove();\n\n        /* Update Axes */\n        var xAxisGroup,\n            yAxisGroup;\n\n        if(_xAxis) {\n            xAxisGroup = svg.select('.x.axis')\n                .transition()\n                .duration(COMMON.DURATION)\n                .call(_localXAxis);\n\n            _setAxisColor(xAxisGroup, _xAxisColor);\n        }\n           \n        if(_yAxis) {\n            yAxisGroup = svg.select('.y.axis')\n                .transition()\n                .duration(COMMON.DURATION)\n                .call(_localYAxis);\n\n            _setAxisColor(yAxisGroup, _yAxisColor);\n        }\n\n        /* Update Axes Grid */\n        _localXGrid.ticks(_localXLabels.length);\n\n        svg.select('.x.grid')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('visibility', function() {\n                return _grid ? 'visible' : 'hidden';\n            })\n            .call(_localXGrid);\n\n        svg.select('.y.grid')\n            .transition()\n            .duration(COMMON.DURATION)\n            .attr('visibility', function() {\n                return _grid ? 'visible' : 'hidden';\n            })\n            .call(_localYGrid);\n    }\n\n    chart.config = function(value) {\n        if(!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function(value) {\n        if(!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function(value) {\n        if(!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.xAxis = function(value) {\n        if(!arguments.length) {\n            return _xAxis;\n        }\n        _xAxis = value;\n        return chart;\n    }\n\n    chart.yAxis = function(value) {\n        if(!arguments.length) {\n            return _yAxis;\n        }\n        _yAxis = value;\n        return chart;\n    }\n\n    chart.xAxisColor = function(value) {\n        if(!arguments.length) {\n            return _xAxisColor;\n        }\n        _xAxisColor = value;\n        return chart;\n    }\n\n    chart.yAxisColor = function(value) {\n        if(!arguments.length) {\n            return _yAxisColor;\n        }\n        _yAxisColor = value;\n        return chart;\n    }\n    \n    chart.xAxisLabel = function(value) {\n        if(!arguments.length) {\n            return _xAxisLabel;\n        }\n        _xAxisLabel = value;\n        return chart;\n    }\n\n    chart.yAxisLabel = function(value) {\n        if(!arguments.length) {\n            return _yAxisLabel;\n        }\n        _yAxisLabel = value;\n        return chart;\n    }\n\n    chart.legend = function(value) {\n        if(!arguments.length) {\n            return _legend;\n        }\n        _legend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function(value) {\n        if(!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.grid = function(value) {\n        if(!arguments.length) {\n            return _grid;\n        }\n        _grid = value;\n        return chart;\n    }\n\n    chart.stacked = function(value) {\n        if(!arguments.length) {\n            return _stacked;\n        }\n        _stacked = value;\n        return chart;\n    }\n\n    chart.dimensionDisplayName = function(value) {\n        if(!arguments.length) {\n            return _dimensionDisplayName;\n        }\n        _dimensionDisplayName = value;\n        return chart;\n    }\n\n    /**\n     * Line Measure Showvalue accessor function\n     *\n     * @param {boolean|array(boolean)|null} value Measure Showvalue value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {boolean|array(boolean)|function}\n     */\n    chart.measureShowValue = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureShowValue, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure Displayname accessor function\n     *\n     * @param {string|array(string)|null} value Measure Displayname value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureDisplayName = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureDisplayName, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure FontStyle accessor function\n     *\n     * @param {string|array(string)|null} value Measure FontStyle value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureFontStyle = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureFontStyle, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure FontWeight accessor function\n     *\n     * @param {number|array(number)|null} value Measure FontWeight value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {number|array(number)|function}\n     */\n    chart.measureFontWeight = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureFontWeight, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure FontSize accessor function\n     *\n     * @param {number|array(number)|null} value Measure FontSize value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {number|array(number)|function}\n     */\n    chart.measureFontSize = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureFontSize, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure NumberFormat accessor function\n     *\n     * @param {string|array(string)|null} value Measure NumberFormat value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureNumberFormat = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureNumberFormat, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure TextColor accessor function\n     *\n     * @param {string|array(string)|null} value Measure TextColor value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureTextColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureTextColor, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure DisplayColor accessor function\n     *\n     * @param {string|array(string)|null} value Measure DisplayColor value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureDisplayColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureDisplayColor, value, measure, _measure);\n    }\n\n    /**\n     * Line Measure BorderColor accessor function\n     *\n     * @param {string|array(string)|null} value Measure BorderColor value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.measureBorderColor = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureBorderColor, value, measure, _measure);\n    }\n\n    chart.measureLineType = function(value, measure) {\n        return UTIL.baseAccessor.call(_measureLineType, value, measure, _measure);   \n    }\n\n    chart.measurePointType = function(value, measure) {\n        return UTIL.baseAccessor.call(_measurePointType, value, measure, _measure);\n    }\n\n    chart.tooltip = function(value) {\n        if(!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = line;\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/line.js?");

/***/ }),

/***/ "./js/charts/pie.js":
/*!**************************!*\
  !*** ./js/charts/pie.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction pie() {\n\n    /* These are the constant global variable for the function pie.\n     */\n    var _NAME = 'pie';\n\n    /* These are the private variables that is initialized by the arguments sent\n     * by the users and can be updated using public methods.\n     */\n    var _config,\n        _dimension,\n        _measure,\n        _legend,\n        _legendPosition,\n        _valueAs,\n        _valueAsArc,\n        _valuePosition,\n        _sort,\n        _tooltip;\n\n    /* These are the common variables that is shared across the different private/public \n     * methods but is initialized/updated within the methods itself.\n     */\n    var _localSVG,\n        _localTotal = 0,\n        _localTransitionTime = 500,\n        _localTransitionMap = d3.map(),\n        _localSortedMeasureValue = [],\n        _localTooltip,\n        _localKey,\n        _localLegend,\n        _localLabelStack = [],\n        _localData;\n\n    /* These are the common private functions that is shared across the different private/public \n     * methods but is initialized beforehand.\n     */\n    var _pie = d3.pie()\n        .sort(null);\n\n    var _arc = d3.arc()\n        .innerRadius(190);\n\n    var _arcMask = d3.arc();\n\n    var _labelArc = d3.arc();\n\n    /* -------------------------------------------------------------------------------- */\n    var _setConfigParams = function(config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.legend(config.legend);\n        this.legendPosition(config.legendPosition);\n        this.valueAs(config.valueAs);\n        this.valueAsArc(config.valueAsArc);\n        this.valuePosition(config.valuePosition);\n        this.tooltip(config.tooltip);\n    }\n\n    /**\n     * Period function that stretches the rendering process\n     *\n     * @param {number} extraDuration Additional duration value in milliseconds\n     * @return {function} Accessor function that computes the duration period\n     */\n    var _durationFn = function(extraDuration) {\n        if(extraDuration === void 0) { extraDuration = 0; }\n\n        if(isNaN(+extraDuration)) {\n            throw new TypeError('Not a number');\n        }\n\n        return function(d, i) {\n            var t = _localTransitionMap.get(d.value);\n            \n            if(!t) {\n                t = _localTransitionTime * (d.value / _localTotal)\n                _localTransitionMap.set(d.value, t);\n            }\n            \n            return (t + extraDuration);\n        }\n    }\n\n    /**\n     * Delay function that delays the start of rendering process\n     *\n     * @param {number} extraDelay Additional delay value in milliseconds\n     * @return {function} Accessor function that computes the delay period\n     */\n    var _delayFn = function(extraDelay) {\n        if(extraDelay === void 0) { extraDelay = 0; }\n\n        if(isNaN(+extraDelay)) {\n            throw new TypeError('TypeError: Not a number');\n        }\n\n        return function(d, i) {\n            var i = _localSortedMeasureValue.indexOf(d.value),\n                t = 0;\n            \n            while(i > 0) {\n                i--;\n                t += _localTransitionMap.get(_localSortedMeasureValue[i]);\n            }\n            \n            return (t + extraDelay);\n        }\n    }\n\n    /**\n     * Gives the value of hypotenuse using pythagorous theorem\n     *\n     * @param {number} x Value of perpendicular\n     * @param {number} y Value of base\n     * @return {number} Value of hypotenuse\n     */\n    var _pythagorousTheorem = function(x, y) {\n        if(isNaN(+x) || isNaN(+y)) {\n            throw new Error('TypeError: Not a number');\n            return 0;\n        }\n\n        return Math.sqrt(Math.pow(+x, 2) + Math.pow(+y, 2));\n    }\n\n    /**\n     * Label function to provide the label to be shown\n     *\n     * @return {function} Accessor function that identifies the label text\n     */\n    var _labelFn = function() {\n        return function(d, i) {\n            var result;\n\n            switch(_valueAs) {\n                case 'label':\n                    result = d.data[_dimension[0]];\n                    break;\n                case 'value':\n                    result = d.data[_measure[0]];\n                    break;\n                case 'percentage':\n                    result = (100 * d.data[_measure[0]] / _localTotal).toFixed(2) + ' %';\n                    break;\n                default:\n                    result = d.data[_dimension[0]];\n            }\n\n            return result;\n        }\n    }\n\n    /**\n     * Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the arc\n     * @param {function} chart Pie chart function\n     * @return {string} String encoded HTML data\n     */\n    var _buildTooltipData = function(datum, chart) {\n        var output = \"\";\n\n        output += \"<table><tr>\"\n            + \"<th>\" + chart.dimension() + \": </th>\"\n            + \"<td>\" + datum[chart.dimension()] + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + chart.measure() + \": </th>\"\n            + \"<td>\" + datum[chart.measure()] + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var _handleMouseOverFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'pointer');\n\n            var arcGroup = container.selectAll('g.arc')\n                .filter(function(d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcGroup.select('path')\n                .style('fill', COMMON.HIGHLIGHTER);\n\n            var arcMaskGroup = container.selectAll('g.arc-mask')\n                .filter(function(d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcMaskGroup.select('path')\n                .style('visibility', 'visible');\n\n            if(tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d.data, me), container);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            if(tooltip) {\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d.data, me), container);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function(tooltip, container) {\n        var me = this;\n\n        return function(d, i) {\n            d3.select(this).style('cursor', 'default');\n\n            var arcGroup = container.selectAll('g.arc')\n                .filter(function(d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcGroup.select('path')\n                .style('fill', function(d1) {\n                    return COMMON.COLORSCALE(d1.data[_dimension[0]]);\n                });\n\n            var arcMaskGroup = container.selectAll('g.arc-mask')\n                .filter(function(d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcMaskGroup.select('path')\n                .style('visibility', 'hidden');\n            \n            if(tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    var _legendMouseOver = function(data) {\n        d3.selectAll('g.arc')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('fill', COMMON.HIGHLIGHTER);\n\n        d3.selectAll('g.arc-mask')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('visibility', 'visible');\n    }\n\n    var _legendMouseMove = function(data) {\n\n    }\n\n    var _legendMouseOut = function(data) {\n        d3.selectAll('g.arc')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('fill', function(d, i) {\n                return COMMON.COLORSCALE(d.data[_dimension[0]]);\n            });\n\n        d3.selectAll('g.arc-mask')\n            .filter(function(d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            })\n            .select('path')\n            .style('visibility', 'hidden');\n    }\n\n    var _legendClick = function(data) {\n        if(_localLabelStack.indexOf(data[_dimension[0]]) < 0) {\n            _localLabelStack.push(data[_dimension[0]]);\n        } else {\n            _localLabelStack.splice(_localLabelStack.indexOf(data[_dimension[0]]), 1);\n        }\n\n        chart.update(_localData);\n    }\n\n    var _mergeForTransition = function(fData, sData) {\n        var secondSet = d3.set();\n\n        sData.forEach(function(d) {\n            secondSet.add(d[_dimension[0]]);\n        });\n\n        var onlyFirst = fData.filter(function(d) {\n                return !secondSet.has(d[_dimension[0]]);\n            })\n            .map(function(d) {\n                var obj = {};\n\n                obj[_dimension[0]] = d[_dimension[0]];\n                obj[_measure[0]] = 0;\n\n                return obj;\n            });\n\n        return d3.merge([sData, onlyFirst])\n            .sort(function(a, b) {\n                return d3.ascending(a[_dimension[0]], b[_dimension[0]]);\n            })\n    }\n\n    function chart(selection) {\n        _localSVG = selection;\n\n        selection.each(function(data) {\n            var svg = d3.select(this),\n                width = +svg.attr('width'),\n                height = +svg.attr('height'),\n                parentWidth = width - 2 * COMMON.PADDING,\n                parentHeight = height - 2 * COMMON.PADDING,\n                outerRadius;\n\n            /* total sum of the measure values */\n            _localTotal = d3.sum(data.map(function(d) { return d[_measure[0]]; }));\n\n            /* store the data in local variable */\n            _localData = data;\n\n            /* applying sort operation to the data */\n            // UTIL.sorter(data, _measure, _sort);\n\n            data.sort(function(a, b) {\n                return d3.ascending(a[_dimension[0]], b[_dimension[0]]);\n            });\n\n            /* extracting measure values only from the data */\n            _localSortedMeasureValue = data.map(function(d) { return +d[_measure[0]]; })\n\n            var container = svg.append('g')\n                .classed('container', true)\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            var legendWidth = 0,\n                legendHeight = 0,\n                plotWidth = parentWidth,\n                plotHeight = parentHeight;\n\n            if(_legend) {\n                _localLegend = LEGEND.bind(chart);\n\n                var result = _localLegend(data, container, {\n                    width: parentWidth,\n                    height: parentHeight\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n\n                switch(_legendPosition) {\n                    case 'top':\n                    case 'bottom':\n                        plotHeight = plotHeight - legendHeight;\n                        break;\n                    case 'right':\n                    case 'left':\n                        plotWidth = plotWidth - legendWidth;\n                        break;\n                }\n            }\n\n            if(_tooltip) {\n                _localTooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            outerRadius = Math.min(plotWidth, plotHeight) / 2.25;\n            \n            /* setting the outerradius of the arc */\n            _arc.outerRadius(outerRadius);\n\n            /* setting the innerradius and outerradius of the masking arc */\n            _arcMask.outerRadius(outerRadius * 1.02)\n                .innerRadius(outerRadius * 1.01);\n\n            /* setting the outerradius and innerradius of the arc */\n            _labelArc.outerRadius(outerRadius)\n                .innerRadius(outerRadius * 0.8);\n\n            var plot = container.append('g')\n                .attr('id', 'pie-plot')\n                .attr('transform', function() {\n                    var translate = [0, 0];\n\n                    switch(_legendPosition) {\n                        case 'top':\n                            translate = [(plotWidth / 2), legendHeight + (plotHeight / 2)];\n                            break;\n                        case 'bottom':\n                        case 'right':\n                            translate = [(plotWidth / 2), (plotHeight / 2)];\n                            break;\n                        case 'left':\n                            translate = [legendWidth + (plotWidth / 2), (plotHeight / 2)]\n                    }\n\n                    return 'translate(' + translate.toString() + ')';\n                });\n\n            _localKey = function(d) {\n                return d.data[_dimension[0]];\n            }\n\n            var pieMask = plot.append('g')\n                .attr('id', 'arc-mask-group')\n                .selectAll('.arc-mask')\n                .data(_pie(data), _localKey)\n                .enter().append('g')\n                    .attr('id', function(d, i) {\n                        return 'arc-mask-group-' + i;\n                    })\n                    .classed('arc-mask', true)\n                    .append('path')\n                        .attr('id', function(d, i) {\n                            return 'arc-mask-path-' + i;\n                        })\n                        .attr('d', _arcMask)\n                        .style('visibility', 'hidden')\n                        .style('fill', function(d) {\n                            return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                        })\n                        .each(function(d) {\n                            this._current = d;\n                        });\n\n            var pieArcGroup = plot.append('g')\n                .attr('id', 'arc-group')\n                .selectAll('.arc')\n                .data(_pie(data), _localKey)\n                .enter().append('g')\n                    .attr('id', function(d, i) {\n                        return 'arc-group-' + i;\n                    })\n                    .classed('arc', true);\n\n            var pieArcPath = pieArcGroup.append('path')\n                .attr('id', function(d, i) {\n                    return 'arc-path-' + i;\n                })\n                .style('fill', function(d) {\n                    return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                })\n                .each(function(d) {\n                    this._current = d;\n                })\n                .on('mouseover', _handleMouseOverFn.call(chart, _localTooltip, svg))\n                .on('mousemove', _handleMouseMoveFn.call(chart, _localTooltip, svg))\n                .on('mouseout', _handleMouseOutFn.call(chart, _localTooltip, svg))\n                .on('click', function(d, i) {\n                    \n                });\n\n            pieArcPath.transition()\n                .duration(_durationFn())\n                .delay(_delayFn())\n                .attrTween('d', function(d) {\n                    var i = d3.interpolate(d.startAngle + 0.1, d.endAngle);\n                    return function(t) {\n                        d.endAngle = i(t); \n                        return _arc(d)\n                    }\n                });\n\n            var pieLabel;\n\n            if(_valueAsArc) {\n                pieLabel = pieArcGroup.append('text')\n                    .attr('dy', function(d, i) {\n                        if(_valuePosition == 'inside') {\n                            return 10;\n                        } else {\n                            return -5;\n                        }\n                    })\n                \n                pieLabel.append('textPath')\n                    .attr('xlink:href', function(d, i) {\n                        return '#arc-path-' + i;\n                    })\n                    .attr('text-anchor', function() {\n                        return 'middle';\n                    })\n                    .transition()\n                    .delay(_delayFn(200))\n                    .on('start', function() {\n                        d3.select(this).attr('startOffset', function(d) {\n                            var length = pieArcPath.nodes()[d.index].getTotalLength();\n                            return 50 * (length - 2 * outerRadius)/length + '%';\n                        })\n                        .text(_labelFn())\n                        .filter(function(d, i) {\n                            /* length of arc = angle in radians * radius */\n                            var diff = d.endAngle - d.startAngle;\n                            return outerRadius * diff < this.getComputedTextLength();\n                        })\n                        .remove();\n                    });\n            } else {\n                var pieArcTextGroup = plot.selectAll('.arc-text')\n                    .data(_pie(data))\n                    .enter().append('g')\n                        .attr('id', function(d, i) {\n                            return 'arc-text-group-' + i;\n                        })\n                        .classed('arc-text', true);\n\n                pieLabel = pieArcTextGroup.append('text')\n                    .attr('transform', function(d) {\n                        var centroid = _labelArc.centroid(d),\n                            x = centroid[0],\n                            y = centroid[1],\n                            h = _pythagorousTheorem(x, y);\n\n                        if(_valuePosition == 'inside') {\n                            return 'translate('\n                                + outerRadius * (x / h) * 0.85\n                                + ', '\n                                + outerRadius * (y / h) * 0.85\n                                + ')';\n                        } else {\n                            return 'translate('\n                                + outerRadius * (x / h) * 1.05\n                                + ', '\n                                + outerRadius * (y / h) * 1.05\n                                + ')';\n                        }\n                    })\n                    .attr('dy', '0.35em')\n                    .attr('text-anchor', function(d) {\n                        if(_valuePosition == 'inside') {\n                            return 'middle';\n                        } else {\n                            return (d.endAngle + d.startAngle) / 2 > Math.PI\n                                ? 'end' : (d.endAngle + d.startAngle) / 2 < Math.PI\n                                ? 'start' : 'middle';\n                        }\n                    })\n                    .transition()\n                    .delay(_delayFn(200))\n                    .on('start', function() {\n                        d3.select(this).text(_labelFn())\n                            .filter(function(d) {\n                                /* length of arc = angle in radians * radius */\n                                var diff = d.endAngle - d.startAngle;\n                                return outerRadius * diff < this.getComputedTextLength();\n                            })\n                            .remove();\n                    });\n            }\n        });\n    }\n\n    /**\n     * Private method that delegates legend interactions to respective controllers\n     *\n     * @param {object} event Mouseevent instance\n     * @param {object} datum Record of the data binded to the legend item\n     * @return {undefined}\n     */\n    chart._legendInteraction = function(event, datum) {\n        switch(event) {\n            case 'mouseover':\n                _legendMouseOver(datum);\n                break;\n            case 'mousemove':\n                _legendMouseMove(datum);\n                break;\n            case 'mouseout':\n                _legendMouseOut(datum);\n                break;\n            case 'click':\n                _legendClick(datum);\n                break;\n        }\n    }\n\n    chart._getName = function() {\n        return _NAME;\n    }\n\n    chart.update = function(data) {\n        var svg = _localSVG,\n            width = +svg.attr('width'),\n            height = +svg.attr('height'),\n            parentWidth = width - 2 * COMMON.PADDING,\n            parentHeight = height - 2 * COMMON.PADDING,\n            filteredData;\n\n        /* store the data in local variable */\n        _localData = data;\n            \n        data.sort(function(a, b) {\n            return d3.ascending(a[_dimension[0]], b[_dimension[0]]);\n        });\n\n        filteredData = data.filter(function(d) {\n                return _localLabelStack.indexOf(d[_dimension[0]]) == -1;\n            });\n\n        var prevData = svg.selectAll('g.arc')\n            .data().map(function(d) { return d.data });\n\n        if(prevData.length == 0) {\n            prevData = filteredData;\n        }\n\n        var oldFilteredData = _mergeForTransition(filteredData, prevData),\n            newFilteredData = _mergeForTransition(prevData, filteredData);\n\n        if(_legend) {\n            svg.select('.legend').remove();\n            \n            _localLegend(data, svg.select('g'), {\n                width: parentWidth,\n                height: parentHeight,\n                labelStack: _localLabelStack\n            });\n        }\n\n        var pieMask = svg.select('#arc-mask-group')\n            .selectAll('g.arc-mask')\n            .data(_pie(oldFilteredData), _localKey)\n            .enter()\n                .insert('g')\n                .attr('id', function(d, i) {\n                    return 'arc-mask-group-' + i;\n                })\n                .classed('arc-mask', true)\n                .append('path')\n                    .attr('id', function(d, i) {\n                        return 'arc-mask-path-' + i;\n                    })\n                    .style('visibility', 'hidden')\n                    .style('fill', function(d) {\n                        return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                    })\n                    .each(function(d) {\n                        this._current = d;\n                    });\n\n        pieMask = svg.selectAll('g.arc-mask')\n            .data(_pie(newFilteredData), _localKey)\n\n        pieMask.select('path')\n            .transition().duration(1000)\n            .attrTween('d', function(d) {\n                var interpolate = d3.interpolate(this._current, d);\n                var _this = this;\n                return function(t) {\n                    _this._current = interpolate(t);\n                    return _arcMask(_this._current);\n                };\n            });\n\n        pieMask = svg.selectAll('g.arc-mask')\n            .data(_pie(filteredData), _localKey);\n\n        pieMask.exit()\n            .transition()\n            .delay(1000)\n            .duration(0)\n            .remove();\n\n        var pieArcGroup = svg.select('#arc-group')\n            .selectAll('g.arc')\n            .data(_pie(oldFilteredData), _localKey)\n            .enter()\n                .insert('g')\n                .attr('id', function(d, i) {\n                    return 'arc-group-' + i;\n                })\n                .classed('arc', true);\n\n        var pieArcPath = pieArcGroup.append('path')\n            .attr('id', function(d, i) {\n                return 'arc-path-' + i;\n            })\n            .style('fill', function(d) {\n                return COMMON.COLORSCALE(d.data[_dimension[0]]);\n            })\n            .each(function(d) {\n                this._current = d;\n            })\n            .on('mouseover', _handleMouseOverFn.call(chart, _localTooltip, svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, _localTooltip, svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, _localTooltip, svg))\n            .on('click', function(d, i) {\n                \n            });\n\n        pieArcGroup = svg.selectAll('g.arc')\n            .data(_pie(newFilteredData), _localKey);\n\n        pieArcGroup.select('path')\n            .transition().duration(1000)\n            .attrTween('d', function(d) {\n                var interpolate = d3.interpolate(this._current, d);\n                var _this = this;\n                return function(t) {\n                    _this._current = interpolate(t);\n                    return _arc(_this._current);\n                };\n            });\n\n        pieArcGroup = svg.selectAll('g.arc')\n            .data(_pie(filteredData), _localKey);\n\n        pieArcGroup.exit()\n            .transition()\n            .delay(1000)\n            .duration(0)\n            .remove();\n\n        if(_valueAsArc) {\n            pieLabel = pieArcGroup.append('text')\n                .attr('dy', function(d, i) {\n                    if(_valuePosition == 'inside') {\n                        return 10;\n                    } else {\n                        return -5;\n                    }\n                })\n            \n            pieLabel.append('textPath')\n                .attr('xlink:href', function(d, i) {\n                    return '#arc-path-' + i;\n                })\n                .attr('text-anchor', function() {\n                    return 'middle';\n                })\n                .transition()\n                .delay(_delayFn(200))\n                .on('start', function() {\n                    d3.select(this).attr('startOffset', function(d) {\n                        var length = pieArcPath.nodes()[d.index].getTotalLength();\n                        return 50 * (length - 2 * outerRadius)/length + '%';\n                    })\n                    .text(_labelFn())\n                    .filter(function(d, i) {\n                        /* length of arc = angle in radians * radius */\n                        var diff = d.endAngle - d.startAngle;\n                        return outerRadius * diff < this.getComputedTextLength();\n                    })\n                    .remove();\n                });\n        }\n    }\n\n    chart.config = function(value) {\n        if(!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function(value) {\n        if(!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function(value) {\n        if(!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        _pie.value(function(d) { return d[_measure[0]]; });\n        return chart;\n    }\n\n    chart.legend = function(value) {\n        if(!arguments.length) {\n            return _legend;\n        }\n        _legend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function(value) {\n        if(!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.valueAs = function(value) {\n        if(!arguments.length) {\n            return _valueAs;\n        }\n        _valueAs = value;\n        return chart;\n    }\n\n    chart.valueAsArc = function(value) {\n        if(!arguments.length) {\n            return _valueAsArc;\n        }\n        _valueAsArc = value;\n        return chart;\n    }\n\n    chart.valuePosition = function(value) {\n        if(!arguments.length) {\n            return _valuePosition;\n        }\n        _valuePosition = value;\n        return chart;\n    }\n\n    chart.sort = function(value) {\n        if(!arguments.length) {\n            return _sort;\n        }\n        _sort = value;\n        return chart;\n    }\n\n    chart.tooltip = function(value) {\n        if(!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = pie;\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/pie.js?");

/***/ }),

/***/ "./js/charts/pivottable.js":
/*!*********************************!*\
  !*** ./js/charts/pivottable.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction pivottable() {\n\n    var _NAME = 'pivottable';\n\n\n    var _isPivoted = [],\n        _config = [],\n        _dimension = [],\n        _displayNameForDimension = [],\n        _cellColorForDimension = [],\n        _fontStyleForDimension = [],\n        _fontWeightForDimension = [],\n        _fontSizeForDimension = [],\n        _textColorForDimension = [],\n        _textColorExpressionForDimension = [],\n        _textAlignmentForDimension = [],\n        _measure = [],\n        _displayNameForMeasure = [],\n        _cellColorForMeasure = [],\n        _cellColorExpressionForMeasure = [],\n        _fontStyleForMeasure = [],\n        _fontSizeForMeasure = [],\n        _numberFormatForMeasure = [],\n        _textColorForMeasure = [],\n        _textAlignmentForMeasure = [],\n        _textColorExpressionForMeasure = [],\n        _iconNameForMeasure = [],\n        _iconPositionForMeasure = [],\n        _iconExpressionForMeasure = [],\n        _iconFontWeight = [],\n        _iconColor = [],\n        _fontWeightForMeasure = [];\n\n    var _localData, filterData = [];\n\n\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.displayNameForDimension(config.displayNameForDimension);\n        this.cellColorForDimension(config.cellColorForDimension);\n        this.fontStyleForDimension(config.fontStyleForDimension);\n        this.fontWeightForDimension(config.fontWeightForDimension);\n        this.fontSizeForDimension(config.fontSizeForDimension);\n        this.textColorForDimension(config.textColorForDimension);\n        this.textColorExpressionForDimension(config.textColorExpressionForDimension);\n        this.textAlignmentForDimension(config.textAlignmentForDimension);\n        this.isPivoted(config.isPivoted);\n        this.displayNameForMeasure(config.displayNameForMeasure);\n        this.cellColorForMeasure(config.cellColorForMeasure);\n        this.cellColorExpressionForMeasure(config.cellColorExpressionForMeasure);\n        this.fontStyleForMeasure(config.fontStyleForMeasure);\n        this.fontSizeForMeasure(config.fontSizeForMeasure);\n        this.numberFormatForMeasure(config.numberFormatForMeasure);\n        this.textColorForMeasure(config.textColorForMeasure);\n        this.textAlignmentForMeasure(config.textAlignmentForMeasure);\n        this.textColorExpressionForMeasure(config.textColorExpressionForMeasure);\n        this.iconNameForMeasure(config.iconNameForMeasure);\n        this.iconPositionForMeasure(config.iconPositionForMeasure);\n        this.iconExpressionForMeasure(config.iconExpressionForMeasure);\n        this.fontWeightForMeasure(config.fontWeightForMeasure);\n\n\n    }\n\n    var _baseAccessor = function (value, measure) {\n        var me = this;\n\n        if (!arguments.length) {\n            /**\n             * Getter method call with no arguments\n             * E.g. <chart>.<accessor_function>() ==> [<item1>, <item2>]\n             */\n            return me;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            /**\n             * Setter method call with only value argument\n             * E.g. <chart>.<accessor_function>([<item1>, <item2>]) ==> <chart_function>\n             */\n            me.splice(0, me.length);\n            me.push.apply(me, value);\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            /**\n             * Getter method call with only measure argument\n             * E.g. <chart>.<accessor_function>(<measure>) ==> <item>\n             */\n            return me[index];\n        } else {\n            /**\n             * Setter method call with both value and measure arguments\n             * E.g. <chart>.<accessor_function>(<item>, <measure>) ==> <chart_function>\n             */\n            me[index] = value;\n        }\n\n        return chart;\n    }\n    var getIcon = function (index, endValue) {\n        var iconOutput = \"\";\n\n        var iconStyle = {\n            'font-weight': _iconFontWeight[index] || COMMON.DEFAULT_FONTWEIGHT,\n            'color': _iconColor[index] || COMMON.DEFAULT_COLOR,\n            'font-size': _fontSizeForMeasure[index] || COMMON.DEFAULT_FONTSIZE,\n            'text-align': getIconPosition(index)\n        };\n\n        if (_iconExpressionForMeasure[index].length) {\n            _iconNameForMeasure[index] = UTIL.expressionEvaluator(_iconExpressionForMeasure[index], endValue, 'icon');\n            iconStyle['color'] = UTIL.expressionEvaluator(_iconExpressionForMeasure[index], endValue, 'color');\n        }\n\n        iconStyle = JSON.stringify(iconStyle);\n        iconStyle = iconStyle.replace(/[\"{}]/g, '').replace(/,/g, ';');\n\n        iconOutput += \"<i  class=\\\"\" + _iconNameForMeasure[index] + \"\\\" style=\\\"\" + iconStyle + \"\\\" aria-hidden=\\\"true\\\"></i>\";\n\n\n\n        if (getIconName(index) !== \"\") {\n            return iconOutput;\n        }\n        return \"\";\n    }\n    var getPivotedDimension = function () {\n        var result = [];\n\n        _isPivoted.forEach(function (dp, i) {\n            if (dp) {\n                result.push(_dimension[i]);\n            }\n        });\n        return result;\n    }\n\n    var getUnPivotedDimension = function () {\n        var result = [];\n\n        _isPivoted.forEach(function (dp, i) {\n            if (!dp) {\n                result.push(_dimension[i]);\n            }\n        });\n        return result;\n    }\n\n    var getValueNumberFormat = function (index) {\n        var si = _numberFormatForMeasure[index],\n            nf = getNumberFormatter(si);\n\n        return nf;\n    }\n\n    var getIcon = function (index) {\n        if (getIconName(index) !== \"\") {\n            return '<span style=\"display:block; text-align:' + getIconPosition(index) + ';\"><i class=\"' + getIconName(index) + '\" aria-hidden=\"true\"></i></span>';\n        }\n\n        return \"\";\n    }\n    var getIconPosition = function (index) {\n        return _iconPosition[index];\n    }\n    var getIconName = function (index) {\n        return _iconName[index];\n    }\n    var getDisplayName = function (value, isDimension) {\n        if (isDimension) {\n            return _displayNameForDimension.filter(function (item) {\n                return item['dimension'] == value;\n            })[0]['displayName'];\n        }\n        return _displayNameForMeasure.filter(function (item) {\n            return item['measure'] == value;\n        })[0]['displayName'];\n    }\n\n    var getCellColor = function (value, isDimension) {\n        if (isDimension) {\n            _cellColorForDimension[_dimension.indexOf(value)]\n        }\n        return _cellColorForMeasure[_measure.indexOf(value)]\n    }\n\n    var getFontStyle = function (value, isDimension) {\n        if (isDimension) {\n            return _fontStyleForDimension[_dimension.indexOf(value)]\n        }\n        return _fontStyleForMeasure[_measure.indexOf(value)]\n    }\n\n    var getFontWeight = function (value, isDimension) {\n        if (isDimension) {\n            return _fontWeightForDimension[_dimension.indexOf(value)]\n        }\n        return _fontWeightForMeasure[_measure.indexOf(value)]\n    }\n\n    var getFontSize = function (value, isDimension) {\n        if (isDimension) {\n            return _fontSizeForDimension[_dimension.indexOf(value)]\n        }\n        return _fontSizeForMeasure[_measure.indexOf(value)]\n    }\n\n    var getTextColor = function (value, isDimension) {\n        if (isDimension) {\n            return _textColorForDimension[_dimension.indexOf(value)]\n        }\n        return _textColorForMeasure[_measure.indexOf(value)]\n    }\n\n    var getTextAlignment = function (value, isDimension) {\n        if (isDimension) {\n            _textAlignmentForDimension[_dimension.indexOf(value)]\n        }\n        _textAlignmentForMeasure[_measure.indexOf(value)]\n    }\n\n    var getValueNumberFormat = function (value) {\n        var si = _numberFormatForMeasure[_measure.indexOf(value)]\n        nf = UTIL.getNumberFormatter(si);\n\n        return nf;\n    }\n\n    var getUniqueData = function (data, pivoted_dimension) {\n        var result = [];\n\n        data.forEach(function (d) {\n            if (result.indexOf(d[pivoted_dimension]) == -1) {\n                result.push(d[pivoted_dimension]);\n            }\n        });\n\n        return result;\n    }\n\n    var getColspanValue = function (mapper, index) {\n        var arr = mapper.values().slice(index),\n            multiplier = 1;\n\n        arr.forEach(function (v) {\n            multiplier *= v.length;\n        });\n\n        return multiplier;\n    }\n\n    var getCloneFactor = function (mapper, index) {\n        var arr = mapper.values(),\n            multiplier = _dimension.length;\n\n        for (var i = 0; i < index; i++) {\n            multiplier *= arr[i].length;\n        }\n\n        return multiplier;\n    }\n    var applyFilter = function () {\n        return function () {\n            var d = _localData.filter(function (val) {\n                for (var index = 0; index < filterData.length; index++) {\n                    if (val[filterData[index].key] == filterData[index].value) {\n                        return val;\n                    }\n                }\n\n            });\n            d3.select('#donut')\n                .datum(d)\n                .call(chart);\n\n            _local_svg.html('')\n\n            chart(_local_svg)\n        }\n    }\n    var clearFilter = function () {\n        return function () {\n            d3.select('#donut')\n                .datum(_localData)\n                .call(chart);\n\n            _local_svg.html('')\n\n            chart(_local_svg)\n        }\n    }\n    chart.readerTableChart = function (str, ctr, _local_svg, key) {\n        var confirm = d3.select('.confirm')\n            .style('visibility', 'visible');\n        var searchObj = filterData.find(o => o[key] === str);\n        if (searchObj == undefined) {\n            var obj = Object();\n            obj.key = key;\n            obj.value = str;\n            filterData.push(obj);\n        }\n        $(ctr).toggleClass('selected')\n\n    }\n    function chart(selection) {\n        _local_svg = selection;\n\n        selection.each(function (data) {\n\n            var margin = {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 45\n            };\n\n            var div = d3.select(this);\n\n            var width = +div.attr('width');\n            var height = +div.attr('height');\n            var disv = d3.select(\"#pivottable\");\n\n            $('#pivottable').css('width', width)\n                .css('height', height).css('overflow-y', 'hidden').css('overflow-x', 'auto');\n\n            var nester = d3.nest(),\n                pivotedDimension = getPivotedDimension();\n\n            var unpivotedDimension = getUnPivotedDimension();\n\n            unpivotedDimension.forEach(function (dim) {\n                nester = nester.key(function (d) {\n                    return d[dim];\n                })\n            });\n\n            nester.rollup(function (values) {\n                var _sorter = function (x, y, i) {\n                    if (typeof (pivotedDimension[i]) === 'undefined') {\n                        return 0;\n                    }\n\n                    return x[pivotedDimension[i]] < y[pivotedDimension[i]]\n                        ? -1 : x[pivotedDimension[i]] > y[pivotedDimension[i]] ? 1 : _sorter(x, y, i + 1);\n                }\n\n                var sortedValues = values.sort(function (x, y) {\n                    return _sorter(x, y, 0);\n                });\n\n                sortedValues = values;\n\n                var leafNode = function (data, measure, value) {\n                    var leafDim = \"\";\n\n                    pivotedDimension.forEach(function (pd) {\n                        leafDim += \"_\" + data[pd];\n                    });\n\n                    return {\n                        name: measure + leafDim,\n                        value: value\n                    };\n                }\n\n                var result = [];\n\n                _measure.forEach(function (m) {\n                    var temp = sortedValues.map(function (d) {\n                        return leafNode(d, m, d[m]);\n                    });\n\n                    result = Array.prototype.concat(result, temp);\n                });\n\n                return result;\n            });\n\n            var nestedData = nester.entries(data),\n                pivotedData = [];\n\n            var getGeneratedPivotData = function (nestedData, depth, obj) {\n                nestedData.forEach(function (kv) {\n                    var a = kv.key;\n                    obj = (depth !== 0) ? (jQuery.extend(true, {}, obj) || {}) : {};\n                    obj[unpivotedDimension[depth]] = a;\n\n                    if (kv.value) {\n                        kv.value.forEach(function (d) {\n                            obj[d.name] = d.value;\n                        });\n                        pivotedData.push(obj);\n                    } else {\n                        getGeneratedPivotData(kv.values, depth + 1, obj);\n                    }\n                });\n            }\n            getGeneratedPivotData(nestedData, 0);\n\n            var mapper = d3.map();\n\n            pivotedDimension.forEach(function (pd) {\n                mapper.set(pd, getUniqueData(data, pd));\n            });\n\n            var table = $('<table id=\"viz_pivot-table\" class=\"display nowrap\" style=\"width:100%\"></table>').addClass('table table-condensed table-hover');\n\n            var thead = \"<thead><tr>\",\n                tbody = \"<tbody>\";\n\n            _dimension.forEach(function (item, index) {\n                var title = _displayNameForDimension,\n                    style = {\n                        'text-align': _textAlignmentForDimension[index],\n                        'background-color': '#f1f1f1',\n                        'font-weight': 'bold'\n                    };\n\n                style = JSON.stringify(style);\n                style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                if (title != \"\") {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + title + \"</th>\";\n                } else {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + item + \"</th>\";\n                }\n            });\n\n            _measure.forEach(function (item, index) {\n                var title = _displayNameForMeasure[index],\n                    style = {\n                        'text-align': _textAlignmentForMeasure[index],\n                        'background-color': '#f1f1f1',\n                        'font-weight': 'bold'\n                    };\n\n                style = JSON.stringify(style);\n                style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                if (title != \"\") {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + title + \"</th>\";\n                } else {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + item + \"</th>\";\n                }\n            });\n\n            thead += \"</tr></thead>\";\n\n\n            var createHeaders = function (iterator, key, depth) {\n                var row = \"<tr>\",\n                    content = \"\",\n                    output = \"\";\n\n                iterator.forEach(function (item) {\n                    var style = {\n                        'text-align': getTextAlignment(key, true),\n                        'background-color': getCellColor(key, true),\n                        'font-style': getFontStyle(key, true),\n                        'font-weight': getFontWeight(key, true),\n                        'font-size': getFontSize(key, true),\n                        'color': getTextColor(key, true)\n                    };\n\n                    style = JSON.stringify(style);\n                    style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                    content += \"<th style=\\\"\" + style + \"\\\" colspan=\\\"\" + getColspanValue(mapper, depth + 1) + \"\\\">\" + item + \"</th>\";\n                });\n\n                for (var i = 0; i < getCloneFactor(mapper, depth); i++) {\n                    output += content;\n                }\n\n                if (depth == (pivotedDimension.length - 1)) {\n                    var temp = \"\";\n\n                    unpivotedDimension.forEach(function (upd) {\n                        var style = {\n                            'text-align': getTextAlignment(upd, true),\n                            'background-color': '#f7f7f7',\n                            'font-weight': 'bold'\n                        };\n\n                        style = JSON.stringify(style);\n                        style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                        temp += \"<th style=\\\"\" + style + \"\\\">\" + upd + \"</th>\";\n                    });\n\n                    output = temp + output;\n                }\n\n                row += output + \"</tr>\";\n                return row;\n            }\n\n            mapper.entries().forEach(function (entry, index) {\n                thead += createHeaders(entry.value, entry.key, index);\n            });\n\n            thead += \"</thead>\";\n\n            var temp = mapper.values();\n\n            var getGeneratedRecord = function (content, parent, depth, datum, i) {\n                if (typeof (temp[depth]) == 'object') {\n                    temp[depth].forEach(function (item) {\n                        parent.push(item);\n                        content = getGeneratedRecord(content, parent, depth + 1, datum, i);\n                    });\n                } else {\n                    var style = {\n                        'text-align': getTextAlignment(parent[0]),\n                        'background-color': getCellColor(parent[0]),\n                        'font-style': getFontStyle(parent[0]),\n                        'font-weight': getFontWeight(parent[0]),\n                        'font-size': getFontSize(parent[0]),\n                        'color': getTextColor(parent[0])\n                    };\n                    style['color'] = UTIL.expressionEvaluator(_textColorExpressionForMeasure[i], datum[parent.join('_')], 'color');\n                    style['background-color'] = UTIL.expressionEvaluator(_cellColorExpressionForMeasure[i], datum[parent.join('_')], 'color');\n                    style = JSON.stringify(style);\n                    style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                    content += \"<td onClick=\\\"chart.readerTableChart('\" + datum[_dimension[i]] + \"',this,_local_svg,'\" + datum[parent.join('_')] + \"')\\\"  style=\\\"\" + style + \"\\\">\" + ((datum[parent.join('_')] !== undefined) ? getValueNumberFormat(parent[0])(datum[parent.join('_')]) : \"-\") + \"</td>\";\n                }\n\n                parent.pop();\n                return content;\n            }\n\n            var createEntries = function (datum) {\n                var content = \"\";\n\n                unpivotedDimension.forEach(function (upd) {\n                    var style = {\n                        'text-align': getTextAlignment(upd, true),\n                        'background-color': getCellColor(upd, true),\n                        'font-style': getFontStyle(upd, true),\n                        'font-weight': getFontWeight(upd, true),\n                        'font-size': getFontSize(upd, true),\n                        'color': getTextColor(upd, true)\n                    };\n\n                    style = JSON.stringify(style);\n                    style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                    content += \"<td style=\\\"\" + style + \"\\\">\" + datum[upd] + \"</td>\";\n                });\n\n                _measure.forEach(function (m, i) {\n                    content = getGeneratedRecord(content, [m], 0, datum, i);\n                });\n\n                return content;\n            }\n\n            pivotedData.forEach(function (pd) {\n                tbody += \"<tr>\" + createEntries(pd) + \"</tr>\";\n            });\n\n            tbody += \"</tbody></table>\";\n\n            table.append((thead + tbody));\n\n            $('#pivottable').append(table);\n\n            $('#pivottable').find('#viz_pivot-table').dataTable({\n                scrollY: height - 50,\n                scrollX: true,\n                scrollCollapse: true,\n                ordering: true,\n                info: true,\n                searching: false,\n                'sDom': 't'\n            });\n            d3.select('.btn-primary')\n                .on('click', applyFilter());\n\n            d3.select('.btn-default')\n                .on('click', clearFilter());\n\n        }\n\n        );\n    }\n    /**\n     * Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the arc\n     * @param {function} chart Pie chart function\n     * @return {string} String encoded HTML data\n     */\n    chart._legendInteraction = function (event, data) {\n        var arcGroup = d3.selectAll('g.arc')\n            .filter(function (d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            });\n\n        if (event === 'mouseover') {\n            arcGroup.select('path')\n                .style('fill', COMMON.HIGHLIGHTER);\n        } else if (event === 'mousemove') {\n            // do something\n        } else if (event === 'mouseout') {\n            arcGroup.select('path')\n                .style('fill', function (d, i) {\n                    return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                });\n        } else if (event === 'click') {\n\n        }\n    }\n\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.isPivoted = function (value) {\n        if (!arguments.length) {\n            return _isPivoted;\n        }\n        _isPivoted = value;\n        return chart;\n    }\n\n\n    chart.displayNameForDimension = function (value, measure) {\n        return _baseAccessor.call(_displayNameForDimension, value, measure);\n    }\n\n    chart.cellColorForDimension = function (value, measure) {\n        return _baseAccessor.call(_cellColorForDimension, value, measure);;\n    }\n\n    chart.fontStyleForDimension = function (value, measure) {\n        return _baseAccessor.call(_fontStyleForDimension, value, measure);\n    }\n\n    chart.fontWeightForDimension = function (value, measure) {\n        return _baseAccessor.call(_fontWeightForDimension, value, measure);\n    }\n\n    chart.fontSizeForDimension = function (value, measure) {\n        return _baseAccessor.call(_fontSizeForDimension, value, measure);\n    }\n\n    chart.textColorForDimension = function (value, measure) {\n        return _baseAccessor.call(_textColorForDimension, value, measure);\n    }\n\n    chart.textColorExpressionForDimension = function (value, measure) {\n        if (!arguments.length) {\n            return _textColorExpressionForDimension;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            _textColorExpressionForDimension = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return _textColorExpressionForDimension[index];\n        } else {\n            _textColorExpressionForDimension[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n    }\n\n    chart.textAlignmentForDimension = function (value, measure) {\n        return _baseAccessor.call(_textAlignmentForDimension, value, measure);\n    }\n\n    chart.displayNameForMeasure = function (value, measure) {\n        return _baseAccessor.call(_displayNameForMeasure, value, measure);\n    }\n\n    chart.cellColorForMeasure = function (value, measure) {\n        return _baseAccessor.call(_cellColorForMeasure, value, measure);\n    }\n\n    chart.cellColorExpressionForMeasure = function (value, measure) {\n        if (!arguments.length) {\n            return _cellColorExpressionForMeasure;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            _cellColorExpressionForMeasure = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return _cellColorExpressionForMeasure[index];\n        } else {\n            _cellColorExpressionForMeasure[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n    }\n\n    chart.fontStyleForMeasure = function (value, measure) {\n        return _baseAccessor.call(_fontStyleForMeasure, value, measure);\n    }\n\n    chart.fontSizeForMeasure = function (value, measure) {\n        return _baseAccessor.call(_fontSizeForMeasure, value, measure);\n    }\n\n    chart.numberFormatForMeasure = function (value, measure) {\n        return _baseAccessor.call(_numberFormatForMeasure, value, measure);\n    }\n\n    chart.textColorForMeasure = function (value, measure) {\n        return _baseAccessor.call(_textColorForMeasure, value, measure);\n    }\n\n    chart.textAlignmentForMeasure = function (value, measure) {\n        return _baseAccessor.call(_textAlignmentForMeasure, value, measure);\n    }\n\n    chart.textColorExpressionForMeasure = function (value, measure) {\n        if (!arguments.length) {\n            return _textColorExpressionForMeasure;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            _textColorExpressionForMeasure = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return _textColorExpressionForMeasure[index];\n        } else {\n            _textColorExpressionForMeasure[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n    }\n\n    chart.iconNameForMeasure = function (value, measure) {\n        return _baseAccessor.call(_iconNameForMeasure, value, measure);\n    }\n\n    chart.iconPositionForMeasure = function (value, measure) {\n        return _baseAccessor.call(_iconPositionForMeasure, value, measure);\n    }\n\n    chart.iconExpressionForMeasure = function (value, measure) {\n        if (!arguments.length) {\n            /**\n             * Getter method call with no arguments\n             * E.g. <chart>.kpiIconExpression() ==> [<item1>, <item2>]\n             */\n            return _iconExpressionForMeasure;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            /**\n             * Setter method call with only value argument\n             * E.g. <chart>.kpiIconExpression([<item1>, <item2>]) ==> <chart_function>\n             */\n            _iconExpressionForMeasure = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['icon', 'color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            /**\n             * Getter method call with only measure argument\n             * E.g. <chart>.kpiIconExpression(<measure>) ==> <item>\n             */\n            return _iconExpressionForMeasure[index];\n        } else {\n            /**\n             * Setter method call with both value and measure arguments\n             * E.g. <chart>.kpiIconExpression(<item>, <measure>) ==> <chart_function>\n             */\n            _iconExpressionForMeasure[index] = UTIL.getExpressionConfig(value, ['icon', 'color']);\n        }\n\n        return chart;\n    }\n\n    chart.fontWeightForMeasure = function (value, measure) {\n        return _baseAccessor.call(_fontWeightForMeasure, value, measure);\n    }\n\n    chart.iconFontWeight = function (value, measure) {\n        return _baseAccessor.call(_iconFontWeight, value, measure);\n    }\n\n\n    chart.iconColor = function (value, measure) {\n        return _baseAccessor.call(_iconColor, value, measure);\n    }\n\n    return chart;\n}\n\nmodule.exports = pivottable;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/pivottable.js?");

/***/ }),

/***/ "./js/charts/scatter.js":
/*!******************************!*\
  !*** ./js/charts/scatter.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction scatter() {\n\n    var _NAME = 'scatterChart';\n\n    var _config,\n        _dimension,\n        _measure,\n        _showLegend,\n        _legendPosition,\n        _sort,\n        _tooltip,\n        _showXaxis,\n        _showYaxis,\n        _showXaxisLabel,\n        _showYaxisLabel,\n        _xAxisColor,\n        _yAxisColor,\n        _showGrid,\n        _stacked,\n        _displayName,\n        _legendData,\n\n        _showValues,\n        _displayNameForMeasure,\n        _fontStyle,\n        _fontWeight,\n        _numberFormat,\n        _textColor,\n        _displayColor,\n        _borderColor,\n        _fontSize;\n\n\n    var _local_svg, _Local_data;\n\n    var parentWidth, parentHeight, plotWidth, plotHeight;\n\n    var legendSpace = 20, axisLabelSpace = 20, offsetX = 16, offsetY = 3, div;\n    var threshold = [];\n    var filter = false, filterData = [];\n\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.showLegend(config.showLegend);\n        this.legendPosition(config.legendPosition);\n\n        this.showXaxis(config.showXaxis);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showYaxisLabel(config.showYaxisLabel);\n        this.xAxisColor(config.xAxisColor);\n        this.yAxisColor(config.yAxisColor);\n        this.displayName(config.displayName);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showValues(config.showValues);\n        this.displayNameForMeasure(config.displayNameForMeasure);\n        this.fontStyle(config.fontStyle);\n        this.fontWeight(config.fontWeight);\n        this.numberFormat(config.numberFormat);\n        this.textColor(config.textColor);\n        this.displayColor(config.displayColor);\n        this.borderColor(config.borderColor);\n        this.fontSize(config.fontSize);\n\n        this.legendData(config.displayColor, config.measure);\n    }\n\n    var _buildTooltipData = function (datum, chart) {\n        var output = \"\";\n        output += \"<table>\";\n        _measure.forEach(element => {\n            output += \"<tr><th>\" + element + \": </th>\";\n            output += \"<th>\" + datum[ element] + \"</th></tr>\";\n        });\n        output += \"</table>\";\n\n        return output;\n    }\n\n    var onLassoStart = function (lasso, chart) {\n        return function () {\n            if (filter) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', true)\n                    .classed('selected', false);\n            }\n        }\n    }\n\n    var onLassoDraw = function (lasso, chart) {\n        return function () {\n            filter = true;\n            lasso.items().selectAll('rect')\n                .classed('selected', false);\n\n            lasso.possibleItems().selectAll('rect')\n                .classed('not_possible', false)\n                .classed('possible', true);\n\n            lasso.notPossibleItems().selectAll('rect')\n                .classed('not_possible', true)\n                .classed('possible', false);\n        }\n    }\n\n    var onLassoEnd = function (lasso, chart) {\n        return function () {\n            var data = lasso.selectedItems().data();\n            if (!filter) {\n                return;\n            }\n            if (data.length > 0) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', false)\n                    .classed('possible', false);\n            }\n\n            lasso.selectedItems().selectAll('rect')\n                .classed('selected', true)\n\n            lasso.notSelectedItems().selectAll('rect');\n\n            var confirm = d3.select('.confirm')\n                .style('visibility', 'visible');\n\n            var _filter = [];\n            data.forEach(function (d) {\n                var obj = new Object();\n                obj[_dimension[0]] = d[_dimension[0]];\n                for (var index = 0; index < _measure.length; index++) {\n                    obj[_measure[index]] = d[_measure[index]];\n                }\n\n                _filter.push(obj)\n            });\n            if (_filter.length > 0) {\n                filterData = _filter;\n            }\n        }\n    }\n\n    var applyFilter = function (chart) {\n        return function () {\n            if (filterData.length > 0) {\n                chart(filterData);\n            }\n        }\n    }\n\n    var _handleMouseOverFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this)\n                .style('cursor', 'pointer')\n                .style('fill-opacity', 1);\n\n            var border = d3.select(this).attr('fill');\n            if (tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container, border);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            if (tooltip) {\n                var border =  d3.select(this).attr('fill');\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me, border), container, border);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'default')\n                .style('fill-opacity', .5)\n\n            var arcGroup = container.selectAll('g.arc')\n                .filter(function (d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcGroup.select('path')\n                .style('fill', function (d1, i) {\n                    return COMMON.COLORSCALE(d1.data[_dimension[0]]);\n                });\n\n            var arcMaskGroup = container.selectAll('g.arc-mask')\n                .filter(function (d1) {\n                    return d1.data[_dimension[0]] === d.data[_dimension[0]];\n                });\n\n            arcMaskGroup.select('path')\n                .style('visibility', 'hidden');\n\n            if (tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    function chart(selection) {\n        _local_svg = selection;\n        selection.each(function (data) {\n            chart._Local_data = _originalData = data;\n            var margin = {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 45\n            };\n\n            var legendSpace = 20,\n                axisLabelSpace = 20,\n                offsetX = 16,\n                offsetY = 3;\n\n            var div = d3.select(this).node().parentNode;\n\n            var svg = d3.select(this),\n                width = div.clientWidth,\n                height = div.clientHeight;\n\n            parentWidth = width - 2 * COMMON.PADDING - margin.left;\n            parentHeight = (height - 2 * COMMON.PADDING - axisLabelSpace * 2);\n            plotWidth = parentWidth;\n            plotHeight = parentHeight;\n            const color = COMMON.COLORSCALE;\n\n            var str = UTIL.createAlert($(div).attr('id'), _measure);\n            $(div).append(str);\n\n            var container = svg.append('g')\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            _local_total = d3.sum(data.map(function (d) { return d[_measure[0]]; }));\n\n            var plot = container.append('g')\n                .attr('class', 'scatter-plot')\n                .classed('plot', true)\n                .attr('transform', function () {\n                    if (_legendPosition == 'top') {\n                        return 'translate(' + margin.left + ', ' + legendSpace * 2 + ')';\n                    } else if (_legendPosition == 'bottom') {\n                        return 'translate(' + margin.left + ', 0)';\n                    } else if (_legendPosition == 'left') {\n                        return 'translate(' + (legendSpace + margin.left + axisLabelSpace) + ', 0)';\n                    } else if (_legendPosition == 'right') {\n                        return 'translate(' + margin.left + ', 0)';\n                    }\n                });\n\n            var keys = UTIL.getMeasureList(data[0], _dimension);\n\n            var maxGDP = d3.max(data, function (d) {\n                return d3.max(keys, function (key) {\n                    return parseInt(d[key]);\n                });\n            })\n            var minGDP = d3.min(data, function (d) {\n                return d3.min(keys, function (key) {\n                    return parseInt(d[key]);\n                });\n            })\n\n            var rScale = d3.scaleLinear()\n                .domain([minGDP, maxGDP])\n                .range([5, 25]);\n\n            var x = d3.scaleLinear()\n                .rangeRound([0, plotWidth])\n\n            var y = d3.scaleLinear()\n                .rangeRound([plotHeight - 40, 0]);\n\n\n            x.domain([0, d3.max(data, function (d) {\n                return parseInt(d[_dimension[0]]);\n            })]).nice();\n\n            y.domain([0, d3.max(data, function (d) {\n                return parseInt(d[_measure[3]]);\n            })]).nice();\n\n            if (_tooltip) {\n                tooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            plot.append(\"g\")\n                .attr(\"class\", \"x_axis\")\n                .attr(\"transform\", \"translate(0,\" + parseInt(plotHeight - 40) + \")\")\n                .call(d3.axisBottom(x))\n                .append(\"text\")\n                .attr(\"x\", plotWidth / 2)\n                .attr(\"y\", 2 * axisLabelSpace)\n                .attr(\"dy\", \"0.32em\")\n                .attr(\"fill\", \"#000\")\n                .attr(\"font-weight\", \"bold\")\n                .style('text-anchor', 'middle')\n                .style('visibility', UTIL.getVisibility(_showXaxisLabel))\n                .text(function () {\n                    return _displayName;\n                });\n\n            plot.append(\"g\")\n                .attr(\"class\", \"y_axis\")\n                .call(d3.axisLeft(y).ticks(null, \"s\"))\n                .append(\"text\")\n                .attr(\"x\", plotHeight / 2)\n                .attr(\"y\", 2 * axisLabelSpace)\n                .attr(\"transform\", function (d) { return \"rotate(\" + 90 + \")\"; })\n                .attr(\"dy\", \"0.32em\")\n                .style('visibility', UTIL.getVisibility(_showYaxisLabel))\n                .attr(\"font-weight\", \"bold\")\n                .style('text-anchor', 'middle')\n                .text(function () {\n                    return _displayNameForMeasure.map(function (p) {\n                        return p;\n                    }).join(', ');\n                });\n\n            plot.selectAll(\"circle\")\n                .data(data)\n                .enter()\n                .append(\"circle\")\n                .attr(\"cx\", function (d) {\n                    return x(d[_dimension[0]]);\n                })\n                .attr(\"cy\", function (d) {\n                    return y(d[_measure[3]]);\n                })\n                .attr(\"r\", function (d) {\n                    return rScale(parseInt(d[_measure[0]]));\n                })\n                .attr(\"fill\", function (d) {\n                    return color(d[_measure[2]]);\n                })\n\n                .style('fill-opacity', .5)\n                .on('mouseover', _handleMouseOverFn.call(chart, tooltip, svg))\n                .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, svg))\n                .on('mouseout', _handleMouseOutFn.call(chart, tooltip, svg));\n\n            var legendWidth = 0,\n                legendHeight = 0,\n                legendBreakCount;\n\n            plotWidth = parentWidth;\n            plotHeight = parentHeight;\n\n            if (_showLegend) {\n                var clusteredverticalbarLegend = LEGEND.bind(chart);\n\n                var result = clusteredverticalbarLegend(_legendData, container, {\n                    width: parentWidth,\n                    height: parentHeight,\n                    legendBreakCount: legendBreakCount\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n                legendBreakCount = result.legendBreakCount;\n\n                switch (_legendPosition) {\n                    case 'top':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace;\n                        break;\n                    case 'bottom':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace * 2;\n                        break;\n                    case 'right':\n                    case 'left':\n                        plotWidth = parentWidth - legendWidth;\n                        break;\n                }\n\n                if ((_legendPosition == 'top') || (_legendPosition == 'bottom')) {\n                    plotWidth = parentWidth;\n                    plotHeight = parentHeight - 3 * axisLabelSpace;\n                    legendSpace = 20;\n                } else if ((_legendPosition == 'left') || (_legendPosition == 'right')) {\n                    var legend = _local_svg.selectAll('.item');\n                    legendSpace = legend.node().parentNode.getBBox().width;\n                    plotWidth = (parentWidth - legendSpace) - margin.left + axisLabelSpace;\n                    plotHeight = parentHeight;\n\n                    legend.attr('transform', function (d, i) {\n                        if (_legendPosition == 'left') {\n                            return 'translate(0, ' + i * 20 + ')';\n\n                        }\n                        else if (_legendPosition == 'right') {\n                            return 'translate(' + (parentWidth - legendSpace + axisLabelSpace) + ', ' + i * 20 + ')';\n                        }\n                    });\n                }\n            }\n            else {\n                legendSpace = 0;\n                plotWidth = parentWidth;\n                plotHeight = parentHeight;\n            }\n\n            UTIL.setAxisColor(svg, _yAxisColor, _xAxisColor, _showYaxis, _showXaxis, _showYaxis, _showXaxis);\n        });\n\n    }\n\n    chart._legendInteraction = function (event, data) {\n        var arcGroup = d3.selectAll('g.arc')\n            .filter(function (d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            });\n\n        if (event === 'mouseover') {\n            arcGroup.select('path')\n                .style('fill', COMMON.HIGHLIGHTER);\n        } else if (event === 'mousemove') {\n            // do something\n        } else if (event === 'mouseout') {\n            arcGroup.select('path')\n                .style('fill', function (d, i) {\n                    return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                });\n        } else if (event === 'click') {\n\n        }\n    }\n\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.update = function (data) {\n        chart._Local_data = data,\n            svg = _local_svg;\n        filter = false;\n        filterData = [];\n        var key = function (d) {\n            return d.data[_dimension[0]];\n        };\n\n        var prevData = svg.selectAll('g.cluster')\n            .data().map(function (d) { return d.data });\n\n        if (prevData.length == 0) {\n            prevData = data;\n        }\n\n        //  var oldFilteredData = _mergeForTransition(data, prevData),\n        //      newFilteredData = _mergeForTransition(prevData, data);\n\n        var cluster = d3.selectAll('g.cluster')\n            .data(data);\n\n        cluster.enter().append('g')\n            .attr('class', 'cluster')\n            .attr('transform', function (d) {\n                return 'translate(' + xScaleDim(d[dimension[0]]) + ', 0)';\n            });\n\n        cluster.exit().remove();\n\n        cluster = d3.selectAll('g.cluster');\n        var labelStack = [];\n        var clusteredverticalbar = cluster.selectAll('g.clusteredverticalbar')\n            .data(function (d) {\n                return _measure.filter(function (m) {\n                    return labelStack.indexOf(m) == -1;\n                }).map(function (m) {\n                    var obj = {};\n                    obj[_dimension[0]] = d[_dimension[0]];\n                    obj[m] = d[m];\n                    obj['dimension'] = _dimension[0];\n                    obj['measure'] = m;\n                    return obj;\n                });\n            })\n            .enter().append('g')\n            .attr('class', 'clusteredverticalbar');\n\n\n        var rect = clusteredverticalbar.append('rect')\n            .attr(\"x\", function (d) {\n                return x1(d.measure);\n            })\n            .attr(\"y\", function (d) { return y(d[d.measure]); })\n            .attr(\"width\", x1.bandwidth())\n            .attr(\"height\", function (d) {\n                return plotHeight - y(d[d.measure]);\n            })\n            .style('fill', function (d, i) {\n                return UTIL.getDisplayColor(i, _displayColor);\n            })\n            .style('stroke', function (d, i) {\n                return UTIL.getBorderColor(i, _borderColor);\n            })\n            .style('stroke-width', 2)\n            .on('mouseover', _handleMouseOverFn.call(chart, tooltip, svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, tooltip, svg))\n\n        var text = clusteredverticalbar.append('text')\n            .text(function (d, i) {\n                return UTIL.getFormattedValue(d[d.measure], UTIL.getValueNumberFormat(i, _numberFormat));\n            })\n            .attr(\"y\", function (d, i) {\n                return y(d[d.measure]) - _fontSize[i];\n            })\n            .attr(\"x\", function (d) {\n                return x1(d.measure);\n            })\n            .attr('dy', function (d, i) {\n                return offsetX / 10;\n            })\n            .attr('dx', function (d, i) {\n                return x1.bandwidth() / 2;\n            })\n            .style('text-anchor', 'middle')\n            .attr('visibility', function (d, i) {\n                return UTIL.getVisibility(_showValues[i]);\n            })\n            .style('font-style', function (d, i) {\n                return _fontStyle[i];\n            })\n            .style('font-weight', function (d, i) {\n                return _fontWeight[i];\n            })\n            .style('font-size', function (d, i) {\n                return _fontSize[i]+ 'px';\n            })\n            .style('fill', function (d, i) {\n                return _textColor[i];\n            });\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.showLegend = function (value) {\n        if (!arguments.length) {\n            return _showLegend;\n        }\n        _showLegend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function (value) {\n        if (!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.sort = function (value) {\n        if (!arguments.length) {\n            return _sort;\n        }\n        _sort = value;\n        return chart;\n    }\n\n    chart.tooltip = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    chart.showXaxis = function (value) {\n        if (!arguments.length) {\n            return _showXaxis;\n        }\n        _showXaxis = value;\n        return chart;\n    }\n\n    chart.showYaxis = function (value) {\n        if (!arguments.length) {\n            return _showYaxis;\n        }\n        _showYaxis = value;\n        return chart;\n    }\n\n    chart.showXaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showXaxisLabel;\n        }\n        _showXaxisLabel = value;\n        return chart;\n    }\n\n    chart.showYaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showYaxisLabel;\n        }\n        _showYaxisLabel = value;\n        return chart;\n    }\n\n    chart.xAxisColor = function (value) {\n        if (!arguments.length) {\n            return _xAxisColor;\n        }\n        _xAxisColor = value;\n        return chart;\n    }\n\n    chart.yAxisColor = function (value) {\n        if (!arguments.length) {\n            return _yAxisColor;\n        }\n        _yAxisColor = value;\n        return chart;\n    }\n\n    chart.showGrid = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _showGrid = value;\n        return chart;\n    }\n\n    chart.stacked = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _stacked = value;\n        return chart;\n    }\n\n    chart.displayName = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _displayName = value;\n        return chart;\n    }\n\n    chart.legendData = function (measureConfig, measureName) {\n        _legendData = {\n            measureConfig: measureConfig,\n            measureName: measureName\n        }\n        return _legendData;\n    }\n\n    chart.showValues = function (value) {\n        if (!arguments.length) {\n            return _showValues;\n        }\n        _showValues = value;\n        return chart;\n    }\n\n    chart.displayNameForMeasure = function (value) {\n        if (!arguments.length) {\n            return _displayNameForMeasure;\n        }\n        _displayNameForMeasure = value;\n        return chart;\n    }\n\n    chart.fontStyle = function (value) {\n        if (!arguments.length) {\n            return _fontStyle;\n        }\n        _fontStyle = value;\n        return chart;\n    }\n\n    chart.fontWeight = function (value) {\n        if (!arguments.length) {\n            return _fontWeight;\n        }\n        _fontWeight = value;\n        return chart;\n    }\n\n    chart.numberFormat = function (value) {\n        if (!arguments.length) {\n            return _numberFormat;\n        }\n        _numberFormat = value;\n        return chart;\n    }\n\n    chart.textColor = function (value) {\n        if (!arguments.length) {\n            return _textColor;\n        }\n        _textColor = value;\n        return chart;\n    }\n\n    chart.displayColor = function (value) {\n        if (!arguments.length) {\n            return _displayColor;\n        }\n        _displayColor = value;\n        return chart;\n    }\n\n    chart.borderColor = function (value) {\n        if (!arguments.length) {\n            return _borderColor;\n        }\n        _borderColor = value;\n        return chart;\n    }\n\n    chart.fontSize = function (value) {\n        if (!arguments.length) {\n            return _fontSize;\n        }\n        _fontSize = value;\n        return chart;\n    }\n    return chart;\n}\n\nmodule.exports = scatter;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/scatter.js?");

/***/ }),

/***/ "./js/charts/stackedhorizontalbar.js":
/*!*******************************************!*\
  !*** ./js/charts/stackedhorizontalbar.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction stackedhorizontalbar() {\n\n    var _NAME = 'stackedhorizontalbar';\n\n    var _config,\n        _dimension,\n        _measure,\n        _showLegend,\n        _legendPosition,\n        _sort,\n        _tooltip,\n        _showXaxis,\n        _showYaxis,\n        _showXaxisLabel,\n        _showYaxisLabel,\n        _xAxisColor,\n        _yAxisColor,\n        _showGrid,\n        _stacked,\n        _displayName,\n        _legendData,\n\n        _showValues = [],\n        _displayNameForMeasure = [],\n        _fontStyle = [],\n        _fontWeight = [],\n        _numberFormat = [],\n        _textColor = [],\n        _displayColor = [],\n        _borderColor = [],\n        _fontSize = [];\n\n    var _local_svg, _Local_data, _originalData, _localLabelStack = [], legendBreakCount = 1;\n    var legendSpace = 20, axisLabelSpace = 20, offsetX = 16, offsetY = 3, div;\n    var parentWidth, parentHeight, plotWidth, plotHeight, container;\n\n    var x, y;\n\n    var margin = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 45\n    };\n\n    var filter = false, filterData = [];\n    var threshold = [];\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.showLegend(config.showLegend);\n        this.legendPosition(config.legendPosition);\n\n        this.showXaxis(config.showXaxis);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showYaxisLabel(config.showYaxisLabel);\n        this.xAxisColor(config.xAxisColor);\n        this.yAxisColor(config.yAxisColor);\n        this.displayName(config.displayName);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showValues(config.showValues);\n        this.displayNameForMeasure(config.displayNameForMeasure);\n        this.fontStyle(config.fontStyle);\n        this.fontWeight(config.fontWeight);\n        this.numberFormat(config.numberFormat);\n        this.textColor(config.textColor);\n        this.displayColor(config.displayColor);\n        this.borderColor(config.borderColor);\n        this.fontSize(config.fontSize);\n\n        this.legendData(config.displayColor, config.measure);\n    }\n\n    var _buildTooltipData = function (datum, chart) {\n        var output = \"\";\n\n        output += \"<table><tr>\"\n            + \"<th>\" + chart.dimension() + \": </th>\"\n            + \"<td>\" + datum.data[_dimension[0]] + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + datum.key + \": </th>\"\n            + \"<td>\" + datum.data[datum.key] + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var onLassoStart = function (lasso, chart) {\n        return function () {\n            if (filter) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', true)\n                    .classed('selected', false);\n            }\n        }\n    }\n\n    var onLassoDraw = function (lasso, chart) {\n        return function () {\n            filter = true;\n            lasso.items().selectAll('rect')\n                .classed('selected', false);\n\n            lasso.possibleItems().selectAll('rect')\n                .classed('not_possible', false)\n                .classed('possible', true);\n\n            lasso.notPossibleItems().selectAll('rect')\n                .classed('not_possible', true)\n                .classed('possible', false);\n        }\n    }\n\n    var onLassoEnd = function (lasso, chart) {\n        return function () {\n            var data = lasso.selectedItems().data();\n            if (!filter) {\n                return;\n            }\n            if (data.length > 0) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', false)\n                    .classed('possible', false);\n            }\n\n            lasso.selectedItems().selectAll('rect')\n                .classed('selected', true)\n\n            lasso.notSelectedItems().selectAll('rect');\n\n            var confirm = d3.select('.confirm')\n                .style('visibility', 'visible');\n\n            var _filter = [];\n            var keys = UTIL.getMeasureList(data[0].data, _dimension);\n            data.forEach(function (d) {\n                var obj = new Object();\n                var temp = d.data[_dimension[0]];\n                var searchObj = _filter.find(o => o[_dimension[0]] === temp);\n                if (searchObj == undefined) {\n                    obj[_dimension[0]] = d.data[_dimension[0]];\n                    for (var index = 0; index < keys.length; index++) {\n                        obj[keys[index]] = d.data[keys[index]];\n                    }\n                    _filter.push(obj)\n                }\n            });\n            if (_filter.length > 0) {\n                filterData = _filter;\n            }\n        }\n    }\n\n    var applyFilter = function (chart) {\n        return function () {\n            if (filterData.length > 0) {\n                chart.update(filterData);\n            }\n        }\n    }\n    var clearFilter = function () {\n        return function () {\n            chart.update(_originalData);\n        }\n    }\n    var _handleMouseOverFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'pointer')\n                .style('cursor', 'pointer')\n                .style('fill', COMMON.HIGHLIGHTER);\n            var border = UTIL.getDisplayColor(_measure.indexOf(d.key), _displayColor)\n            if (tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container, border);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            if (tooltip) {\n                var border = UTIL.getDisplayColor(_measure.indexOf(d.key), _displayColor)\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me, border), container, border);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'default')\n                .style('fill', function (d1, i) {\n                    return UTIL.getDisplayColor(_measure.indexOf(d1.key), _displayColor);\n                })\n                .style('stroke', function (d1, i) {\n                    return UTIL.getBorderColor(_measure.indexOf(d1.key), _borderColor);\n                });\n\n            if (tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    function chart(selection) {\n        _local_svg = selection;\n\n        selection.each(function (data) {\n            _originalData = data;\n            div = d3.select(this).node().parentNode;\n\n            var width = div.clientWidth,\n                height = div.clientHeight;\n\n            parentWidth = width - 2 * COMMON.PADDING - margin.left;\n            parentHeight = (height - 2 * COMMON.PADDING - axisLabelSpace * 2);\n\n            container = _local_svg.append('g')\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            _local_svg.attr('width', width)\n                .attr('height', height)\n\n            d3.select(div).append('div')\n                .attr('class', 'sort_selection');\n\n            d3.select(div).append('div')\n                .attr('class', 'arrow-down');\n\n            var str = UTIL.createAlert($(div).attr('id'), _measure);\n            $(div).append(str);\n\n            $(document).on('click', '_local_svg', function (e) {\n                if ($(\"#myonoffswitch\").prop('checked') == false) {\n                    var element = e.target\n                    if (element.tagName == \"_local_svg\") {\n                        $('#Modal_' + $(div).attr('id') + ' .measure').val('')\n                        $('#Modal_' + $(div).attr('id') + ' .threshold').val('')\n                        $('#Modal_' + $(div).attr('id') + ' .measure').attr('disabled', false)\n                        $('#Modal_' + $(div).attr('id')).modal('toggle');\n                    }\n                }\n            })\n\n            $(document).on('click', '#Modal_' + $(div).attr('id') + ' .ThresholdSubmit', function (e) {\n                var newValue = $('#Modal_' + $(div).attr('id') + ' .threshold').val();\n                var obj = new Object()\n                obj.measure = $('#Modal_' + $(div).attr('id') + ' .measure').val()\n                obj.threshold = newValue;\n                threshold.push(obj);\n                $('#Modal_' + $(div).attr('id')).modal('toggle');\n            })\n\n            container = _local_svg.append('g')\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            var legendWidth = 0,\n                legendHeight = 0;\n\n            plotWidth = parentWidth;\n            plotHeight = parentHeight;\n\n            if (_showLegend) {\n                var stackedhorizontalbarLegend = LEGEND.bind(chart);\n\n                var result = stackedhorizontalbarLegend(_legendData, container, {\n                    width: parentWidth,\n                    height: parentHeight,\n                    legendBreakCount: legendBreakCount\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n                legendBreakCount = result.legendBreakCount;\n\n                switch (_legendPosition) {\n                    case 'top':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace;\n                        break;\n                    case 'bottom':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace * 2;\n                        break;\n                    case 'right':\n                    case 'left':\n                        plotWidth = parentWidth - legendWidth;\n                        break;\n                }\n\n                if ((_legendPosition == 'top') || (_legendPosition == 'bottom')) {\n                    plotWidth = parentWidth;\n                    plotHeight = parentHeight - 3 * axisLabelSpace;\n                    legendSpace = 20;\n                } else if ((_legendPosition == 'left') || (_legendPosition == 'right')) {\n                    var legend = _local_svg.selectAll('.item');\n                    legendSpace = legend.node().parentNode.getBBox().width;\n                    plotWidth = (parentWidth - legendSpace) - margin.left + axisLabelSpace;\n                    plotHeight = parentHeight;\n\n                    legend.attr('transform', function (d, i) {\n                        if (_legendPosition == 'left') {\n                            return 'translate(0, ' + i * 20 + ')';\n\n                        }\n                        else if (_legendPosition == 'right') {\n                            return 'translate(' + (parentWidth - legendSpace + axisLabelSpace) + ', ' + i * 20 + ')';\n                        }\n                    });\n                }\n            }\n            else {\n                legendSpace = 0;\n                plotWidth = parentWidth;\n                plotHeight = parentHeight;\n            }\n\n            if (_tooltip) {\n                tooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            drawPlot.call(this, data);\n        });\n    }\n\n    var drawViz = function (element) {\n        var me = this;\n\n        element.append('rect')\n            .style('fill', function (d, i) {\n                return UTIL.getDisplayColor(_measure.indexOf(d.key), _displayColor);\n            })\n            .style('stroke', function (d, i) {\n                return UTIL.getBorderColor(_measure.indexOf(d.key), _borderColor);\n            })\n            .attr(\"y\", function (d) {\n                return x(d.data[_dimension[0]]);\n            })\n            .attr(\"x\", function (d) {\n                return (d[0] < d[1]) ? (y(d[0]) + 1) : (y(d[1]) + 1);\n            })\n            .attr(\"width\", function (d) {\n                return Math.abs(y(d[1]) - y(d[0]));\n            })\n            .attr(\"height\", x.bandwidth())\n            .style('stroke-width', 2)\n            .on('mouseover', _handleMouseOverFn.call(chart, tooltip, _local_svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, _local_svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, tooltip, _local_svg))\n            .on('click', function (d) {\n                if ($(\"#myonoffswitch\").prop('checked') == false) {\n                    $('#Modal_' + $(div).attr('id') + ' .measure').val(d.key);\n                    $('#Modal_' + $(div).attr('id') + ' .threshold').val('');\n                    $('#Modal_' + $(div).attr('id') + ' .measure').attr('disabled', true);;\n                    $('#Modal_' + $(div).attr('id')).modal('toggle');\n                }\n                else {\n                    var confirm = d3.select('.confirm')\n                        .style('visibility', 'visible');\n                    var _filter = _Local_data.filter(function (d1) {\n                        return d.data[_dimension[0]] === d1[_dimension[0]]\n                    })\n                    var rect = d3.select(this);\n                    if (rect.classed('selected')) {\n                        rect.classed('selected', false);\n                        filterData.map(function (val, i) {\n                            if (val[_dimension[0]] == d[_dimension[0]]) {\n                                filterData.splice(i, 1)\n                            }\n                        })\n                    } else {\n                        rect.classed('selected', true);\n                        var isExist = filterData.filter(function (val) {\n                            if (val[_dimension[0]] == d[_dimension[0]]) {\n                                return val\n                            }\n                        })\n                        if (isExist.length == 0) {\n                            filterData.push(_filter[0]);\n                        }\n                    }\n                }\n            })\n\n        element.append('text')\n            .text(function (d, i) {\n                return UTIL.getFormattedValue(d.data[d.key], UTIL.getValueNumberFormat(_measure.indexOf(d.key), _numberFormat));\n            })\n            .attr('x', function (d, i) {\n                return y(d[1]) - 20;\n            })\n            .attr('y', function (d, i) {\n                return x(d.data[_dimension[0]]) + x.bandwidth() / 2;\n            })\n            .attr('dy', function (d, i) {\n                return offsetX / 2;\n            })\n            .style('text-anchor', 'middle')\n            .attr('visibility', function (d, i) {\n                return UTIL.getVisibility(_showValues[_measure.indexOf(d.key)]);\n            })\n            .attr('visibility', function (d, i) {\n                if (this.getAttribute('visibility') == 'hidden') return 'hidden';\n                var rect = d3.select(this.previousElementSibling).node(),\n                    rectWidth = rect.getAttribute('width'),\n                    rectHeight = rect.getAttribute('height');\n\n                if (rectHeight <= parseFloat(d3.select(this).style('font-size').replace('px', ''))) {\n                    return 'hidden';\n                }\n\n                if ((this.getComputedTextLength() + (offsetX / 4)) > parseFloat(rectWidth)) {\n                    return 'hidden';\n                }\n\n                return 'visible';\n            })\n            .style('font-style', function (d, i) {\n                return _fontStyle[_measure.indexOf(d.key)];\n            })\n            .style('font-weight', function (d, i) {\n                return _fontWeight[_measure.indexOf(d.key)];\n            })\n            .style('font-size', function (d, i) {\n                return _fontSize[_measure.indexOf(d.key)] + 'px';\n            })\n            .style('fill', function (d, i) {\n                return _textColor[_measure.indexOf(d.key)];\n            });\n    }\n    var drawPlot = function (data) {\n        var me = this;\n        _Local_data = data;\n        var plot = container.append('g')\n            .attr('class', 'stackedhorizontalbar-plot')\n            .classed('plot', true)\n            .attr('transform', function () {\n                if (_legendPosition == 'top') {\n                    return 'translate(' + margin.left + ', ' + parseInt(legendSpace * 2 + (20 * parseInt(legendBreakCount))) + ')';\n                } else if (_legendPosition == 'bottom') {\n                    return 'translate(' + margin.left + ', 0)';\n                } else if (_legendPosition == 'left') {\n                    return 'translate(' + (legendSpace + margin.left + axisLabelSpace) + ', 0)';\n                } else if (_legendPosition == 'right') {\n                    return 'translate(' + margin.left + ', 0)';\n                }\n            });\n        if (!_showLegend) {\n            _local_svg.select('.plot')\n                .attr('transform', function () {\n                    return 'translate(' + margin.left + ', ' + 0 + ')';\n                });\n        }\n\n        x = d3.scaleBand()\n            .rangeRound([0, plotHeight])\n            .padding([0.2])\n\n        y = d3.scaleLinear()\n            .rangeRound([0, plotWidth]);\n\n        var keys = UTIL.getMeasureList(data[0], _dimension);\n\n        for (i = 0; i < data.length; i++) {\n            var t = 0;\n            for (j = 0; j < keys.length; j++) {\n                t = parseInt(t) + parseInt(data[i][keys[j]]);\n            }\n            data[i].total = t;\n        }\n\n        x.domain(data.map(function (d) { return d[_dimension[0]]; }));\n        y.domain([0, d3.max(data, function (d) {\n            return d.total;\n        })]).nice();\n\n        data.map(function (val) {\n            delete val['total'];\n        })\n\n        var labelStack = [];\n        var stack = plot.append('g')\n            .attr('class', 'stack')\n            .selectAll('g')\n            .data(d3.stack().keys(keys)(data))\n            .enter().append('g')\n            .attr('class', 'stackedhorizontalbar-group');\n\n        var stackedhorizontalbar = stack.selectAll('g')\n            .data(function (d, i) {\n                d.forEach(function (datum) {\n                    datum.key = d.key;\n                })\n                return d;\n            })\n            .enter().append('g')\n            .attr('class', 'stackedhorizontalbar');\n\n        drawViz(stackedhorizontalbar);\n\n        plot.append(\"g\")\n            .attr(\"class\", \"x_axis\")\n            .attr(\"transform\", \"translate(0,\" + plotHeight + \")\")\n            .call(d3.axisBottom(y))\n            .append(\"text\")\n            .attr(\"x\", plotWidth / 2)\n            .attr(\"y\", 2 * axisLabelSpace)\n            .attr(\"dy\", \"0.32em\")\n            .attr(\"fill\", \"#000\")\n            .attr(\"font-weight\", \"bold\")\n            .style('text-anchor', 'middle')\n            .style('visibility', UTIL.getVisibility(_showXaxisLabel))\n            .text(function () {\n                return _displayNameForMeasure.map(function (p) { return p; }).join(', ');\n            });\n\n        plot.append(\"g\")\n            .attr(\"class\", \"y_axis\")\n            .call(d3.axisLeft(x).ticks(null, \"s\"))\n            .append(\"text\")\n            .attr(\"x\", plotHeight / 2)\n            .attr(\"y\", 2 * axisLabelSpace)\n            .attr(\"transform\", function (d) { return \"rotate(\" + 90 + \")\"; })\n            .attr(\"dy\", \"0.32em\")\n            .style('visibility', UTIL.getVisibility(_showYaxisLabel))\n            .attr(\"font-weight\", \"bold\")\n            .style('text-anchor', 'middle')\n            .text(function () {\n                return _displayName;\n            });\n\n        UTIL.setAxisColor(_local_svg, _yAxisColor, _xAxisColor, _showYaxis, _showXaxis, _showYaxis, _showXaxis);\n        _local_svg.select('g.sort').remove();\n        UTIL.sortingView(container, parentHeight, parentWidth + margin.left, legendBreakCount, axisLabelSpace, offsetX);\n\n        _local_svg.select('g.sort').selectAll('text')\n            .on('click', function () {\n                var order = d3.select(this).attr('class')\n                switch (order) {\n                    case 'ascending':\n                        UTIL.toggleSortSelection(me, 'ascending', drawPlot, _local_svg, keys, _Local_data);\n                        break;\n                    case 'descending':\n                        UTIL.toggleSortSelection(me, 'descending', drawPlot, _local_svg, keys, _Local_data);\n                        break;\n                    case 'reset': {\n                        _local_svg.select(me.parentElement).select('.plot').remove();\n                        drawPlot.call(me, _Local_data);\n                        break;\n                    }\n                }\n            });\n\n        d3.select(div).select('.btn-primary')\n            .on('click', applyFilter(chart));\n\n        d3.select(div).select('.btn-default')\n            .on('click', clearFilter());\n\n        var lasso = d3.lasso()\n            .hoverSelect(true)\n            .closePathSelect(true)\n            .closePathDistance(100)\n            .items(stackedhorizontalbar)\n            .targetArea(_local_svg);\n\n        lasso.on('start', onLassoStart(lasso, chart))\n            .on('draw', onLassoDraw(lasso, chart))\n            .on('end', onLassoEnd(lasso, chart));\n\n        _local_svg.call(lasso);\n    }\n\n    chart._legendInteraction = function (event, data) {\n        switch (event) {\n            case 'mouseover':\n                _legendMouseOver(data);\n                break;\n            case 'mousemove':\n                _legendMouseMove(data);\n                break;\n            case 'mouseout':\n                _legendMouseOut(data);\n                break;\n            case 'click':\n                _legendClick(data);\n                break;\n        }\n    }\n    var _legendMouseOver = function (data) {\n\n        d3.selectAll('g.stackedhorizontalbar')\n            .filter(function (d) {\n                return d.measure === data;\n            })\n            .select('rect')\n            .style('fill', COMMON.HIGHLIGHTER);\n    }\n\n    var _legendMouseMove = function (data) {\n\n    }\n\n    var _legendMouseOut = function (data) {\n        d3.selectAll('g.stackedhorizontalbar')\n            .filter(function (d) {\n                return d.measure === data;\n            })\n            .select('rect')\n            .style('fill', function (d, i) {\n                return UTIL.getDisplayColor(_measure.indexOf(d.measure), _displayColor);\n            });\n    }\n\n    var _legendClick = function (data) {\n        var _filter = UTIL.getFilterData(_localLabelStack, data, _originalData)\n        drawPlot.call(this, _filter);\n    }\n\n    chart.update = function (data) {\n\n        _Local_data = data;\n        filterData = [];\n\n        x = d3.scaleBand()\n            .rangeRound([0, plotHeight])\n            .padding([0.2])\n\n        y = d3.scaleLinear()\n            .rangeRound([0, plotWidth]);\n\n        var keys = UTIL.getMeasureList(data[0], _dimension);\n        for (i = 0; i < data.length; i++) {\n            var t = 0;\n            for (j = 0; j < keys.length; j++) {\n                t = parseInt(t) + parseInt(data[i][keys[j]]);\n            }\n            data[i].total = t;\n        }\n\n        x.domain(data.map(function (d) { return d[_dimension[0]]; }));\n        y.domain([0, d3.max(data, function (d) {\n            return d.total;\n        })]).nice();\n\n        data.map(function (val) {\n            delete val['total'];\n        })\n\n        var labelStack = [];\n        var plot = _local_svg.select('.plot')\n\n        var stack = plot.select('g.stack').selectAll('g.stackedhorizontalbar-group')\n            .data(d3.stack().keys(keys)(data))\n\n        stack.enter().append('g')\n            .attr('class', 'stackedhorizontalbar-group');\n\n        stack.exit().remove();\n\n        var stackedhorizontalbarGroup = plot.select('g.stack').selectAll('g.stackedhorizontalbar-group');\n\n        var stackedhorizontalbar = stackedhorizontalbarGroup.selectAll('g.stackedhorizontalbar')\n            .data(function (d, i) {\n                d.forEach(function (datum) {\n                    datum.key = d.key;\n                })\n                return d;\n            });\n\n\n        stackedhorizontalbar.select('rect')\n            .attr(\"y\", function (d) {\n                return x(d.data[_dimension[0]]);\n            })\n            .attr(\"x\", function (d) {\n                return (d[0] < d[1]) ? (y(d[0]) + 1) : (y(d[1]) + 1);\n            })\n            .attr(\"width\", function (d) {\n                return Math.abs(y(d[1]) - y(d[0]));\n            })\n            .classed('selected', false)\n            .classed('possible', false)\n            .attr(\"height\", x.bandwidth())\n            .style('stroke-width', 2)\n\n        stackedhorizontalbar.select('text')\n            .text(function (d, i) {\n                return UTIL.getFormattedValue(d.data[d.key], UTIL.getValueNumberFormat(_measure.indexOf(d.key), _numberFormat));\n            })\n            .attr('x', function (d, i) {\n                return y(d[1]) - 20;\n            })\n            .attr('y', function (d, i) {\n                return x(d.data[_dimension[0]]) + x.bandwidth() / 2;\n            })\n            .attr('dy', function (d, i) {\n                return offsetX / 2;\n            })\n            .style('text-anchor', 'middle')\n            .attr('visibility', function (d, i) {\n                return UTIL.getVisibility(_showValues[_measure.indexOf(d.key)]);\n            })\n            .attr('visibility', function (d, i) {\n                if (this.getAttribute('visibility') == 'hidden') return 'hidden';\n                var rect = d3.select(this.previousElementSibling).node(),\n                    rectWidth = rect.getAttribute('width'),\n                    rectHeight = rect.getAttribute('height');\n\n                if (rectHeight <= parseFloat(d3.select(this).style('font-size').replace('px', ''))) {\n                    return 'hidden';\n                }\n                if ((this.getComputedTextLength() + (offsetX / 4)) > parseFloat(rectWidth)) {\n                    return 'hidden';\n                }\n                return 'visible';\n            })\n\n        var newBars = stackedhorizontalbar.enter().append('g')\n            .attr('class', 'stackedhorizontalbar');\n\n        drawViz(newBars);\n\n        plot.select('.x_axis')\n            .transition()\n            .duration(1000)\n            .call(d3.axisBottom(y));\n\n        plot.select('.y_axis')\n            .transition()\n            .duration(1000)\n            .call(d3.axisLeft(x).ticks(null, \"s\"));\n\n        stackedhorizontalbar.exit()\n            .transition()\n            .duration(1000)\n            .remove();\n\n        UTIL.setAxisColor(_local_svg, _yAxisColor, _xAxisColor, _showYaxis, _showXaxis);\n        UTIL.displayThreshold(threshold, data, keys);\n    }\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.showLegend = function (value) {\n        if (!arguments.length) {\n            return _showLegend;\n        }\n        _showLegend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function (value) {\n        if (!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.sort = function (value) {\n        if (!arguments.length) {\n            return _sort;\n        }\n        _sort = value;\n        return chart;\n    }\n\n    chart.tooltip = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    chart.showXaxis = function (value) {\n        if (!arguments.length) {\n            return _showXaxis;\n        }\n        _showXaxis = value;\n        return chart;\n    }\n\n    chart.showYaxis = function (value) {\n        if (!arguments.length) {\n            return _showYaxis;\n        }\n        _showYaxis = value;\n        return chart;\n    }\n\n    chart.showXaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showXaxisLabel;\n        }\n        _showXaxisLabel = value;\n        return chart;\n    }\n\n    chart.showYaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showYaxisLabel;\n        }\n        _showYaxisLabel = value;\n        return chart;\n    }\n\n    chart.xAxisColor = function (value) {\n        if (!arguments.length) {\n            return _xAxisColor;\n        }\n        _xAxisColor = value;\n        return chart;\n    }\n\n    chart.yAxisColor = function (value) {\n        if (!arguments.length) {\n            return _yAxisColor;\n        }\n        _yAxisColor = value;\n        return chart;\n    }\n\n    chart.showGrid = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _showGrid = value;\n        return chart;\n    }\n\n    chart.stacked = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _stacked = value;\n        return chart;\n    }\n\n    chart.displayName = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _displayName = value;\n        return chart;\n    }\n\n    chart.legendData = function (measureConfig, measureName) {\n        _legendData = {\n            measureConfig: measureConfig,\n            measureName: measureName\n        }\n        return _legendData;\n    }\n\n    chart.showValues = function (value, measure) {\n        _baseAccessor.call(_showValues, value, measure)\n    }\n\n    chart.displayNameForMeasure = function (value, measure) {\n        _baseAccessor.call(_displayNameForMeasure, value, measure)\n    }\n\n    chart.fontStyle = function (value, measure) {\n        _baseAccessor.call(_fontStyle, value, measure)\n    }\n\n    chart.fontWeight = function (value, measure) {\n        _baseAccessor.call(_fontWeight, value, measure)\n    }\n\n    chart.numberFormat = function (value, measure) {\n        _baseAccessor.call(_numberFormat, value, measure)\n    }\n\n    chart.textColor = function (value, measure) {\n        _baseAccessor.call(_textColor, value, measure)\n    }\n\n    chart.displayColor = function (value, measure) {\n        _baseAccessor.call(_displayColor, value, measure)\n    }\n\n    chart.borderColor = function (value, measure) {\n        _baseAccessor.call(_borderColor, value, measure)\n    }\n\n    chart.fontSize = function (value, measure) {\n        _baseAccessor.call(_fontSize, value, measure)\n    }\n\n    var _baseAccessor = function (value, measure) {\n        var me = this;\n\n        if (!arguments.length) {\n            return me;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            me.splice(0, me.length);\n            me.push.apply(me, value);\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return me[index];\n        } else {\n            me[index] = value;\n        }\n        return chart;\n    }\n    return chart;\n}\n\nmodule.exports = stackedhorizontalbar;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/stackedhorizontalbar.js?");

/***/ }),

/***/ "./js/charts/stackedverticalbar.js":
/*!*****************************************!*\
  !*** ./js/charts/stackedverticalbar.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction stackedverticalbar() {\n\n    var _NAME = 'stackedverticalbar';\n\n    var _config,\n        _dimension,\n        _measure,\n        _showLegend,\n        _legendPosition,\n        _sort,\n        _tooltip,\n        _showXaxis,\n        _showYaxis,\n        _showXaxisLabel,\n        _showYaxisLabel,\n        _xAxisColor,\n        _yAxisColor,\n        _showGrid,\n        _stacked,\n        _displayName,\n        _legendData,\n        _showValues = [],\n        _displayNameForMeasure = [],\n        _fontStyle = [],\n        _fontWeight = [],\n        _numberFormat = [],\n        _textColor = [],\n        _displayColor = [],\n        _borderColor = [],\n        _fontSize = [];\n\n    var _local_svg,\n        _Local_data;\n\n    var x, y;\n    var margin = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 45\n    };\n    var _local_svg, _Local_data, _originalData, _localLabelStack = [], legendBreakCount = 1;\n    var legendSpace = 20, axisLabelSpace = 20, offsetX = 16, offsetY = 3, div;\n    var parentWidth, parentHeight, plotWidth, plotHeight, container;\n\n    var filter = false, filterData = [];\n    var threshold = [];\n\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.showLegend(config.showLegend);\n        this.legendPosition(config.legendPosition);\n\n        this.showXaxis(config.showXaxis);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showYaxisLabel(config.showYaxisLabel);\n        this.xAxisColor(config.xAxisColor);\n        this.yAxisColor(config.yAxisColor);\n        this.displayName(config.displayName);\n        this.showYaxis(config.showYaxis);\n        this.showXaxisLabel(config.showXaxisLabel);\n\n        this.showValues(config.showValues);\n        this.displayNameForMeasure(config.displayNameForMeasure);\n        this.fontStyle(config.fontStyle);\n        this.fontWeight(config.fontWeight);\n        this.numberFormat(config.numberFormat);\n        this.textColor(config.textColor);\n        this.displayColor(config.displayColor);\n        this.borderColor(config.borderColor);\n        this.fontSize(config.fontSize);\n\n        this.legendData(config.displayColor, config.measure);\n    }\n\n    var _buildTooltipData = function (datum, chart) {\n        var output = \"\";\n        output += \"<table><tr>\"\n            + \"<th>\" + chart.dimension() + \": </th>\"\n            + \"<td>\" + datum.data[chart.dimension()] + \"</td>\"\n            + \"</tr><tr>\"\n            + \"<th>\" + datum.key + \": </th>\"\n            + \"<td>\" + datum.data[datum.key] + \"</td>\"\n            + \"</tr></table>\";\n\n        return output;\n    }\n\n    var onLassoStart = function (lasso, chart) {\n        return function () {\n            if (filter) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', true)\n                    .classed('selected', false);\n            }\n        }\n    }\n\n    var onLassoDraw = function (lasso, chart) {\n        return function () {\n            filter = true;\n            lasso.items().selectAll('rect')\n                .classed('selected', false);\n\n            lasso.possibleItems().selectAll('rect').each(function (d, i) {\n                var item = d3.select(this).node().className.baseVal.split(' ')[0];\n                d3.selectAll('rect.' + item)\n                    .classed('not_possible', false)\n                    .classed('possible', true);\n\n            });\n            lasso.possibleItems().selectAll('rect')\n                .classed('not_possible', false)\n                .classed('possible', true);\n\n            lasso.notPossibleItems().selectAll('rect')\n                .classed('not_possible', true)\n                .classed('possible', false);\n        }\n    }\n\n    var onLassoEnd = function (lasso, chart) {\n        return function () {\n            var data = lasso.selectedItems().data();\n            if (!filter) {\n                return;\n            }\n            if (data.length > 0) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', false)\n                    .classed('possible', false);\n            }\n\n            lasso.selectedItems().selectAll('rect')\n                .classed('selected', true)\n\n            lasso.notSelectedItems().selectAll('rect');\n\n            var confirm = d3.select('.confirm')\n                .style('visibility', 'visible');\n\n            var _filter = [];\n            var keys = UTIL.getMeasureList(data[0].data, _dimension);\n            data.forEach(function (d) {\n                var obj = new Object();\n                var temp = d.data[_dimension[0]];\n                var searchObj = _filter.find(o => o[_dimension[0]] === temp);\n                if (searchObj == undefined) {\n                    obj[_dimension[0]] = d.data[_dimension[0]];\n                    for (var index = 0; index < keys.length; index++) {\n                        obj[keys[index]] = d.data[keys[index]];\n                    }\n                    _filter.push(obj)\n                }\n            });\n            if (_filter.length > 0) {\n                filterData = _filter;\n            }\n        }\n    }\n\n    var applyFilter = function (chart) {\n        return function () {\n            if (filterData.length > 0) {\n                chart.update(filterData);\n            }\n        }\n    }\n\n    var clearFilter = function () {\n        return function () {\n            chart.update(_originalData);\n        }\n    }\n\n    var _handleMouseOverFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'pointer')\n                .style('cursor', 'pointer')\n                .style('fill', COMMON.HIGHLIGHTER);\n            var border = UTIL.getDisplayColor(_measure.indexOf(d.key), _displayColor)\n            if (tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container, border);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            if (tooltip) {\n                var border = UTIL.getDisplayColor(_measure.indexOf(d.key), _displayColor)\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me, border), container, border);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'default')\n                .style('fill', function (d1, i) {\n                    return UTIL.getDisplayColor(_measure.indexOf(d1.key), _displayColor);\n                })\n                .style('stroke', function (d1, i) {\n                    return UTIL.getBorderColor(_measure.indexOf(d1.key), _borderColor);\n                });\n\n            if (tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    function chart(selection) {\n        _local_svg = selection;\n\n        selection.each(function (data) {\n            _originalData = data;\n            div = d3.select(this).node().parentNode;\n\n            _local_svg = d3.select(this);\n            var width = div.clientWidth,\n                height = div.clientHeight;\n\n            parentWidth = width - 2 * COMMON.PADDING - margin.left;\n            parentHeight = (height - 2 * COMMON.PADDING - axisLabelSpace * 2);\n\n            container = _local_svg.append('g')\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            _local_svg.attr('width', width)\n                .attr('height', height)\n\n            d3.select(div).append('div')\n                .attr('class', 'sort_selection');\n\n            d3.select(div).append('div')\n                .attr('class', 'arrow-down');\n\n            var str = UTIL.createAlert($(div).attr('id'), _measure);\n            $(div).append(str);\n\n            $(document).on('click', '_local_svg', function (e) {\n                if ($(\"#myonoffswitch\").prop('checked') == false) {\n                    var element = e.target\n                    if (element.tagName == \"_local_svg\") {\n                        $('#Modal_' + $(div).attr('id') + ' .measure').val('')\n                        $('#Modal_' + $(div).attr('id') + ' .threshold').val('')\n                        $('#Modal_' + $(div).attr('id') + ' .measure').attr('disabled', false)\n                        $('#Modal_' + $(div).attr('id')).modal('toggle');\n                    }\n                }\n            })\n\n            $(document).on('click', '#Modal_' + $(div).attr('id') + ' .ThresholdSubmit', function (e) {\n                var newValue = $('#Modal_' + $(div).attr('id') + ' .threshold').val();\n                var obj = new Object()\n                obj.measure = $('#Modal_' + $(div).attr('id') + ' .measure').val()\n                obj.threshold = newValue;\n                threshold.push(obj);\n                $('#Modal_' + $(div).attr('id')).modal('toggle');\n            })\n            container = _local_svg.append('g')\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            var legendWidth = 0,\n                legendHeight = 0;\n\n            plotWidth = parentWidth;\n            plotHeight = parentHeight;\n\n            if (_showLegend) {\n                var stackedverticalbarLegend = LEGEND.bind(chart);\n\n                var result = stackedverticalbarLegend(_legendData, container, {\n                    width: parentWidth,\n                    height: parentHeight,\n                    legendBreakCount: legendBreakCount\n                });\n\n                legendWidth = result.legendWidth;\n                legendHeight = result.legendHeight;\n                legendBreakCount = result.legendBreakCount;\n\n                switch (_legendPosition) {\n                    case 'top':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace;\n                        break;\n                    case 'bottom':\n                        plotHeight = parentHeight - legendHeight - axisLabelSpace * 2;\n                        break;\n                    case 'right':\n                    case 'left':\n                        plotWidth = parentWidth - legendWidth;\n                        break;\n                }\n\n                if ((_legendPosition == 'top') || (_legendPosition == 'bottom')) {\n                    plotWidth = parentWidth;\n                    plotHeight = parentHeight - 3 * axisLabelSpace;\n                    legendSpace = 20;\n                } else if ((_legendPosition == 'left') || (_legendPosition == 'right')) {\n                    var legend = _local_svg.selectAll('.item');\n                    legendSpace = legend.node().parentNode.getBBox().width;\n                    plotWidth = (parentWidth - legendSpace) - margin.left + axisLabelSpace;\n                    plotHeight = parentHeight;\n\n                    legend.attr('transform', function (d, i) {\n                        if (_legendPosition == 'left') {\n                            return 'translate(0, ' + i * 20 + ')';\n\n                        }\n                        else if (_legendPosition == 'right') {\n                            return 'translate(' + (parentWidth - legendSpace + axisLabelSpace) + ', ' + i * 20 + ')';\n                        }\n                    });\n                }\n            }\n            else {\n                legendSpace = 0;\n                plotWidth = parentWidth;\n                plotHeight = parentHeight;\n            }\n\n            if (_tooltip) {\n                tooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            drawPlot.call(this, data);\n        });\n    }\n\n    var drawViz = function (element) {\n        var me = this;\n\n        element.append('rect')\n            .style('fill', function (d, i) {\n                return UTIL.getDisplayColor(_measure.indexOf(d.key), _displayColor);;\n            })\n            .style('stroke', function (d, i) {\n                return UTIL.getBorderColor(_measure.indexOf(d.key), _borderColor);\n            })\n            .attr(\"x\", function (d) {\n                return x(d.data[_dimension[0]]);\n            })\n            .attr('class', function (d, i) {\n                return d.data[_dimension[0]];\n            })\n            .attr(\"y\", function (d) { return y(d[1]); })\n            .attr(\"height\", function (d) { return y(d[0]) - y(d[1]); })\n            .attr(\"width\", x.bandwidth())\n            .style('stroke-width', 2)\n            .on('mouseover', _handleMouseOverFn.call(chart, tooltip, _local_svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, _local_svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, tooltip, _local_svg))\n            .on('click', function (d) {\n                if ($(\"#myonoffswitch\").prop('checked') == false) {\n                    $('#Modal_' + $(div).attr('id') + ' .measure').val(d.key);\n                    $('#Modal_' + $(div).attr('id') + ' .threshold').val('');\n                    $('#Modal_' + $(div).attr('id') + ' .measure').attr('disabled', true);;\n                    $('#Modal_' + $(div).attr('id')).modal('toggle');\n                }\n                else {\n                    var confirm = d3.select('.confirm')\n                        .style('visibility', 'visible');\n                    var _filter = _Local_data.filter(function (d1) {\n                        return d.data[_dimension[0]] === d1[_dimension[0]]\n                    })\n                    var rect = d3.select(this);\n                    if (rect.classed('selected')) {\n                        rect.classed('selected', false);\n                        filterData.map(function (val, i) {\n                            if (val[_dimension[0]] == d[_dimension[0]]) {\n                                filterData.splice(i, 1)\n                            }\n                        })\n                    } else {\n                        rect.classed('selected', true);\n                        var isExist = filterData.filter(function (val) {\n                            if (val[_dimension[0]] == d[_dimension[0]]) {\n                                return val\n                            }\n                        })\n                        if (isExist.length == 0) {\n                            filterData.push(_filter[0]);\n                        }\n                    }\n                }\n            })\n\n        element.append('text')\n            .text(function (d, i) {\n                return UTIL.getFormattedValue(d.data[d.key], UTIL.getValueNumberFormat(_measure.indexOf(d.key), _numberFormat));\n            })\n            .attr('x', function (d, i) {\n                return x(d.data[_dimension[0]]) + x.bandwidth() / 2;\n            })\n            .attr('y', function (d, i) {\n                return y(d[1]) + 5;\n            })\n            .attr('dy', function (d, i) {\n                return offsetX / 2;\n            })\n            .style('text-anchor', 'middle')\n            .attr('visibility', function (d, i) {\n                return UTIL.getVisibility(_showValues[_measure.indexOf(d.key)]);\n            })\n            .attr('visibility', function (d, i) {\n                if (this.getAttribute('visibility') == 'hidden') return 'hidden';\n                var rect = d3.select(this.previousElementSibling).node(),\n                    rectWidth = rect.getAttribute('width'),\n                    rectHeight = rect.getAttribute('height');\n\n                if (rectHeight <= ((offsetX / 2) + parseFloat(d3.select(this).style('font-size').replace('px', '')))) {\n                    return 'hidden';\n                }\n\n                if (this.getComputedTextLength() > parseFloat(rectWidth)) {\n                    return 'hidden';\n                }\n\n                return 'visible';\n            })\n            .style('font-style', function (d, i) {\n                return _fontStyle[_measure.indexOf(d.key)][\"fontStyle\"];\n            })\n            .style('font-weight', function (d, i) {\n                return _fontWeight[_measure.indexOf(d.key)][\"fontWeight\"];\n            })\n            .style('font-size', function (d, i) {\n                return _fontSize[_measure.indexOf(d.key)]['fontSize'] + 'px';\n            })\n            .style('fill', function (d, i) {\n                return _textColor[_measure.indexOf(d.key)][\"textColor\"];\n            });\n    }\n    var drawPlot = function (data) {\n        var me = this;\n        _Local_data = data;\n        var plot = container.append('g')\n            .attr('class', 'stackedverticalbar-plot')\n            .classed('plot', true)\n            .attr('transform', function () {\n                if (_legendPosition == 'top') {\n                    return 'translate(' + margin.left + ', ' + parseInt(legendSpace * 2 + (20 * parseInt(legendBreakCount))) + ')';\n                } else if (_legendPosition == 'bottom') {\n                    return 'translate(' + margin.left + ', 0)';\n                } else if (_legendPosition == 'left') {\n                    return 'translate(' + (legendSpace + margin.left + axisLabelSpace) + ', 0)';\n                } else if (_legendPosition == 'right') {\n                    return 'translate(' + margin.left + ', 0)';\n                }\n            });\n        if (!_showLegend) {\n            _local_svg.select('.plot')\n                .attr('transform', function () {\n                    return 'translate(' + margin.left + ', ' + 0 + ')';\n                });\n        }\n\n        x = d3.scaleBand()\n            .rangeRound([0, plotWidth])\n            .paddingInner(0.1)\n            .padding([0.1])\n            .align(0.1);\n\n        y = d3.scaleLinear()\n            .rangeRound([plotHeight, 0]);\n\n        var keys = UTIL.getMeasureList(data[0], _dimension);\n\n        for (i = 0; i < data.length; i++) {\n            var t = 0;\n            for (j = 0; j < keys.length; j++) {\n                t = parseInt(t) + parseInt(data[i][keys[j]]);\n            }\n            data[i].total = t;\n        }\n\n        x.domain(data.map(function (d) { return d[_dimension[0]]; }));\n        y.domain([0, d3.max(data, function (d) {\n            return d.total;\n        })]).nice();\n\n        data.map(function (val) {\n            delete val['total'];\n        })\n\n        var labelStack = [];\n        var stack = plot.append('g')\n            .attr('class', 'stack')\n            .selectAll('g')\n            .data(d3.stack().keys(keys)(data))\n            .enter().append('g')\n            .attr('class', 'stackedverticalbar-group');\n\n        var stackedverticalbar = stack.selectAll('g')\n            .data(function (d, i) {\n                d.forEach(function (datum) {\n                    datum.key = d.key;\n                })\n                return d;\n            })\n            .enter().append('g')\n            .attr('class', 'stackedverticalbar');\n\n        drawViz(stackedverticalbar);\n\n        plot.append(\"g\")\n            .attr(\"class\", \"x_axis\")\n            .attr(\"transform\", \"translate(0,\" + plotHeight + \")\")\n            .call(d3.axisBottom(x))\n            .append(\"text\")\n            .attr(\"x\", plotWidth / 2)\n            .attr(\"y\", 2 * axisLabelSpace)\n            .attr(\"dy\", \"0.32em\")\n            .attr(\"fill\", \"#000\")\n            .attr(\"font-weight\", \"bold\")\n            .style('text-anchor', 'middle')\n            .style('visibility', UTIL.getVisibility(_showXaxisLabel))\n            .text(function () {\n                return _displayName;\n            });\n\n        plot.append(\"g\")\n            .attr(\"class\", \"y_axis\")\n            .call(d3.axisLeft(y).ticks(null, \"s\"))\n            .append(\"text\")\n            .attr(\"x\", plotHeight / 2)\n            .attr(\"y\", 2 * axisLabelSpace)\n            .attr(\"transform\", function (d) { return \"rotate(\" + 90 + \")\"; })\n            .attr(\"dy\", \"0.32em\")\n            .style('visibility', UTIL.getVisibility(_showYaxisLabel))\n            .attr(\"font-weight\", \"bold\")\n            .style('text-anchor', 'middle')\n            .text(function () {\n                return _displayNameForMeasure.map(function (p) { return p; }).join(', ');\n            });\n\n        UTIL.setAxisColor(_local_svg, _yAxisColor, _xAxisColor, _showYaxis, _showXaxis, _showYaxis, _showXaxis);\n\n        _local_svg.select('g.sort').remove();\n        UTIL.sortingView(container, parentHeight, parentWidth + margin.left, legendBreakCount, axisLabelSpace, offsetX);\n\n        _local_svg.select('g.sort').selectAll('text')\n            .on('click', function () {\n                var order = d3.select(this).attr('class')\n                switch (order) {\n                    case 'ascending':\n                        UTIL.toggleSortSelection(me, 'ascending', drawPlot, _local_svg, keys, _Local_data);\n                        break;\n                    case 'descending':\n                        UTIL.toggleSortSelection(me, 'descending', drawPlot, _local_svg, keys, _Local_data);\n                        break;\n                    case 'reset': {\n                        _local_svg.select(me.parentElement).select('.plot').remove();\n                        drawPlot.call(me, _Local_data);\n                        break;\n                    }\n                }\n            });\n\n        d3.select(div).select('.btn-primary')\n            .on('click', applyFilter(chart));\n\n        d3.select(div).select('.btn-default')\n            .on('click', clearFilter());\n\n        _local_svg.select('g.lasso').remove()\n        var lasso = d3.lasso()\n            .hoverSelect(true)\n            .closePathSelect(true)\n            .closePathDistance(100)\n            .items(stackedverticalbar)\n            .targetArea(_local_svg);\n\n        lasso.on('start', onLassoStart(lasso, chart))\n            .on('draw', onLassoDraw(lasso, chart))\n            .on('end', onLassoEnd(lasso, chart));\n\n        _local_svg.call(lasso);\n    }\n\n    chart._legendInteraction = function (event, data) {\n        switch (event) {\n            case 'mouseover':\n                _legendMouseOver(data);\n                break;\n            case 'mousemove':\n                _legendMouseMove(data);\n                break;\n            case 'mouseout':\n                _legendMouseOut(data);\n                break;\n            case 'click':\n                _legendClick(data);\n                break;\n        }\n    }\n\n    var _legendMouseOver = function (data) {\n\n        d3.selectAll('g.stackedverticalbar')\n            .filter(function (d) {\n                return d.measure === data;\n            })\n            .select('rect')\n            .style('fill', COMMON.HIGHLIGHTER);\n    }\n\n    var _legendMouseMove = function (data) {\n\n    }\n\n    var _legendMouseOut = function (data) {\n        d3.selectAll('g.stackedverticalbar')\n            .filter(function (d) {\n                return d.measure === data;\n            })\n            .select('rect')\n            .style('fill', function (d, i) {\n                return UTIL.getDisplayColor(_measure.indexOf(d.measure), _displayColor);\n            });\n    }\n\n    var _legendClick = function (data) {\n        var _filter = UTIL.getFilterData(_localLabelStack, data, _originalData)\n        drawPlot.call(this, _filter);\n    }\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.update = function (data) {\n\n        _Local_data = data,\n            filterData = [];\n\n        x = d3.scaleBand()\n            .rangeRound([0, plotWidth])\n            .paddingInner(0.1)\n            .padding([0.1])\n            .align(0.1);\n        var labelStack = [];\n        y = d3.scaleLinear()\n            .rangeRound([plotHeight, 0]);\n\n        var keys = UTIL.getMeasureList(data[0], _dimension);\n\n        for (i = 0; i < data.length; i++) {\n            var t = 0;\n            for (j = 0; j < keys.length; j++) {\n                t = parseInt(t) + parseInt(data[i][keys[j]]);\n            }\n            data[i].total = t;\n        }\n\n        x.domain(data.map(function (d) { return d[_dimension[0]]; }));\n        y.domain([0, d3.max(data, function (d) {\n            return d.total;\n        })]).nice();\n\n        data.map(function (val) {\n            delete val['total'];\n        })\n        var plot = _local_svg.select('.plot')\n\n        var stack = _local_svg.select('g.stack').selectAll('g.stackedverticalbar-group')\n            .data(d3.stack().keys(keys)(data))\n\n        stack.enter().append('g')\n            .attr('class', 'stackedverticalbar-group');\n\n        stack.exit().remove();\n\n        var stackedVerticalbarGroup = plot.select('g.stack').selectAll('g.stackedverticalbar-group');\n\n        var stackedverticalbar = stackedVerticalbarGroup.selectAll('g.stackedverticalbar')\n            .data(function (d, i) {\n                d.forEach(function (datum) {\n                    datum.key = d.key;\n                })\n                return d;\n            });\n\n\n        stackedverticalbar.select('rect')\n            .attr(\"x\", function (d) {\n                return x(d.data[_dimension[0]]);\n            })\n            .attr('class', function (d, i) {\n                return d.data[_dimension[0]];\n            })\n            .attr(\"y\", function (d) { return y(d[1]); })\n            .attr(\"height\", function (d) { return y(d[0]) - y(d[1]); })\n            .attr(\"width\", x.bandwidth())\n            .style('stroke-width', 2)\n\n        stackedverticalbar.select('text')\n            .text(function (d, i) {\n                return UTIL.getFormattedValue(d.data[d.key], UTIL.getValueNumberFormat(_measure.indexOf(d.key), _numberFormat));\n            })\n            .attr('x', function (d, i) {\n                return x(d.data[_dimension[0]]) + x.bandwidth() / 2;\n            })\n            .attr('y', function (d, i) {\n                return y(d[1]) + 5;\n            })\n            .attr('dy', function (d, i) {\n                return offsetX / 2;\n            })\n            .style('text-anchor', 'middle')\n\n        var newBars = stackedverticalbar.enter().append('g')\n            .attr('class', 'stackedverticalbar');\n\n        drawViz(newBars);\n\n        plot.select('.x_axis')\n            .transition()\n            .duration(1000)\n            .call(d3.axisBottom(x));\n\n        plot.select('.y_axis')\n            .transition()\n            .duration(1000)\n            .call(d3.axisLeft(y).ticks(null, \"s\"));\n\n        stackedverticalbar.exit()\n            .transition()\n            .duration(1000)\n            .remove();\n\n        UTIL.setAxisColor(_local_svg, _yAxisColor, _xAxisColor, _showYaxis, _showXaxis);\n        UTIL.displayThreshold(threshold, data, keys);\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.showLegend = function (value) {\n        if (!arguments.length) {\n            return _showLegend;\n        }\n        _showLegend = value;\n        return chart;\n    }\n\n    chart.legendPosition = function (value) {\n        if (!arguments.length) {\n            return _legendPosition;\n        }\n        _legendPosition = value;\n        return chart;\n    }\n\n    chart.sort = function (value) {\n        if (!arguments.length) {\n            return _sort;\n        }\n        _sort = value;\n        return chart;\n    }\n\n    chart.tooltip = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    chart.showXaxis = function (value) {\n        if (!arguments.length) {\n            return _showXaxis;\n        }\n        _showXaxis = value;\n        return chart;\n    }\n\n    chart.showYaxis = function (value) {\n        if (!arguments.length) {\n            return _showYaxis;\n        }\n        _showYaxis = value;\n        return chart;\n    }\n\n    chart.showXaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showXaxisLabel;\n        }\n        _showXaxisLabel = value;\n        return chart;\n    }\n\n    chart.showYaxisLabel = function (value) {\n        if (!arguments.length) {\n            return _showYaxisLabel;\n        }\n        _showYaxisLabel = value;\n        return chart;\n    }\n\n    chart.xAxisColor = function (value) {\n        if (!arguments.length) {\n            return _xAxisColor;\n        }\n        _xAxisColor = value;\n        return chart;\n    }\n\n    chart.yAxisColor = function (value) {\n        if (!arguments.length) {\n            return _yAxisColor;\n        }\n        _yAxisColor = value;\n        return chart;\n    }\n\n    chart.showGrid = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _showGrid = value;\n        return chart;\n    }\n\n    chart.stacked = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _stacked = value;\n        return chart;\n    }\n\n    chart.displayName = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _displayName = value;\n        return chart;\n    }\n\n    chart.legendData = function (measureConfig, measureName) {\n        _legendData = {\n            measureConfig: measureConfig,\n            measureName: measureName\n        }\n        return _legendData;\n    }\n\n    chart.showValues = function (value, measure) {\n        _baseAccessor.call(_showValues, value, measure)\n    }\n\n    chart.displayNameForMeasure = function (value, measure) {\n        _baseAccessor.call(_displayNameForMeasure, value, measure)\n    }\n\n    chart.fontStyle = function (value, measure) {\n        _baseAccessor.call(_fontStyle, value, measure)\n    }\n\n    chart.fontWeight = function (value, measure) {\n        _baseAccessor.call(_fontWeight, value, measure)\n    }\n\n    chart.numberFormat = function (value, measure) {\n        _baseAccessor.call(_numberFormat, value, measure)\n    }\n\n    chart.textColor = function (value, measure) {\n        _baseAccessor.call(_textColor, value, measure)\n    }\n\n    chart.displayColor = function (value, measure) {\n        _baseAccessor.call(_displayColor, value, measure)\n    }\n\n    chart.borderColor = function (value, measure) {\n        _baseAccessor.call(_borderColor, value, measure)\n    }\n\n    chart.fontSize = function (value, measure) {\n        _baseAccessor.call(_fontSize, value, measure)\n    }\n\n    var _baseAccessor = function (value, measure) {\n        var me = this;\n\n        if (!arguments.length) {\n            return me;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            me.splice(0, me.length);\n            me.push.apply(me, value);\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return me[index];\n        } else {\n            me[index] = value;\n        }\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = stackedverticalbar;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/stackedverticalbar.js?");

/***/ }),

/***/ "./js/charts/table.js":
/*!****************************!*\
  !*** ./js/charts/table.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction table() {\n\n    var _NAME = 'table';\n\n    var _config = [],\n        _dimension = [],\n        _displayNameForDimension = [],\n        _cellColorForDimension = [],\n        _fontStyleForDimension = [],\n        _fontWeightForDimension = [],\n        _fontSizeForDimension = [],\n        _textColorForDimension = [],\n        _textColorExpressionForDimension = [],\n        _textAlignmentForDimension = [],\n        _measure = [],\n        _displayNameForMeasure = [],\n        _cellColorForMeasure = [],\n        _cellColorExpressionForMeasure = [],\n        _fontStyleForMeasure = [],\n        _fontSizeForMeasure = [],\n        _numberFormatForMeasure = [],\n        _textColorForMeasure = [],\n        _textAlignmentForMeasure = [],\n        _textColorExpressionForMeasure = [],\n        _iconNameForMeasure = [],\n        _iconPositionForMeasure = [],\n        _iconExpressionForMeasure = [],\n        _iconFontWeight = [],\n        _iconColor = [],\n        _fontWeightForMeasure = [];\n\n    var _localData, filterData = [];\n\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.displayNameForDimension(config.displayNameForDimension);\n        this.cellColorForDimension(config.cellColorForDimension);\n        this.fontStyleForDimension(config.fontStyleForDimension);\n        this.fontWeightForDimension(config.fontWeightForDimension);\n        this.fontSizeForDimension(config.fontSizeForDimension);\n        this.textColorForDimension(config.textColorForDimension);\n        this.textColorExpressionForDimension(config.textColorExpressionForDimension);\n        this.textAlignmentForDimension(config.textAlignmentForDimension);\n        this.displayNameForMeasure(config.displayNameForMeasure);\n        this.cellColorForMeasure(config.cellColorForMeasure);\n        this.cellColorExpressionForMeasure(config.cellColorExpressionForMeasure);\n        this.fontStyleForMeasure(config.fontStyleForMeasure);\n        this.fontSizeForMeasure(config.fontSizeForMeasure);\n        this.numberFormatForMeasure(config.numberFormatForMeasure);\n        this.textColorForMeasure(config.textColorForMeasure);\n        this.textAlignmentForMeasure(config.textAlignmentForMeasure);\n        this.textColorExpressionForMeasure(config.textColorExpressionForMeasure);\n        this.iconNameForMeasure(config.iconNameForMeasure);\n        this.iconPositionForMeasure(config.iconPositionForMeasure);\n        this.iconExpressionForMeasure(config.iconExpressionForMeasure);\n        this.fontWeightForMeasure(config.fontWeightForMeasure);\n\n        this.iconFontWeight(config.iconFontWeight);\n        this.iconColor(config.iconColor);\n    }\n\n    var _baseAccessor = function (value, measure) {\n        var me = this;\n\n        if (!arguments.length) {\n            /**\n             * Getter method call with no arguments\n             * E.g. <chart>.<accessor_function>() ==> [<item1>, <item2>]\n             */\n            return me;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            /**\n             * Setter method call with only value argument\n             * E.g. <chart>.<accessor_function>([<item1>, <item2>]) ==> <chart_function>\n             */\n            me.splice(0, me.length);\n            me.push.apply(me, value);\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            /**\n             * Getter method call with only measure argument\n             * E.g. <chart>.<accessor_function>(<measure>) ==> <item>\n             */\n            return me[index];\n        } else {\n            /**\n             * Setter method call with both value and measure arguments\n             * E.g. <chart>.<accessor_function>(<item>, <measure>) ==> <chart_function>\n             */\n            me[index] = value;\n        }\n\n        return chart;\n    }\n\n    var getIcon = function (index, endValue) {\n        var iconOutput = \"\";\n\n        var iconStyle = {\n            'font-weight': _iconFontWeight[index] || COMMON.DEFAULT_FONTWEIGHT,\n            'color': _iconColor[index] || COMMON.DEFAULT_COLOR,\n            'font-size': _fontSizeForMeasure[index] || COMMON.DEFAULT_FONTSIZE,\n            'text-align': getIconPosition(index)\n        };\n\n        if (_iconExpressionForMeasure[index].length) {\n            _iconNameForMeasure[index] = UTIL.expressionEvaluator(_iconExpressionForMeasure[index], endValue, 'icon');\n            iconStyle['color'] = UTIL.expressionEvaluator(_iconExpressionForMeasure[index], endValue, 'color');\n        }\n\n        iconStyle = JSON.stringify(iconStyle);\n        iconStyle = iconStyle.replace(/[\"{}]/g, '').replace(/,/g, ';');\n\n        iconOutput += \"<i  class=\\\"\" + _iconNameForMeasure[index] + \"\\\" style=\\\"\" + iconStyle + \"\\\" aria-hidden=\\\"true\\\"></i>\";\n\n\n\n        if (getIconName(index) !== \"\") {\n            return iconOutput;\n        }\n        return \"\";\n    }\n    var getIconPosition = function (index) {\n        return _iconPositionForMeasure[index];\n    }\n    var getIconName = function (index) {\n        return _iconNameForMeasure[index];\n    }\n    var applyFilter = function () {\n        return function () {\n            var d = _localData.filter(function (val) {\n                for (var index = 0; index < filterData.length; index++) {\n                    if (val[filterData[index].key] == filterData[index].value) {\n                        return val;\n                    }\n                }\n\n            });\n            d3.select('#donut')\n                .datum(d)\n                .call(chart);\n\n            _local_svg.html('')\n\n            chart(_local_svg)\n        }\n    }\n    var clearFilter = function () {\n        return function () {\n            d3.select('#donut')\n                .datum(_localData)\n                .call(chart);\n\n            _local_svg.html('')\n\n            chart(_local_svg)\n        }\n    }\n    chart.readerTableChart = function (str, ctr, _local_svg, key) {\n        var confirm = d3.select('.confirm')\n            .style('visibility', 'visible');\n        var searchObj = filterData.find(o => o[key] === str);\n        if (searchObj == undefined) {\n            var obj = Object();\n            obj.key = key;\n            obj.value = str;\n            filterData.push(obj);\n        }\n        $(ctr).toggleClass('selected')\n\n    }\n    function chart(selection) {\n        _local_svg = selection;\n\n        selection.each(function (data) {\n            _localData = data\n            var margin = {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 45\n            };\n\n            var div = d3.select(this);\n\n            var width = +div.attr('width');\n            var height = +div.attr('height');\n            var disv = d3.select(\"#donut\");\n            $('#donut').css('width', width)\n                .css('height', height).css('overflow-y', 'hidden').css('overflow-x', 'auto');\n\n            var table = $('<table id=\"viz_table\" class=\"display nowrap\" style=\"width:100%\"></table>').addClass('table table-condensed table-hover');\n\n            var thead = \"<thead><tr>\",\n                tbody = \"<tbody>\";\n\n            _dimension.forEach(function (item, index) {\n                var title = _displayNameForDimension[index],\n                    style = {\n                        'text-align': _textAlignmentForDimension[index],\n                        'background-color': '#f1f1f1',\n                        'font-weight': 'bold'\n                    };\n\n                style = JSON.stringify(style);\n                style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                if (title != \"\") {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + title + \"</th>\";\n                } else {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + item + \"</th>\";\n                }\n            });\n\n            _measure.forEach(function (item, index) {\n                var title = _displayNameForMeasure[index],\n                    style = {\n                        'text-align': _textAlignmentForMeasure[index],\n                        'background-color': '#f1f1f1',\n                        'font-weight': 'bold'\n                    };\n\n                style = JSON.stringify(style);\n                style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n\n                if (title != \"\") {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + title + \"</th>\";\n                } else {\n                    thead += \"<th style=\\\"\" + style + \"\\\">\" + item + \"</th>\";\n                }\n            });\n\n            thead += \"</tr></thead>\";\n            table.append(thead);\n\n            data.forEach(function (d) {\n                tbody += \"<tr>\";\n                _dimension.forEach(function (item, index) {\n\n                    var style = {\n                        'text-align': _textAlignmentForDimension[index],\n                        'background-color': _cellColorForDimension[index],\n                        'font-style': _fontStyleForDimension[index],\n                        'font-weight': _fontWeightForDimension[index],\n                        'font-size': _fontSizeForDimension[index],\n                        'color': _textColorForDimension[index]\n                    };\n                    style['color'] = UTIL.expressionEvaluator(_textColorExpressionForDimension[index], d[_dimension[index]], 'color');\n\n                    style = JSON.stringify(style);\n                    style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n                    tbody += \"<td onClick=\\\"chart.readerTableChart('\" + d[_dimension[index]] + \"',this,_local_svg,'\" + item + \"')\\\" style=\\\"\" + style + \"\\\">\" + d[_dimension[index]] + \"</td>\";\n                });\n\n                _measure.forEach(function (item, index) {\n                    var style = {\n                        'text-align': _textAlignmentForMeasure[index],\n                        'background-color': _cellColorForMeasure[index],\n                        'font-style': _fontStyleForMeasure[index],\n                        'font-weight': _fontWeightForMeasure[index],\n                        'font-size': _fontSizeForMeasure[index],\n                        'color': _textColorForMeasure[index]\n                    };\n                    style['color'] = UTIL.expressionEvaluator(_textColorExpressionForMeasure[index], d[_measure[index]], 'color');\n                    style['background-color'] = UTIL.expressionEvaluator(_cellColorExpressionForMeasure[index], d[_measure[index]], 'color');\n                    style = JSON.stringify(style);\n                    style = style.replace(/\",\"/g, ';').replace(/[\"{}]/g, '');\n                    tbody += \"<td onClick=\\\"chart.readerTableChart('\" + d[_measure[index]] + \"',this,_local_svg,'\" + item + \"')\\\" style=\\\"\" + style + \"\\\">\" + getIcon(index, d[_measure[index]]) + UTIL.getFormattedValue(d[_measure[index]], UTIL.getValueNumberFormat(index, _numberFormatForMeasure)) + \"</td>\";\n                });\n                tbody += \"</tr>\";\n            });\n\n            tbody += \"</tbody>\";\n            table.append(tbody);\n\n            $('#donut').append(table);\n\n            $('#donut').find('#viz_table').dataTable({\n                scrollY: height - 150,\n                scrollX: true,\n                scrollCollapse: true,\n                ordering: true,\n                info: true,\n\n                pagingType: \"full_numbers\",\n                aLengthMenu: [[2, 5, 10, 15, 20, 25, -1], [2, 5, 10, 15, 20, 25, \"All\"]],\n                iDisplayLength: 20,\n                bDestroy: true,\n                dom: '<\"table-header\">rt<\"table-footer\"lp>',\n                fnDrawCallback: function (oSettings) {\n                    if (oSettings._iDisplayLength > oSettings.fnRecordsDisplay()) {\n                        $(oSettings.nTableWrapper).find('.dataTables_paginate').hide();\n                        $(oSettings.nTableWrapper).find('.dataTables_info').hide();\n                    }\n                }\n            });\n\n            d3.select('.btn-primary')\n                .on('click', applyFilter());\n\n            d3.select('.btn-default')\n                .on('click', clearFilter());\n        }\n\n        );\n    }\n    /**\n     * Builds the html data for the tooltip\n     *\n     * @param {object} datum Datum forming the arc\n     * @param {function} chart Pie chart function\n     * @return {string} String encoded HTML data\n     */\n    chart._legendInteraction = function (event, data) {\n        var arcGroup = d3.selectAll('g.arc')\n            .filter(function (d) {\n                return d.data[_dimension[0]] === data[_dimension[0]];\n            });\n\n        if (event === 'mouseover') {\n            arcGroup.select('path')\n                .style('fill', COMMON.HIGHLIGHTER);\n        } else if (event === 'mousemove') {\n            // do something\n        } else if (event === 'mouseout') {\n            arcGroup.select('path')\n                .style('fill', function (d, i) {\n                    return COMMON.COLORSCALE(d.data[_dimension[0]]);\n                });\n        } else if (event === 'click') {\n\n        }\n    }\n\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.displayNameForDimension = function (value, measure) {\n        return _baseAccessor.call(_displayNameForDimension, value, measure);\n    }\n\n    chart.cellColorForDimension = function (value, measure) {\n        return _baseAccessor.call(_cellColorForDimension, value, measure);;\n    }\n\n    chart.fontStyleForDimension = function (value, measure) {\n        return _baseAccessor.call(_fontStyleForDimension, value, measure);\n    }\n\n    chart.fontWeightForDimension = function (value, measure) {\n        return _baseAccessor.call(_fontWeightForDimension, value, measure);\n    }\n\n    chart.fontSizeForDimension = function (value, measure) {\n        return _baseAccessor.call(_fontSizeForDimension, value, measure);\n    }\n\n    chart.textColorForDimension = function (value, measure) {\n        return _baseAccessor.call(_textColorForDimension, value, measure);\n    }\n\n    chart.textColorExpressionForDimension = function (value, measure) {\n        if (!arguments.length) {\n            return _textColorExpressionForDimension;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            _textColorExpressionForDimension = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return _textColorExpressionForDimension[index];\n        } else {\n            _textColorExpressionForDimension[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n    }\n\n    chart.textAlignmentForDimension = function (value, measure) {\n        return _baseAccessor.call(_textAlignmentForDimension, value, measure);\n    }\n\n    chart.displayNameForMeasure = function (value, measure) {\n        return _baseAccessor.call(_displayNameForMeasure, value, measure);\n    }\n\n    chart.cellColorForMeasure = function (value, measure) {\n        return _baseAccessor.call(_cellColorForMeasure, value, measure);\n    }\n\n    chart.cellColorExpressionForMeasure = function (value, measure) {\n        if (!arguments.length) {\n            return _cellColorExpressionForMeasure;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            _cellColorExpressionForMeasure = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return _cellColorExpressionForMeasure[index];\n        } else {\n            _cellColorExpressionForMeasure[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n    }\n\n    chart.fontStyleForMeasure = function (value, measure) {\n        return _baseAccessor.call(_fontStyleForMeasure, value, measure);\n    }\n\n    chart.fontSizeForMeasure = function (value, measure) {\n        return _baseAccessor.call(_fontSizeForMeasure, value, measure);\n    }\n\n    chart.numberFormatForMeasure = function (value, measure) {\n        return _baseAccessor.call(_numberFormatForMeasure, value, measure);\n    }\n\n    chart.textColorForMeasure = function (value, measure) {\n        return _baseAccessor.call(_textColorForMeasure, value, measure);\n    }\n\n    chart.textAlignmentForMeasure = function (value, measure) {\n        return _baseAccessor.call(_textAlignmentForMeasure, value, measure);\n    }\n\n    chart.textColorExpressionForMeasure = function (value, measure) {\n        if (!arguments.length) {\n            return _textColorExpressionForMeasure;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            _textColorExpressionForMeasure = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            return _textColorExpressionForMeasure[index];\n        } else {\n            _textColorExpressionForMeasure[index] = UTIL.getExpressionConfig(value, ['color']);\n        }\n    }\n\n    chart.iconNameForMeasure = function (value, measure) {\n        return _baseAccessor.call(_iconNameForMeasure, value, measure);\n    }\n\n    chart.iconPositionForMeasure = function (value, measure) {\n        return _baseAccessor.call(_iconPositionForMeasure, value, measure);\n    }\n\n    chart.iconExpressionForMeasure = function (value, measure) {\n        if (!arguments.length) {\n            /**\n             * Getter method call with no arguments\n             * E.g. <chart>.kpiIconExpression() ==> [<item1>, <item2>]\n             */\n            return _iconExpressionForMeasure;\n        }\n\n        if (value instanceof Array && measure == void 0) {\n            /**\n             * Setter method call with only value argument\n             * E.g. <chart>.kpiIconExpression([<item1>, <item2>]) ==> <chart_function>\n             */\n            _iconExpressionForMeasure = value.map(function (v) {\n                return UTIL.getExpressionConfig(v, ['icon', 'color']);\n            });\n            return chart;\n        }\n\n        var index = _measure.indexOf(measure);\n\n        if (index === -1) {\n            throw new Error('Invalid measure provided');\n        }\n\n        if (value == void 0) {\n            /**\n             * Getter method call with only measure argument\n             * E.g. <chart>.kpiIconExpression(<measure>) ==> <item>\n             */\n            return _iconExpressionForMeasure[index];\n        } else {\n            /**\n             * Setter method call with both value and measure arguments\n             * E.g. <chart>.kpiIconExpression(<item>, <measure>) ==> <chart_function>\n             */\n            _iconExpressionForMeasure[index] = UTIL.getExpressionConfig(value, ['icon', 'color']);\n        }\n\n        return chart;\n    }\n\n    chart.fontWeightForMeasure = function (value, measure) {\n        return _baseAccessor.call(_fontWeightForMeasure, value, measure);\n    }\n\n    chart.iconFontWeight = function (value, measure) {\n        return _baseAccessor.call(_iconFontWeight, value, measure);\n    }\n\n\n    chart.iconColor = function (value, measure) {\n        return _baseAccessor.call(_iconColor, value, measure);\n    }\n    return chart;\n}\n\nmodule.exports = table;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/table.js?");

/***/ }),

/***/ "./js/charts/treemap.js":
/*!******************************!*\
  !*** ./js/charts/treemap.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")(),\n    UTIL = __webpack_require__(/*! ../extras/util.js */ \"./js/extras/util.js\")(),\n    LEGEND = __webpack_require__(/*! ../extras/legend.js */ \"./js/extras/legend.js\")();\n\nfunction treemap() {\n\n    /* These are the constant global variable for the function clusteredverticalbar.\n     */\n    var _NAME = 'treemap';\n\n    /* These are the private variables that is initialized by the arguments sent\n     * by the users and can be updated using public methods.\n     */\n\n    var _config,\n        _dimension,\n        _measure,\n        showLabel,\n        colorPattern,\n        showValues,\n        valueTextColour,\n        fontStyleForMes,\n        fontWeightForMes,\n        fontSizeForMes,\n        numberFormat,\n\n        showLabelForDimension = [],\n        labelColorForDimension = [],\n        displayColor = [],\n        fontStyleForDimension = [],\n        fontWeightForDimension = [],\n        fontSizeForDimension = [];\n\n    /* These are the common variables that is shared across the different private/public\n     * methods but is initialized/updated within the methods itself.\n     */\n    var _localSVG,\n        _localTotal,\n        _localData = [],\n        _localTooltip,\n        textPadding = 2,\n        _originalData,\n        width,\n        height\n    // _localLabelStack;\n\n    /* These are the common private functions that is shared across the different private/public\n     * methods but is initialized beforehand.\n     */\n    var BASE_COLOR = '#ffffff',\n        dim1Color = d3.scaleLinear(),\n        dim2Color = d3.scaleLinear(),\n        filterData = [],\n        root,\n        treemap,\n        nest;\n    /* -------------------------------------------------------------------------------- */\n    var _setConfigParams = function (config) {\n        this.dimension(config.dimension);\n        this.measure(config.measure);\n        this.showLabel(config.showLabel);\n        this.colorPattern(config.colorPattern);\n        this.showValues(config.showValues);\n        this.valueTextColour(config.valueTextColour);\n        this.fontStyleForMes(config.fontStyleForMes);\n        this.fontWeightForMes(config.fontWeightForMes);\n        this.fontSizeForMes(config.fontSizeForMes);\n        this.numberFormat(config.numberFormat);\n        this.showLabelForDimension(config.showLabelForDimension);\n        this.labelColorForDimension(config.labelColorForDimension);\n        this.displayColor(config.displayColor);\n        this.fontStyleForDimension(config.fontStyleForDimension);\n        this.fontWeightForDimension(config.fontWeightForDimension);\n        this.fontSizeForDimension(config.fontSizeForDimension);\n    }\n\n    var setColorDomainRange = function (arr, dim) {\n        var values = [];\n\n        arr.forEach(function (item) {\n            if (item.depth == dim) {\n                values.push(item.value);\n            }\n        });\n\n        if (dim == 1) {\n            dim1Color.domain([Math.min.apply(Math, values), Math.max.apply(Math, values)]);\n            dim1Color.range([d3.rgb(displayColor[0]).brighter(), d3.rgb(displayColor[0]).darker()])\n        } else if (dim == 2) {\n            dim2Color.domain([Math.min.apply(Math, values), Math.max.apply(Math, values)]);\n            dim2Color.range([d3.rgb(displayColor[1]).brighter(), d3.rgb(displayColor[1]).darker()])\n        }\n    }\n\n    var getFillColor = function (obj, index) {\n        if (index == 0) {\n            return BASE_COLOR;\n        }\n\n        if (colorPattern == 'single_color') {\n            if (_dimension.length == 2) {\n                if (obj.children) {\n                    return displayColor[0];\n                } else {\n                    return displayColor[1];\n                }\n            } else {\n                return this.displayColor[0];\n            }\n        } else if (colorPattern == 'unique_color') {\n\n            var defaultColors = ['#4897D8',\n                '#ED5752',\n                '#5BC8AC',\n                '#20948B',\n                '#9A9EAB',\n                '#755248',\n                '#FA6E59',\n                '#CF3721',\n                '#31A9B8',\n                '#EFEFEF',\n                '#34675C',\n                '#AF4425'\n            ]\n            return defaultColors[index % (defaultColors.length)];\n            // return d3.schemeCategory20c[index % (d3.schemeCategory20c.length)];\n        } else if (colorPattern == 'gradient_color') {\n            if (_dimension.length == 2) {\n                if (obj.children) {\n                    return dim1Color(obj.value);\n                } else {\n                    return dim2Color(obj.value);\n                }\n            } else {\n                return dim1Color(obj.value);\n            }\n        }\n    }\n\n    var getFilterLabels = function (obj) {\n        var result = [];\n\n        if (_dimension.length == 2) {\n            if (obj.children) {\n                if (showLabelForDimension[0]) {\n                    result = result.concat({ node: obj, data: obj.data.key });\n                }\n            } else {\n                if (showLabelForDimension[1]) {\n                    result = result.concat({ node: obj, data: obj.data.key });\n                }\n            }\n        } else {\n            if (showLabelForDimension[0]) {\n                result = result.concat({ node: obj, data: obj.data.key });\n            }\n        }\n\n        if (showLabelForDimension[0]) {\n            var nf = UTIL.getNumberFormatter(numberFormat),\n                value;\n\n            if (numberFormat == \"Percent\") {\n                value = nf(obj.value / _localTotal);\n            } else {\n                value = nf(obj.value);\n            }\n\n            if (value.indexOf(\"G\") != -1) {\n                value = value.slice(0, -1) + \"B\";\n            }\n            result = result.concat({ node: obj, data: value });\n        }\n\n        if (!obj.parent) {\n            return [];\n        }\n\n        return result;\n    }\n\n    var getColorValue = function (data, index) {\n        if ((data.node.children && _dimension.length == 2) || (!data.node.children && _dimension.length == 1)) {\n            if (showLabelForDimension[0]) {\n                return labelColorForDimension[0];\n            }\n        } else {\n            if (showLabelForDimension[1]) {\n                return labelColorForDimension[1];\n            }\n        }\n        return null;\n    }\n\n    var getFontWeightValue = function (obj, index) {\n\n        if ((obj.node.children && _dimension.length == 2) || (!obj.node.children && _dimension.length == 1)) {\n            if (showLabelForDimension[0]) {\n                return fontWeightForDimension[0];\n            }\n        } else {\n            if (showLabelForDimension[1]) {\n                return fontWeightForDimension[1];\n            }\n        }\n\n        return null;\n    }\n\n    var getFontStyleValue = function (obj, index) {\n\n        if ((obj.node.children && _dimension.length == 2) || (!obj.node.children && _dimension.length == 1)) {\n            if (showLabelForDimension[0]) {\n                return fontStyleForDimension[0];\n            }\n        } else {\n            if (showLabelForDimension[1]) {\n                return fontStyleForDimension[1];\n            }\n        }\n\n\n        return null;\n    }\n\n    var getFontSizeValue = function (obj, index) {\n\n        if ((obj.node.children && _dimension.length == 2) || (!obj.node.children && _dimension.length == 1)) {\n            if (showLabelForDimension[0]) {\n                return fontSizeForDimension[0];\n            }\n        } else {\n            if (showLabelForDimension[1]) {\n                return fontSizeForDimension[1];\n            }\n        }\n\n\n        return null;\n    }\n\n    var getVisibilityValue = function (element, node) {\n        var contWidth = node.x1 - node.x0,\n            contHeight = node.y1 - node.y0,\n            textWidth = element.getComputedTextLength(),\n            textHeight = parseInt(d3.select(element).style('font-size').replace('px', ''));\n\n        if (((textWidth + 2 * textPadding) > contWidth) || ((textHeight + 2 * textPadding) > contHeight)) {\n            return 'hidden';\n        }\n        return 'visible';\n    }\n\n    var _handleMouseOverFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            d3.select(this).style('cursor', 'pointer')\n            // .style('cursor', 'pointer')\n            // .style('fill-opacity', .5);\n            var border = d3.select(this).attr('fill');\n            if (tooltip) {\n                UTIL.showTooltip(tooltip);\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me), container, border);\n            }\n        }\n    }\n\n    var _handleMouseMoveFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            if (tooltip) {\n                var border = d3.select(this).attr('fill');\n                UTIL.updateTooltip.call(tooltip, _buildTooltipData(d, me, border), container, border);\n            }\n        }\n    }\n\n    var _handleMouseOutFn = function (tooltip, container) {\n        var me = this;\n\n        return function (d, i) {\n            var border = d3.select(this).attr('fill');\n            d3.select(this).style('cursor', 'default')\n                .style('fill', function (d1, i) {\n                    return border\n                })\n\n            if (tooltip) {\n                UTIL.hideTooltip(tooltip);\n            }\n        }\n    }\n\n    var _buildTooltipData = function (datum, chart) {\n        var output = \"\";\n\n        if (datum.data.key != undefined) {\n            if (datum.children != undefined) {\n                output += \"<table><tr>\" +\n                    \"<tr> <th>\" + _dimension[0] + \": </th>\"\n                    + \"<td>\" + datum.data.key + \"</td>\"\n                    + \"</tr>\";\n            }\n            else {\n                output += \"<table><tr>\" +\n                    \"<tr><th>\" + _dimension[0] + \"</th><th>\" + datum.parent.data.key + \"</th></tr>\" +\n                    \"<tr> <th>\" + _dimension[1] + \": </th>\"\n                    + \"<td>\" + datum.data.key + \"</td>\"\n                    + \"</tr>\";\n            }\n\n            if (datum.data.values != undefined) {\n                for (var index = 0; index < datum.data.values.length; index++) {\n                    output += \" <tr> <th>\" + datum.data.values[index].key + \": </th>\"\n                        + \"<td>\" + datum.data.values[index].value + \"</td>\"\n                        + \"</tr>\";\n                }\n            }\n            else {\n                output += \" <tr> <th>\" + _measure[0] + \": </th>\"\n                    + \"<td>\" + datum.data.value + \"</td>\"\n                    + \"</tr>\";\n            }\n            output += \"</table>\";\n            return output;\n        }\n        else {\n            UTIL.hideTooltip(tooltip);\n        }\n\n    }\n    var onLassoStart = function (lasso, chart) {\n        return function () {\n            if (filter) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', true)\n                    .classed('selected', false);\n            }\n        }\n    }\n\n    var onLassoDraw = function (lasso, chart) {\n        return function () {\n            filter = true;\n            lasso.items().selectAll('rect')\n                .classed('selected', false);\n\n            lasso.possibleItems().selectAll('rect')\n                .classed('not_possible', false)\n                .classed('possible', true);\n\n            lasso.notPossibleItems().selectAll('rect')\n                .classed('not_possible', true)\n                .classed('possible', false);\n        }\n    }\n\n    var onLassoEnd = function (lasso, chart) {\n        return function () {\n            var data = lasso.selectedItems().data();\n            debugger\n            if (!filter) {\n                return;\n            }\n            if (data.length > 0) {\n                lasso.items().selectAll('rect')\n                    .classed('not_possible', false)\n                    .classed('possible', false);\n            }\n\n            lasso.selectedItems().selectAll('rect')\n                .classed('selected', true)\n\n            lasso.notSelectedItems().selectAll('rect');\n\n            var confirm = d3.select('.confirm')\n                .style('visibility', 'visible');\n\n            var _filter = [];\n            if (data.length > 0) {\n                data.forEach(function (d) {\n                    if (d.children != undefined) {\n                        for (var index = 0; index < d.data.values.length; index++) {\n\n                            var isExist = _filter.filter(function (val) {\n                                if (val[_dimension[1]] == d.data.key) {\n                                    return val\n                                }\n                            })\n                            if (isExist.length == 0) {\n                                var searchObj = _localData.find(o => o[_dimension[1]] === d.data.values[index].key);\n\n                                var isExist = _filter.filter(function (val) {\n                                    if (val[_dimension[0]] == searchObj[_dimension[0]] && val[_dimension[1]] == searchObj[_dimension[1]]) {\n                                        return val\n                                    }\n                                })\n                                if (isExist.length == 0) {\n                                    _filter.push(searchObj);\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        var isExist = filterData.filter(function (val) {\n                            if (val[_dimension[0]] == d[_dimension[0]]) {\n                                return val\n                            }\n                        })\n                        if (isExist.length == 0) {\n                            filterData.push(_filter[0]);\n                        }\n                    }\n                })\n                if (_filter.length > 0) {\n                    filterData = _filter;\n                }\n            }\n        }\n    }\n    var applyFilter = function (chart) {\n        return function () {\n            if (filterData.length > 0) {\n                chart.update(filterData);\n            }\n        }\n    }\n\n    var clearFilter = function () {\n        return function () {\n            chart.update(_originalData);\n        }\n    }\n\n    var drawViz = function (element) {\n        var rect = element.append('rect')\n            .attr('rx', 5)\n            .attr('ry', 5)\n            .attr('class', 'treeRect')\n            .attr('width', function (d) {\n                return d.x1 - d.x0;\n            })\n            .attr('height', function (d) {\n                return d.y1 - d.y0;\n            })\n            .attr('fill', function (d, i) {\n                return getFillColor(d, i);\n            })\n            .attr('stroke', function (d, i) {\n                return getFillColor(d, i);\n            })\n            .style('stroke-width', 2)\n            .attr('id', function (d, i) {\n                return 'rect-' + i;\n            })\n            .on('mouseover', _handleMouseOverFn.call(chart, tooltip, _local_svg))\n            .on('mousemove', _handleMouseMoveFn.call(chart, tooltip, _local_svg))\n            .on('mouseout', _handleMouseOutFn.call(chart, tooltip, _local_svg))\n            .on('click', function (d) {\n\n                var confirm = d3.select('.confirm')\n                    .style('visibility', 'visible');\n                var _filter = _localData.filter(function (d1) {\n                    return d.data.key === d1[_dimension[1]]\n                })\n                var rect = d3.select(this);\n                if (rect.classed('selected')) {\n                    rect.classed('selected', false);\n                    filterData.map(function (val, i) {\n                        if (val[_dimension[0]] == d[_dimension[0]]) {\n                            filterData.splice(i, 1)\n                        }\n                    })\n                } else {\n                    rect.classed('selected', true);\n                    if (d.children != undefined) {\n                        for (var index = 0; index < d.data.values.length; index++) {\n\n                            var isExist = filterData.filter(function (val) {\n                                if (val[_dimension[1]] == d.data.key) {\n                                    return val\n                                }\n                            })\n                            if (isExist.length == 0) {\n                                var searchObj = _localData.find(o => o[_dimension[1]] === d.data.values[index].key);\n\n\n                                var isExist = filterData.filter(function (val) {\n                                    if (val[_dimension[0]] == searchObj[_dimension[0]] && val[_dimension[1]] == searchObj[_dimension[1]]) {\n                                        return val\n                                    }\n                                })\n                                if (isExist.length == 0) {\n                                    filterData.push(searchObj);\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        var isExist = filterData.filter(function (val) {\n                            if (val[_dimension[0]] == d[_dimension[0]]) {\n                                return val\n                            }\n                        })\n                        if (isExist.length == 0) {\n                            filterData.push(_filter[0]);\n                        }\n                    }\n\n                }\n            })\n\n        rect.transition(t)\n            .attr('width', function (d) {\n                return d.x1 - d.x0;\n            })\n            .attr('height', function (d) {\n                return d.y1 - d.y0;\n            })\n            .attr('fill', function (d, i) {\n                return getFillColor(d, i)\n            });\n\n        function afterTransition() {\n            element.filter(function (d, i) { return d.parent; })\n                .append('text')\n                .attr('class', 'information')\n                .selectAll('tspan')\n                .data(function (d, i) {\n                    return getFilterLabels(d);\n                })\n                .enter().append('tspan')\n                .attr('x', function (d, i) {\n                    return i ? null : 2;\n                })\n                .attr('y', '1em')\n                .text(function (d, i) {\n                    return i ? '- ' + d.data : d.data;\n                })\n                .attr('fill', function (d, i) {\n                    return getColorValue(d, i);\n                })\n                .attr('visibility', function (d, i) {\n                    var parentNode = d3.select(this).node().parentNode;\n                    return getVisibilityValue(parentNode, d.node);\n                })\n                .style('font-style', function (d, i) {\n                    return getFontStyleValue(d, i);\n                })\n                .style('font-weight', function (d, i) {\n                    return getFontWeightValue(d, i);\n                })\n                .style('font-size', function (d, i) {\n                    return getFontSizeValue(d, i);\n                });\n        }\n\n        var t = d3.transition()\n            .duration(400)\n            .ease(d3.easeQuadIn)\n            .on('end', afterTransition);\n    }\n    function chart(selection) {\n        _localSVG = selection;\n\n        selection.each(function (data) {\n\n            var div = d3.select(this).node().parentNode;\n            _local_svg = d3.select(this);\n\n            width = div.clientWidth - 2 * COMMON.PADDING,\n                height = div.clientHeight - 2 * COMMON.PADDING;\n\n            var svg = d3.select(this);\n\n            /* store the data in local variable */\n            _localData = _originalData = data;\n\n            var me = this;\n\n            svg.selectAll('g').remove();\n\n            svg.attr('width', width)\n                .attr('height', height)\n                .attr('transform', 'translate(' + COMMON.PADDING + ', ' + COMMON.PADDING + ')');\n\n            if (_tooltip) {\n                tooltip = d3.select(this.parentNode).select('#tooltip');\n            }\n\n            treemap = d3.treemap()\n                .size([width, height])\n                .paddingOuter(function (node) {\n                    if (node.parent) {\n                        return 5;\n                    }\n                    return 1;\n                })\n                .paddingTop(function (node) {\n                    if (node.parent) {\n                        return 20;\n                    }\n                    return 0;\n                })\n                .paddingInner(10)\n                .round(true);\n\n            if (_dimension.length == 2) {\n                nest = this._nest = d3.nest()\n                    .key(function (d) { return d[_dimension[0]]; })\n                    .key(function (d) { return d[_dimension[1]]; })\n                    .rollup(function (d) { return d3.sum(d, function (d) { return d[_measure[0]]; }); });\n            } else {\n                nest = this._nest = d3.nest()\n                    .key(function (d) { return d[_dimension[0]]; })\n                    .rollup(function (d) { return d3.sum(d, function (d) { return d[_measure[0]]; }); });\n            }\n\n            root = d3.hierarchy({ values: nest.entries(data) }, function (d) { return d.values; })\n                .sum(function (d) { return d.value; })\n                .sort(function (a, b) { return b.value - a.value; });\n\n            _localTotal = root.value;\n\n            treemap(root);\n\n            var dim = _dimension.length;\n\n            while (dim > 0) {\n                setColorDomainRange(root.descendants(), dim);\n                dim -= 1;\n            }\n            var plot = svg.append('g')\n                .attr('class', 'plot');\n\n            var cell = plot.selectAll('.node')\n                .data(root.descendants())\n                .enter().append('g')\n                .attr('transform', function (d) {\n                    return 'translate(' + d.x0 + ',' + d.y0 + ')';\n                })\n                .attr('class', 'node')\n                .each(function (d) { d.node = this; });\n\n            drawViz(cell)\n\n            d3.select(div).select('.btn-primary')\n                .on('click', applyFilter(chart));\n\n            d3.select(div).select('.btn-default')\n                .on('click', clearFilter());\n\n            var lasso = d3.lasso()\n                .hoverSelect(true)\n                .closePathSelect(true)\n                .closePathDistance(100)\n                .items(cell)\n                .targetArea(svg);\n\n            lasso.on('start', onLassoStart(lasso, chart))\n                .on('draw', onLassoDraw(lasso, chart))\n                .on('end', onLassoEnd(lasso, chart));\n\n            _local_svg.call(lasso);\n\n        });\n    }\n\n    chart._getName = function () {\n        return _NAME;\n    }\n\n    chart.update = function (data) {\n        _Local_data = data;\n        filterData = [];\n\n        if (_dimension.length == 2) {\n            nest = this._nest = d3.nest()\n                .key(function (d) { return d[_dimension[0]]; })\n                .key(function (d) { return d[_dimension[1]]; })\n                .rollup(function (d) { return d3.sum(d, function (d) { return d[_measure[0]]; }); });\n        } else {\n            nest = this._nest = d3.nest()\n                .key(function (d) { return d[_dimension[0]]; })\n                .rollup(function (d) { return d3.sum(d, function (d) { return d[_measure[0]]; }); });\n        }\n\n        root = d3.hierarchy({ values: nest.entries(data) }, function (d) { return d.values; })\n            .sum(function (d) { return d.value; })\n            .sort(function (a, b) { return b.value - a.value; });\n\n        _localTotal = root.value;\n\n        treemap(root);\n\n        var dim = _dimension.length;\n\n        while (dim > 0) {\n            setColorDomainRange(root.descendants(), dim);\n            dim -= 1;\n        }\n        var svg = _localSVG\n        treemap(root);\n        var dim = _dimension.length;\n        var plot = _localSVG.select('.plot');\n\n        plot.selectAll('.information').remove();\n        while (dim > 0) {\n            setColorDomainRange(root.descendants(), dim);\n            dim -= 1;\n        }\n\n        var cell = plot.selectAll('.node')\n            .data(root.descendants())\n            .each(function (d) { d.node = this; });\n\n        var newCell = cell.enter().append('g')\n            .attr('class', 'node')\n            .attr('transform', function (d) {\n                return 'translate(' + d.x0 + ',' + d.y0 + ')';\n            });\n\n        drawViz(newCell)\n\n        cell.exit().remove();\n\n        cell = plot.selectAll('.node');\n\n        var rect = cell.select('rect')\n            .attr('rx', 5)\n            .attr('ry', 5)\n            .attr('width', function (d) {\n                return d.x1 - d.x0;\n            })\n            .attr('height', function (d) {\n                return d.y1 - d.y0;\n            })\n            .attr('fill', function (d, i) {\n                return getFillColor(d, i);\n            })\n            .attr('stroke', function (d, i) {\n                return getFillColor(d, i);\n            })\n            .style('stroke-width', 2)\n            .classed('selected', false)\n            .attr('id', function (d, i) {\n                return 'rect-' + i;\n            })\n\n        cell.filter(function (d, i) { return d.parent; })\n            .append('text')\n            .attr('class', 'information')\n            .selectAll('tspan')\n            .data(function (d, i) {\n                return getFilterLabels(d);\n            })\n            .enter().append('tspan')\n            .attr('x', function (d, i) {\n                return i ? null : 2;\n            })\n            .attr('y', '1em')\n            .text(function (d, i) {\n                return i ? '- ' + d.data : d.data;\n            })\n            .attr('fill', function (d, i) {\n                return getColorValue(d, i);\n            })\n            .attr('visibility', function (d, i) {\n                var parentNode = d3.select(this).node().parentNode;\n                return getVisibilityValue(parentNode, d.node);\n            })\n            .style('font-style', function (d, i) {\n                return getFontStyleValue(d, i);\n            })\n            .style('font-weight', function (d, i) {\n                return getFontWeightValue(d, i);\n            })\n            .style('font-size', function (d, i) {\n                return getFontSizeValue(d, i);\n            });\n\n        plot.selectAll('.node')\n            .attr('transform', function (d) {\n                return 'translate(' + d.x0 + ',' + d.y0 + ')';\n            })\n\n    }\n\n    chart.config = function (value) {\n        if (!arguments.length) {\n            return _config;\n        }\n        _config = value;\n        _setConfigParams.call(chart, _config);\n        return chart;\n    }\n\n    chart.dimension = function (value) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = value;\n        return chart;\n    }\n\n    chart.measure = function (value) {\n        if (!arguments.length) {\n            return _measure;\n        }\n        _measure = value;\n        return chart;\n    }\n\n    chart.showLabel = function (value) {\n        if (!arguments.length) {\n            return showLabel;\n        }\n        showLabel = value;\n        return chart;\n    }\n    chart.colorPattern = function (value) {\n        if (!arguments.length) {\n            return colorPattern;\n        }\n        colorPattern = value;\n        return chart;\n    }\n    chart.showValues = function (value) {\n        if (!arguments.length) {\n            return showValues;\n        }\n        showValues = value;\n        return chart;\n    }\n    chart.valueTextColour = function (value) {\n        if (!arguments.length) {\n            return valueTextColour;\n        }\n        valueTextColour = value;\n        return chart;\n    }\n    chart.fontStyleForMes = function (value) {\n        if (!arguments.length) {\n            return fontStyleForMes;\n        }\n        valueTextColour = value;\n        return chart;\n    }\n    chart.fontWeightForMes = function (value) {\n        if (!arguments.length) {\n            return fontWeightForMes;\n        }\n        fontWeightForMes = value;\n        return chart;\n    }\n    chart.fontSizeForMes = function (value) {\n        if (!arguments.length) {\n            return fontSizeForMes;\n        }\n        fontSizeForMes = value;\n        return chart;\n    }\n    chart.numberFormat = function (value) {\n        if (!arguments.length) {\n            return numberFormat;\n        }\n        numberFormat = value;\n        return chart;\n    }\n\n    /**\n     * ClusteredVerticalBar Measure Showvalue accessor function\n     *\n     * @param {boolean|array(boolean)|null} value Measure Showvalue value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {boolean|array(boolean)|function}\n     */\n    chart.showLabelForDimension = function (value, measure) {\n        return UTIL.baseAccessor.call(showLabelForDimension, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure Displayname accessor function\n     *\n     * @param {string|array(string)|null} value Measure Displayname value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.labelColorForDimension = function (value, measure) {\n        return UTIL.baseAccessor.call(labelColorForDimension, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure FontStyle accessor function\n     *\n     * @param {string|array(string)|null} value Measure FontStyle value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.displayColor = function (value, measure) {\n        return UTIL.baseAccessor.call(displayColor, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure FontWeight accessor function\n     *\n     * @param {number|array(number)|null} value Measure FontWeight value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {number|array(number)|function}\n     */\n    chart.fontStyleForDimension = function (value, measure) {\n        return UTIL.baseAccessor.call(fontStyleForDimension, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure FontSize accessor function\n     *\n     * @param {number|array(number)|null} value Measure FontSize value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {number|array(number)|function}\n     */\n    chart.fontWeightForDimension = function (value, measure) {\n        return UTIL.baseAccessor.call(fontWeightForDimension, value, measure, _measure);\n    }\n\n    /**\n     * ClusteredVerticalBar Measure NumberFormat accessor function\n     *\n     * @param {string|array(string)|null} value Measure NumberFormat value for the measure(s)\n     * @param {string|null} measure Measure for which the value is to be set or retrieved\n     * @return {string|array(string)|function}\n     */\n    chart.fontSizeForDimension = function (value, measure) {\n        return UTIL.baseAccessor.call(fontSizeForDimension, value, measure, _measure);\n    }\n\n    chart.tooltip = function (value) {\n        if (!arguments.length) {\n            return _tooltip;\n        }\n        _tooltip = value;\n        return chart;\n    }\n\n    return chart;\n}\n\nmodule.exports = treemap;\n\n\n//# sourceURL=webpack://flairVisualizations/./js/charts/treemap.js?");

/***/ }),

/***/ "./js/extras/common.js":
/*!*****************************!*\
  !*** ./js/extras/common.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function common() {\n    return {\n        MARGIN: 15,\n        PADDING: 15,\n        OFFSET: 10,\n        DEFAULT_FONTSTYLE: 'normal',\n        DEFAULT_FONTSIZE: '60px',\n        DEFAULT_FONTWEIGHT: 200,\n        DEFAULT_COLOR: '#DC1C50',\n        LEGEND_COLOR: '#6B6A5D',\n        HIGHLIGHTER: '#DCDCDC',\n        BORDER_RADIUS: 5,\n        DURATION: 1000,\n        AXIS_THICKNESS: 50,\n        COLORSCALE: d3.scaleOrdinal()\n            .range(['#4897D8',\n                '#ED5752',\n                '#5BC8AC',\n                '#20948B',\n                '#9A9EAB',\n                '#755248',\n                '#FA6E59',\n                '#CF3721',\n                '#31A9B8',\n                '#F1F3CE',\n                '#34675C',\n                '#AF4425'\n                ])\n    }\n}\n\nmodule.exports = common;\n\n//# sourceURL=webpack://flairVisualizations/./js/extras/common.js?");

/***/ }),

/***/ "./js/extras/legend.js":
/*!*****************************!*\
  !*** ./js/extras/legend.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var COMMON = __webpack_require__(/*! ../extras/common.js */ \"./js/extras/common.js\")();\n\nfunction legend() {\n    return function(data, selection, extraParams) {\n        if(extraParams.labelStack == void 0) {\n            extraParams.labelStack = [];\n        }\n\n        var me = this;\n\n        var width = 12,\n            height = 12;\n\n        var legend = selection.append('g')\n            .attr('id', function() {\n                return me._getName() + '-legend';\n            })\n            .attr('class', 'legend')\n            .attr('display', 'block');\n\n        var legendItem = legend.selectAll('.item')\n            .data(data)\n            .enter().append('g')\n                .attr('class', 'item')\n                .attr('id', function(d, i) {\n                    return me._getName() + '-legend-item' + i;\n                })\n                .attr('transform', function(d, i) {\n                    var translate = [0, 0];\n\n                    switch(me.legendPosition()) {\n                        case 'top':\n                            translate = [i * Math.floor(extraParams.width/data.length), 0];\n                            break;\n                        case 'bottom':\n                            translate = [i * Math.floor(extraParams.width/data.length), (extraParams.height - COMMON.PADDING)];\n                            break;\n                        case 'right':\n                            translate = [(4 / 5) * extraParams.width, i * 20];\n                            break;\n                        case 'left':\n                            translate = [0, i * 20];\n                    }\n\n                    return 'translate(' + translate.toString() + ')';\n                })\n                .on('mouseover', function(d, i) {\n                    d3.select(this).attr('cursor', 'pointer');\n                    me._legendInteraction('mouseover', d);\n                })\n                .on('mousemove', function(d, i) {\n                    d3.select(this).attr('cursor', 'pointer');\n                    me._legendInteraction('mousemove', d);\n                })\n                .on('mouseout', function(d, i) {\n                    d3.select(this).attr('cursor', 'default');\n                    me._legendInteraction('mouseout', d);\n                })\n                .on('click', function(d, i) {\n                    var rect = d3.select(this).select('rect'),\n                        o = parseInt(rect.style('fill-opacity'));\n\n                    if(!o) {\n                        rect.style('fill-opacity', 1)\n                            .style('stroke-width', 0);\n                    } else {\n                        rect.style('fill-opacity', 0)\n                            .style('stroke-width', 1);\n                    }\n\n                    me._legendInteraction('click', d);\n                });\n\n        legendItem.append('rect')\n            .attr('width', width)\n            .attr('height', height)\n            .style('fill', function(d, i) {\n                if(typeof d == 'string') {\n                    return COMMON.COLORSCALE(d);\n                }\n                return COMMON.COLORSCALE(d[me.dimension()]);\n            })\n            .style('fill-opacity', function(d, i) {\n                if(typeof d == 'string') {\n                    return extraParams.labelStack.indexOf(d) == -1 ? 1 : 0;\n                }\n                return extraParams.labelStack.indexOf(d[me.dimension()]) == -1 ? 1 : 0;\n            })\n            .style('stroke', function(d, i) {\n                if(typeof d == 'string') {\n                    return COMMON.COLORSCALE(d);\n                }\n                return COMMON.COLORSCALE(d[me.dimension()]);\n            })\n            .style('stroke-width', function(d, i) {\n                if(typeof d == 'string') {\n                    return extraParams.labelStack.indexOf(d) == -1 ? 1 : 0;\n                }\n                return extraParams.labelStack.indexOf(d[me.dimension()]) == -1 ? 0 : 1;\n            }),\n\n        legendItem.append('text')\n            .attr('x', 18)\n            .attr('y', 10)\n            .text(function(d) {\n                if(typeof d == 'string') {\n                    return d;\n                }\n                return d[me.dimension()];\n            })\n            .style('fill', COMMON.LEGEND_COLOR)\n            .style('font-weight', 'bold')\n\n        var legendWidth = legend.node().getBBox().width,\n            legendHeight = legend.node().getBBox().height;\n\n        legendItem.attr('transform', function(d, i) {\n            var translate = [0, 0];\n\n            switch(me.legendPosition()) {\n                case 'top':\n                    translate = [i * Math.floor(extraParams.width/data.length), 0];\n                    break;\n                case 'bottom':\n                    translate = [i * Math.floor(extraParams.width/data.length), (extraParams.height - COMMON.PADDING)];\n                    break;\n                case 'right':\n                    /* For pie and doughnut chart vertically center the legend items */\n                    if(me._getName() == 'pie' || me._getName() == 'doughnut') {\n                        translate = [(4 / 5) * extraParams.width, ((extraParams.height / 2) - (legendHeight / 2) + i * 20)];\n                    } else {\n                        translate = [(extraParams.width - legendWidth), i * 20];\n                    }\n                    break;\n                case 'left':\n                    /* For pie and doughnut chart vertically center the legend items */\n                    if(me._getName() == 'pie' || me._getName() == 'doughnut') {\n                        translate = [0, ((extraParams.height / 2) - (legendHeight / 2) + i * 20)];\n                    } else {\n                        translate = [0, i * 20];\n                    }\n            }\n\n            return 'translate(' + translate.toString() + ')';\n        });\n\n        return {\n            legendWidth: legendWidth,\n            legendHeight: legendHeight\n        }\n    }\n}\n\nmodule.exports = legend;\n\n//# sourceURL=webpack://flairVisualizations/./js/extras/legend.js?");

/***/ }),

/***/ "./js/extras/util.js":
/*!***************************!*\
  !*** ./js/extras/util.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function util() {\n\n    var _verifyPrecision = function(precision) {\n        if(precision < 0 || precision > 20) {\n            throw new RangeError('Formatter precision must be between 0 and 20');\n        }\n        if(precision !== Math.floor(precision)) {\n            throw new RangeError('Formatter precision must be an integer');\n        }\n    }\n\n    var _boundTooltip = function(container, tooltip) {\n        var left = container.offsetLeft,\n            width = container.offsetWidth,\n            height = container.offsetHeight,\n            top = 0;\n\n        var tipLeft = tooltip.offsetLeft,\n            tipWidth = tooltip.offsetWidth,\n            tipHeight = tooltip.offsetHeight,\n            tipTop = tooltip.offsetTop;\n\n        if(tipLeft < left) {\n            tooltip.style.left = left + \"px\";\n        }\n\n        if(tipLeft + tipWidth > left + width) {\n            tooltip.style.left = (left + width - tipWidth) + 'px';\n        }\n\n        if(tipTop < top) {\n            tooltip.style.top = top + \"px\";\n        }\n\n        if(tipTop + tipHeight > top + height) {\n            tooltip.style.top = (top + height - tipHeight) + 'px';\n        }\n    }\n\n    var publicMethods = {\n\n        ASCENDING: 1,\n        DESCENDING: -1,\n\n        showTooltip: function(tooltip) {\n            if(tooltip) tooltip.style('visibility', 'visible');\n        },\n\n        updateTooltip: function(data, container) {\n            var pt = d3.mouse(container.node()),\n                x = pt[0] + 15,\n                y = pt[1] + 20;\n\n            this.style('top', y + 'px')\n                .style('left', x + 'px')\n                .html(data);\n\n            _boundTooltip(container.node(), this.node());\n        },\n\n        hideTooltip: function(tooltip) {\n            if(tooltip) tooltip.style('visibility', 'hidden');\n        },\n\n        /**\n         * Sorts the data based upon the order and keys\n         *\n         * @param {array} data Array of objects that needs to be sorted\n         * @param {array} keys Array of string (key) that will be used for sorting\n         * @param {string} order 'Ascending' or 'Descending' order of sort\n         * @return {null}\n         */\n        sorter: function(data, keys, order) {\n            var _sorter = function(x, y, index) {\n                if(typeof(keys[index]) == 'undefined') {\n                    return 0;\n                }\n\n                return +x[keys[index]] > +y[keys[index]] ? -1\n                    : +x[keys[index]] < +y[keys[index]] ? 1\n                    : _sorter(x, y, index + 1);\n            }\n\n            /* sort ascending */\n            if(order === 1) {\n                data.sort(function(x, y) {\n                    return _sorter(y, x, 0);\n                });\n            }\n            /* sort descending */\n            else if(order === -1) {\n                data.sort(function(x, y) {\n                    return _sorter(x, y, 0);\n                });\n            }\n        },\n\n        /**\n         * Sorts the data based upon the order and keys\n         *\n         * @param {array} data Array of objects that needs to be sorted\n         * @param {array} keys Array of string (key) that will be used for sorting\n         * @param {string} order 'Ascending' or 'Descending' order of sort\n         * @return {null}\n         */\n        getTruncatedLabel: function(element, label, containerLength, offset) {\n            if(typeof(label) === 'undefined') {\n                return \"\";\n            }\n\n            if(label === null) {\n                label = \"null\";\n            }\n\n            label = label.toString();\n\n            if(offset === void 0) {\n                offset = 0;\n            }\n\n            offset += 3;\n\n            var truncLabel = label,\n                arr = label.split('');\n\n            if(containerLength < element.getComputedTextLength()) {\n                var charLength = parseInt(containerLength * element.getNumberOfChars()/element.getComputedTextLength()) - offset;\n                charLength = (charLength < 0) ? 0 : charLength;\n                truncLabel = arr.splice(0, charLength).join('') + '...';    \n            }\n\n            return truncLabel;\n        },\n\n        /**\n         * Provides D3's number formatting function\n         *\n         * @param {string} si Type of Number format to be used\n         * @return {function}\n         */\n        getNumberFormatterFn: function(si) {\n            if(si === void 0) {\n                si = \"actual\";\n            }\n            si = si.toLowerCase();\n\n            var result;\n\n            var siMapper = {\n                'k': '1e3',\n                'm': '1e6',\n                'b': '1e9',\n            };\n\n            switch(si) {\n                case \"actual\":\n                    result = d3.format('');\n                    break;\n                case \"percent\":\n                    result = d3.format('.0%');\n                    break;\n                default:\n                    result = d3.formatPrefix(',.2s', siMapper[si] || '1e6');\n                    break;\n            }\n\n            return result;\n        },\n\n        /**\n         * Rounds a number to a given number of digits\n         *\n         * @param {array} data Array of objects that needs to be sorted\n         * @param {array} keys Array of string (key) that will be used for sorting\n         * @param {string} order 'Ascending' or 'Descending' order of sort\n         * @return {null}\n         */\n        roundNumber: function(num, scale) {\n            if(typeof(scale) == 'undefined') {\n                throw new Error('Scale is not specified');\n            }\n\n            var exp1 = \"e+\" + scale,\n                exp2 = \"e-\" + scale;\n\n            return +(Math.round(num + exp1) + exp2);\n        },\n\n        /**\n         * Provides config format of a string expression \n         *\n         * @param {string} expression The expression which is to be transformed to the config\n         * @param {array} args Array of string for which will be the properties for the config\n         * @return {array(object)}\n         */\n        getExpressionConfig: function(expression, args) {\n            var config = [],\n                temp,\n                obj;\n\n            if(!expression || !args.length) {\n                return [];\n            }\n\n            try {\n                expression = expression.split('|');\n\n                expression.forEach(function(item) {\n                    obj = {};\n                    temp = item.split(',').map(function(c) { return c.trim(); });\n                    obj[temp[0].toLowerCase()] = parseInt(temp[1]) || null;\n                    args.forEach(function(arg, i) {\n                        obj[arg] = temp[i + 2];\n                    });\n                    config.push(obj);\n                });\n            } catch(e) {\n                console.error(e);\n                throw new Error('Invalid expression format');\n            }\n\n            return config;\n        },\n\n        /**\n         * Retrives property value inside the expression based upon the given criteria\n         *\n         * @param {array(object)} expression The expression which is to be evaluated\n         * @param {number} value The value whose placement is to be identified \n         * @param {string} key The property that is being evaluated\n         * @return {string|number}\n         */\n        expressionEvaluator: function(expression, value, key) {\n            var result = expression.filter(function(t) {\n                    return t.hasOwnProperty('default');\n                });\n\n            if(result.length) {\n                result = result[0][key];\n            }\n\n            for(var i=0; i<expression.length; i++) {\n                var property = expression[i];\n                if(property.hasOwnProperty('upto')) {\n                    if(value <= property.upto) {\n                        result = property[key];\n                        break;\n                    }\n                } else if(property.hasOwnProperty('above')) {\n                    if(value > property.above) {\n                        result = property[key];\n                        break;\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         * Base accessor function\n         *\n         * @param {string|array(string)|null} value \"this\" value for the measure(s)\n         * @param {string|null} measure Measure for which the value is to be set or retrieved\n         * @param {array(string)} measures All the available measures\n         * @return {string|array(string)|function}\n         */\n        baseAccessor: function(value, measure, measures) {\n            var me = this;\n\n            if(!arguments.length) {\n                /**\n                 * Getter method call with no arguments\n                 * E.g. <chart>.<accessor_function>() ==> [<item1>, <item2>]\n                 */\n                return me;\n            }\n\n            if(value != void 0 && measure == void 0) {\n                /**\n                 * Setter method call with only value argument\n                 * E.g. <chart>.<accessor_function>([<item1>, <item2>]) ==> <chart_function>\n                 */\n                if(value instanceof Array) {\n                    me.splice(0, me.length);\n                } else {\n                    value = measures.map(function(i) { return value; });\n                }\n\n                me.push.apply(me, value);\n                return chart;\n            }\n\n            var index = measures.indexOf(measure);\n\n            if(index === -1) {\n                throw new Error('Invalid measure provided');\n            }\n\n            if(value == void 0) {\n                /**\n                 * Getter method call with only measure argument\n                 * E.g. <chart>.<accessor_function>(<measure>) ==> <item>\n                 */\n                return me[index];\n            } else {\n                /**\n                 * Setter method call with both value and measure arguments\n                 * E.g. <chart>.<accessor_function>(<item>, <measure>) ==> <chart_function>\n                 */\n                me[index] = value;\n            }\n\n            return chart;\n        },\n\n        shortScale: function(precision) {\n            if (precision === void 0) { precision = 3; }\n            _verifyPrecision(precision);\n            \n            var suffixes = \"KMBTQ\";\n            var fixedFormatter = d3.format(\".\" + precision + \"f\");\n            var exponentFormatter = d3.format(\".\" + precision + \"e\");\n            \n            var max = Math.pow(10, (3 * (suffixes.length + 1)));\n            var min = Math.pow(10, -precision);\n            return function (num) {\n                var absNum = Math.abs(num);\n                if ((absNum < min || absNum >= max) && absNum !== 0) {\n                    return exponentFormatter(num);\n                }\n                var idx = -1;\n                while (absNum >= Math.pow(1000, idx + 2) && idx < (suffixes.length - 1)) {\n                    idx++;\n                }\n                var output = \"\";\n                if (idx === -1) {\n                    output = fixedFormatter(num);\n                    output = parseFloat(output).toString();\n                }\n                else {\n                    output = fixedFormatter(num / Math.pow(1000, idx + 1));\n                    output = parseFloat(output) + suffixes[idx];\n                }\n\n                if ((num > 0 && output.substr(0, 4) === \"1000\") || (num < 0 && output.substr(0, 5) === \"-1000\")) {\n                    if (idx < suffixes.length - 1) {\n                        idx++;\n                        output = fixedFormatter(num / Math.pow(1000, idx + 1));\n                        output = parseFloat(output) + suffixes[idx];\n                    }\n                    else {\n                        output = exponentFormatter(num);\n                    }\n                }\n                return output;\n            };\n        }\n    }\n\n    return publicMethods;\n\n}\n\nmodule.exports = util;\n\n//# sourceURL=webpack://flairVisualizations/./js/extras/util.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Load the required JS files\nvar clusteredverticalbar = __webpack_require__(/*! ./charts/clusteredverticalbar.js */ \"./js/charts/clusteredverticalbar.js\");\nvar combo = __webpack_require__(/*! ./charts/combo.js */ \"./js/charts/combo.js\");\nvar donut = __webpack_require__(/*! ./charts/donut.js */ \"./js/charts/donut.js\");\nvar heatmap = __webpack_require__(/*! ./charts/heatmap.js */ \"./js/charts/heatmap.js\");\nvar infographics = __webpack_require__(/*! ./charts/infographics.js */ \"./js/charts/infographics.js\");\nvar kpi = __webpack_require__(/*! ./charts/kpi.js */ \"./js/charts/kpi.js\");\nvar line = __webpack_require__(/*! ./charts/line.js */ \"./js/charts/line.js\");\nvar pie = __webpack_require__(/*! ./charts/pie.js */ \"./js/charts/pie.js\");\nvar pivot = __webpack_require__(/*! ./charts/pivottable.js */ \"./js/charts/pivottable.js\");\nvar scatter = __webpack_require__(/*! ./charts/scatter.js */ \"./js/charts/scatter.js\");\nvar stackedhorizontalbar = __webpack_require__(/*! ./charts/stackedhorizontalbar.js */ \"./js/charts/stackedhorizontalbar.js\");\nvar stackedverticalbar = __webpack_require__(/*! ./charts/stackedverticalbar.js */ \"./js/charts/stackedverticalbar.js\");\nvar table = __webpack_require__(/*! ./charts/table.js */ \"./js/charts/table.js\");\nvar treemap = __webpack_require__(/*! ./charts/treemap.js */ \"./js/charts/treemap.js\");\n\n// Load the required CSS files\n__webpack_require__(/*! ../styles/stylesheets/screen.css */ \"./styles/stylesheets/screen.css\");\n\nmodule.exports = {\n\tclusteredverticalbar: clusteredverticalbar,\n\tcombo: combo,\n\tdonut: donut,\n\theatmap: heatmap,\n\tinfographics: infographics,\n\tkpi: kpi,\n\tline: line,\n\tpie: pie,\n\tpivot: pivot,\n\tscatter: scatter,\n\tstackedhorizontalbar: stackedhorizontalbar,\n\tstackedverticalbar: stackedverticalbar,\n\ttable: table,\n\ttreemap: treemap\n};\n\n\n//# sourceURL=webpack://flairVisualizations/./js/main.js?");

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/json/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/json/stringify.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = { \"default\": __webpack_require__(/*! core-js/library/fn/json/stringify */ \"./node_modules/core-js/library/fn/json/stringify.js\"), __esModule: true };\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/babel-runtime/core-js/json/stringify.js?");

/***/ }),

/***/ "./node_modules/core-js/library/fn/json/stringify.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/json/stringify.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var core = __webpack_require__(/*! ../../modules/_core */ \"./node_modules/core-js/library/modules/_core.js\");\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/core-js/library/fn/json/stringify.js?");

/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var core = module.exports = { version: '2.6.5' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/core-js/library/modules/_core.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./styles/stylesheets/screen.css":
/*!*****************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./styles/stylesheets/screen.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Imports\nvar urlEscape = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/url-escape.js */ \"./node_modules/css-loader/dist/runtime/url-escape.js\");\nvar ___CSS_LOADER_URL___0___ = urlEscape(__webpack_require__(/*! ../../fonts/FiraSansExtraCondensed-Light.ttf */ \"./fonts/FiraSansExtraCondensed-Light.ttf\"));\nvar ___CSS_LOADER_URL___1___ = urlEscape(__webpack_require__(/*! ../../fonts/FiraSansExtraCondensed-Regular.ttf */ \"./fonts/FiraSansExtraCondensed-Regular.ttf\"));\nvar ___CSS_LOADER_URL___2___ = urlEscape(__webpack_require__(/*! ../../fonts/FiraSansExtraCondensed-SemiBold.ttf */ \"./fonts/FiraSansExtraCondensed-SemiBold.ttf\"));\nvar ___CSS_LOADER_URL___3___ = urlEscape(__webpack_require__(/*! ../../fonts/FiraSansExtraCondensed-Bold.ttf */ \"./fonts/FiraSansExtraCondensed-Bold.ttf\"));\n\n// Module\nexports.push([module.i, \"/* Welcome to Compass.\\n * In this file you should write your main styles. (or centralize your imports)\\n * Import this file using the following HTML or equivalent:\\n * <link href=\\\"/stylesheets/screen.css\\\" media=\\\"screen, projection\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\" /> */\\n/* line 5, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\nhtml, body, div, span, applet, object, iframe,\\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\\na, abbr, acronym, address, big, cite, code,\\ndel, dfn, em, img, ins, kbd, q, s, samp,\\nsmall, strike, strong, sub, sup, tt, var,\\nb, u, i, center,\\ndl, dt, dd, ol, ul, li,\\nfieldset, form, label, legend,\\ntable, caption, tbody, tfoot, thead, tr, th, td,\\narticle, aside, canvas, details, embed,\\nfigure, figcaption, footer, header, hgroup,\\nmenu, nav, output, ruby, section, summary,\\ntime, mark, audio, video {\\n  margin: 0;\\n  padding: 0;\\n  border: 0;\\n  font: inherit;\\n  font-size: 100%;\\n  vertical-align: baseline;\\n}\\n\\n/* line 22, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\nhtml {\\n  line-height: 1;\\n}\\n\\n/* line 24, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\nol, ul {\\n  list-style: none;\\n}\\n\\n/* line 26, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\ntable {\\n  border-collapse: collapse;\\n  border-spacing: 0;\\n}\\n\\n/* line 28, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\ncaption, th, td {\\n  text-align: left;\\n  font-weight: normal;\\n  vertical-align: middle;\\n}\\n\\n/* line 30, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\nq, blockquote {\\n  quotes: none;\\n}\\n/* line 103, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\nq:before, q:after, blockquote:before, blockquote:after {\\n  content: \\\"\\\";\\n  content: none;\\n}\\n\\n/* line 32, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\na img {\\n  border: none;\\n}\\n\\n/* line 116, ../../../../../../.rvm/gems/ruby-2.4.2/gems/compass-core-1.0.3/stylesheets/compass/reset/_utilities.scss */\\narticle, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary {\\n  display: block;\\n}\\n\\n/* line 1, ../sass/partials/_common.scss */\\ntext {\\n  font-size: 0.6rem;\\n}\\n\\n@font-face {\\n  font-family: 'Fira Sans Extra Condensed', sans-serif;\\n  font-style: normal;\\n  font-weight: 300;\\n  src: local(\\\"Fira Sans Extra Condensed Light\\\"), local(\\\"FiraSans-Light\\\"), url(\" + ___CSS_LOADER_URL___0___ + \");\\n}\\n@font-face {\\n  font-family: 'Fira Sans Extra Condensed', sans-serif;\\n  font-style: normal;\\n  font-weight: 400;\\n  src: local(\\\"Fira Sans Extra Condensed\\\"), local(\\\"FiraSans\\\"), url(\" + ___CSS_LOADER_URL___1___ + \");\\n}\\n@font-face {\\n  font-family: 'Fira Sans Extra Condensed', sans-serif;\\n  font-style: normal;\\n  font-weight: 600;\\n  src: local(\\\"Fira Sans Extra Condensed\\\"), local(\\\"FiraSans-Semibold\\\"), url(\" + ___CSS_LOADER_URL___2___ + \");\\n}\\n@font-face {\\n  font-family: 'Fira Sans Extra Condensed', sans-serif;\\n  font-style: normal;\\n  font-weight: 700;\\n  src: local(\\\"Fira Sans Extra Condensed\\\"), local(\\\"FiraSans-Bold\\\"), url(\" + ___CSS_LOADER_URL___3___ + \");\\n}\\n/* line 2, ../sass/partials/_grid.scss */\\n.grid path {\\n  stroke: #ededed;\\n}\\n/* line 6, ../sass/partials/_grid.scss */\\n.grid line {\\n  stroke: #ededed;\\n  shape-rendering: crispEdges;\\n}\\n\\n/* line 1, ../sass/partials/_infographics.scss */\\n#infographics {\\n  border: 1px solid #999;\\n  width: 1260px;\\n  height: 540px;\\n}\\n/* line 6, ../sass/partials/_infographics.scss */\\n#infographics .container {\\n  position: relative;\\n}\\n\\n/* line 11, ../sass/partials/_infographics.scss */\\n#info {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  pointer-events: none;\\n}\\n/* line 17, ../sass/partials/_infographics.scss */\\n#info .measure {\\n  display: -webkit-box;\\n  display: -moz-box;\\n  display: -ms-flexbox;\\n  display: -webkit-flex;\\n  display: flex;\\n  height: 100%;\\n  align-items: center;\\n}\\n/* line 27, ../sass/partials/_infographics.scss */\\n#info .measure .parent .child {\\n  padding: 3px;\\n  line-height: 80%;\\n  color: #636464;\\n  text-align: left;\\n}\\n\\n/* line 37, ../sass/partials/_infographics.scss */\\nsvg#graphics {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n/* line 1, ../sass/partials/_kpi.scss */\\n#kpi {\\n  border: 1px solid #999;\\n  width: 1260px;\\n  height: 540px;\\n}\\n/* line 7, ../sass/partials/_kpi.scss */\\n#kpi .container .measure {\\n  display: -webkit-box;\\n  display: -moz-box;\\n  display: -ms-flexbox;\\n  display: -webkit-flex;\\n  display: flex;\\n  height: 50%;\\n}\\n/* line 16, ../sass/partials/_kpi.scss */\\n#kpi .container .measure .parent .child {\\n  padding: 3px;\\n  line-height: 80%;\\n  color: #636464;\\n  text-align: left;\\n}\\n\\n/* line 1, ../sass/partials/_tooltip.scss */\\n#tooltip {\\n  visibility: hidden;\\n  position: absolute;\\n  background-color: white;\\n  -webkit-border-radius: 1px;\\n  -moz-border-radius: 1px;\\n  border-radius: 0.5px;\\n  padding: 5px 2px;\\n  z-index: 10;\\n  box-shadow: 0px 0px 1px #BCBCBC;\\n  transition-duration: 0.3s;\\n  -moz-transition-duration: 0.3s;\\n  -webkit-transition-duration: 0.3s;\\n  transition-timing-function: ease;\\n  -moz-transition-timing-function: ease;\\n  -webkit-transition-timing-function: ease;\\n}\\n/* line 19, ../sass/partials/_tooltip.scss */\\n#tooltip table {\\n  font-size: 0.6rem;\\n  font-weight: bold;\\n  border-collapse: separate;\\n  border-spacing: 5px;\\n}\\n/* line 26, ../sass/partials/_tooltip.scss */\\n#tooltip table tr th {\\n  text-align: left;\\n  color: #6F6F6F;\\n  padding: 2px 5px;\\n}\\n/* line 32, ../sass/partials/_tooltip.scss */\\n#tooltip table tr td {\\n  color: #28689C;\\n  padding: 2px 5px;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack://flairVisualizations/./styles/stylesheets/screen.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/url-escape.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/url-escape.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function escape(url, needQuotes) {\n  if (typeof url !== 'string') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]/.test(url) || needQuotes) {\n    return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"';\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/css-loader/dist/runtime/url-escape.js?");

/***/ }),

/***/ "./node_modules/is-in-browser/dist/module.js":
/*!***************************************************!*\
  !*** ./node_modules/is-in-browser/dist/module.js ***!
  \***************************************************/
/*! exports provided: isBrowser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBrowser\", function() { return isBrowser; });\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar isBrowser = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && (typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) === 'object' && document.nodeType === 9;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (isBrowser);\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/is-in-browser/dist/module.js?");

/***/ }),

/***/ "./node_modules/jss/lib/Jss.js":
/*!*************************************!*\
  !*** ./node_modules/jss/lib/Jss.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _isInBrowser = __webpack_require__(/*! is-in-browser */ \"./node_modules/is-in-browser/dist/module.js\");\n\nvar _isInBrowser2 = _interopRequireDefault(_isInBrowser);\n\nvar _StyleSheet = __webpack_require__(/*! ./StyleSheet */ \"./node_modules/jss/lib/StyleSheet.js\");\n\nvar _StyleSheet2 = _interopRequireDefault(_StyleSheet);\n\nvar _PluginsRegistry = __webpack_require__(/*! ./PluginsRegistry */ \"./node_modules/jss/lib/PluginsRegistry.js\");\n\nvar _PluginsRegistry2 = _interopRequireDefault(_PluginsRegistry);\n\nvar _rules = __webpack_require__(/*! ./plugins/rules */ \"./node_modules/jss/lib/plugins/rules.js\");\n\nvar _rules2 = _interopRequireDefault(_rules);\n\nvar _observables = __webpack_require__(/*! ./plugins/observables */ \"./node_modules/jss/lib/plugins/observables.js\");\n\nvar _observables2 = _interopRequireDefault(_observables);\n\nvar _functions = __webpack_require__(/*! ./plugins/functions */ \"./node_modules/jss/lib/plugins/functions.js\");\n\nvar _functions2 = _interopRequireDefault(_functions);\n\nvar _sheets = __webpack_require__(/*! ./sheets */ \"./node_modules/jss/lib/sheets.js\");\n\nvar _sheets2 = _interopRequireDefault(_sheets);\n\nvar _StyleRule = __webpack_require__(/*! ./rules/StyleRule */ \"./node_modules/jss/lib/rules/StyleRule.js\");\n\nvar _StyleRule2 = _interopRequireDefault(_StyleRule);\n\nvar _createGenerateClassName = __webpack_require__(/*! ./utils/createGenerateClassName */ \"./node_modules/jss/lib/utils/createGenerateClassName.js\");\n\nvar _createGenerateClassName2 = _interopRequireDefault(_createGenerateClassName);\n\nvar _createRule2 = __webpack_require__(/*! ./utils/createRule */ \"./node_modules/jss/lib/utils/createRule.js\");\n\nvar _createRule3 = _interopRequireDefault(_createRule2);\n\nvar _DomRenderer = __webpack_require__(/*! ./renderers/DomRenderer */ \"./node_modules/jss/lib/renderers/DomRenderer.js\");\n\nvar _DomRenderer2 = _interopRequireDefault(_DomRenderer);\n\nvar _VirtualRenderer = __webpack_require__(/*! ./renderers/VirtualRenderer */ \"./node_modules/jss/lib/renderers/VirtualRenderer.js\");\n\nvar _VirtualRenderer2 = _interopRequireDefault(_VirtualRenderer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar defaultPlugins = _rules2['default'].concat([_observables2['default'], _functions2['default']]);\n\nvar instanceCounter = 0;\n\nvar Jss = function () {\n  function Jss(options) {\n    _classCallCheck(this, Jss);\n\n    this.id = instanceCounter++;\n    this.version = \"9.8.7\";\n    this.plugins = new _PluginsRegistry2['default']();\n    this.options = {\n      createGenerateClassName: _createGenerateClassName2['default'],\n      Renderer: _isInBrowser2['default'] ? _DomRenderer2['default'] : _VirtualRenderer2['default'],\n      plugins: []\n    };\n    this.generateClassName = (0, _createGenerateClassName2['default'])();\n\n    // eslint-disable-next-line prefer-spread\n    this.use.apply(this, defaultPlugins);\n    this.setup(options);\n  }\n\n  _createClass(Jss, [{\n    key: 'setup',\n    value: function setup() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.createGenerateClassName) {\n        this.options.createGenerateClassName = options.createGenerateClassName;\n        // $FlowFixMe\n        this.generateClassName = options.createGenerateClassName();\n      }\n\n      if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;\n      if (options.virtual || options.Renderer) {\n        this.options.Renderer = options.Renderer || (options.virtual ? _VirtualRenderer2['default'] : _DomRenderer2['default']);\n      }\n\n      // eslint-disable-next-line prefer-spread\n      if (options.plugins) this.use.apply(this, options.plugins);\n\n      return this;\n    }\n\n    /**\n     * Create a Style Sheet.\n     */\n\n  }, {\n    key: 'createStyleSheet',\n    value: function createStyleSheet(styles) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var index = options.index;\n      if (typeof index !== 'number') {\n        index = _sheets2['default'].index === 0 ? 0 : _sheets2['default'].index + 1;\n      }\n      var sheet = new _StyleSheet2['default'](styles, _extends({}, options, {\n        jss: this,\n        generateClassName: options.generateClassName || this.generateClassName,\n        insertionPoint: this.options.insertionPoint,\n        Renderer: this.options.Renderer,\n        index: index\n      }));\n      this.plugins.onProcessSheet(sheet);\n\n      return sheet;\n    }\n\n    /**\n     * Detach the Style Sheet and remove it from the registry.\n     */\n\n  }, {\n    key: 'removeStyleSheet',\n    value: function removeStyleSheet(sheet) {\n      sheet.detach();\n      _sheets2['default'].remove(sheet);\n      return this;\n    }\n\n    /**\n     * Create a rule without a Style Sheet.\n     */\n\n  }, {\n    key: 'createRule',\n    value: function createRule(name) {\n      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // Enable rule without name for inline styles.\n      if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        options = style;\n        style = name;\n        name = undefined;\n      }\n\n      // Cast from RuleFactoryOptions to RuleOptions\n      // https://stackoverflow.com/questions/41328728/force-casting-in-flow\n      var ruleOptions = options;\n\n      ruleOptions.jss = this;\n      ruleOptions.Renderer = this.options.Renderer;\n      if (!ruleOptions.generateClassName) ruleOptions.generateClassName = this.generateClassName;\n      if (!ruleOptions.classes) ruleOptions.classes = {};\n      var rule = (0, _createRule3['default'])(name, style, ruleOptions);\n\n      if (!ruleOptions.selector && rule instanceof _StyleRule2['default']) {\n        rule.selector = '.' + ruleOptions.generateClassName(rule);\n      }\n\n      this.plugins.onProcessRule(rule);\n\n      return rule;\n    }\n\n    /**\n     * Register plugin. Passed function will be invoked with a rule instance.\n     */\n\n  }, {\n    key: 'use',\n    value: function use() {\n      var _this = this;\n\n      for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {\n        plugins[_key] = arguments[_key];\n      }\n\n      plugins.forEach(function (plugin) {\n        // Avoids applying same plugin twice, at least based on ref.\n        if (_this.options.plugins.indexOf(plugin) === -1) {\n          _this.options.plugins.push(plugin);\n          _this.plugins.use(plugin);\n        }\n      });\n\n      return this;\n    }\n  }]);\n\n  return Jss;\n}();\n\nexports['default'] = Jss;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/Jss.js?");

/***/ }),

/***/ "./node_modules/jss/lib/PluginsRegistry.js":
/*!*************************************************!*\
  !*** ./node_modules/jss/lib/PluginsRegistry.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PluginsRegistry = function () {\n  function PluginsRegistry() {\n    _classCallCheck(this, PluginsRegistry);\n\n    this.hooks = {\n      onCreateRule: [],\n      onProcessRule: [],\n      onProcessStyle: [],\n      onProcessSheet: [],\n      onChangeValue: [],\n      onUpdate: []\n\n      /**\n       * Call `onCreateRule` hooks and return an object if returned by a hook.\n       */\n    };\n  }\n\n  _createClass(PluginsRegistry, [{\n    key: 'onCreateRule',\n    value: function onCreateRule(name, decl, options) {\n      for (var i = 0; i < this.hooks.onCreateRule.length; i++) {\n        var rule = this.hooks.onCreateRule[i](name, decl, options);\n        if (rule) return rule;\n      }\n      return null;\n    }\n\n    /**\n     * Call `onProcessRule` hooks.\n     */\n\n  }, {\n    key: 'onProcessRule',\n    value: function onProcessRule(rule) {\n      if (rule.isProcessed) return;\n      var sheet = rule.options.sheet;\n\n      for (var i = 0; i < this.hooks.onProcessRule.length; i++) {\n        this.hooks.onProcessRule[i](rule, sheet);\n      }\n\n      // $FlowFixMe\n      if (rule.style) this.onProcessStyle(rule.style, rule, sheet);\n\n      rule.isProcessed = true;\n    }\n\n    /**\n     * Call `onProcessStyle` hooks.\n     */\n\n  }, {\n    key: 'onProcessStyle',\n    value: function onProcessStyle(style, rule, sheet) {\n      var nextStyle = style;\n\n      for (var i = 0; i < this.hooks.onProcessStyle.length; i++) {\n        nextStyle = this.hooks.onProcessStyle[i](nextStyle, rule, sheet);\n        // $FlowFixMe\n        rule.style = nextStyle;\n      }\n    }\n\n    /**\n     * Call `onProcessSheet` hooks.\n     */\n\n  }, {\n    key: 'onProcessSheet',\n    value: function onProcessSheet(sheet) {\n      for (var i = 0; i < this.hooks.onProcessSheet.length; i++) {\n        this.hooks.onProcessSheet[i](sheet);\n      }\n    }\n\n    /**\n     * Call `onUpdate` hooks.\n     */\n\n  }, {\n    key: 'onUpdate',\n    value: function onUpdate(data, rule, sheet) {\n      for (var i = 0; i < this.hooks.onUpdate.length; i++) {\n        this.hooks.onUpdate[i](data, rule, sheet);\n      }\n    }\n\n    /**\n     * Call `onChangeValue` hooks.\n     */\n\n  }, {\n    key: 'onChangeValue',\n    value: function onChangeValue(value, prop, rule) {\n      var processedValue = value;\n      for (var i = 0; i < this.hooks.onChangeValue.length; i++) {\n        processedValue = this.hooks.onChangeValue[i](processedValue, prop, rule);\n      }\n      return processedValue;\n    }\n\n    /**\n     * Register a plugin.\n     * If function is passed, it is a shortcut for `{onProcessRule}`.\n     */\n\n  }, {\n    key: 'use',\n    value: function use(plugin) {\n      for (var name in plugin) {\n        if (this.hooks[name]) this.hooks[name].push(plugin[name]);else (0, _warning2['default'])(false, '[JSS] Unknown hook \"%s\".', name);\n      }\n    }\n  }]);\n\n  return PluginsRegistry;\n}();\n\nexports['default'] = PluginsRegistry;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/PluginsRegistry.js?");

/***/ }),

/***/ "./node_modules/jss/lib/RuleList.js":
/*!******************************************!*\
  !*** ./node_modules/jss/lib/RuleList.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _createRule = __webpack_require__(/*! ./utils/createRule */ \"./node_modules/jss/lib/utils/createRule.js\");\n\nvar _createRule2 = _interopRequireDefault(_createRule);\n\nvar _linkRule = __webpack_require__(/*! ./utils/linkRule */ \"./node_modules/jss/lib/utils/linkRule.js\");\n\nvar _linkRule2 = _interopRequireDefault(_linkRule);\n\nvar _StyleRule = __webpack_require__(/*! ./rules/StyleRule */ \"./node_modules/jss/lib/rules/StyleRule.js\");\n\nvar _StyleRule2 = _interopRequireDefault(_StyleRule);\n\nvar _escape = __webpack_require__(/*! ./utils/escape */ \"./node_modules/jss/lib/utils/escape.js\");\n\nvar _escape2 = _interopRequireDefault(_escape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Contains rules objects and allows adding/removing etc.\n * Is used for e.g. by `StyleSheet` or `ConditionalRule`.\n */\nvar RuleList = function () {\n\n  // Original styles object.\n  function RuleList(options) {\n    var _this = this;\n\n    _classCallCheck(this, RuleList);\n\n    this.map = {};\n    this.raw = {};\n    this.index = [];\n\n    this.update = function (name, data) {\n      var _options = _this.options,\n          plugins = _options.jss.plugins,\n          sheet = _options.sheet;\n\n      if (typeof name === 'string') {\n        plugins.onUpdate(data, _this.get(name), sheet);\n      } else {\n        for (var index = 0; index < _this.index.length; index++) {\n          plugins.onUpdate(name, _this.index[index], sheet);\n        }\n      }\n    };\n\n    this.options = options;\n    this.classes = options.classes;\n  }\n\n  /**\n   * Create and register rule.\n   *\n   * Will not render after Style Sheet was rendered the first time.\n   */\n\n\n  // Used to ensure correct rules order.\n\n  // Rules registry for access by .get() method.\n  // It contains the same rule registered by name and by selector.\n\n\n  _createClass(RuleList, [{\n    key: 'add',\n    value: function add(name, decl, options) {\n      var _options2 = this.options,\n          parent = _options2.parent,\n          sheet = _options2.sheet,\n          jss = _options2.jss,\n          Renderer = _options2.Renderer,\n          generateClassName = _options2.generateClassName;\n\n\n      options = _extends({\n        classes: this.classes,\n        parent: parent,\n        sheet: sheet,\n        jss: jss,\n        Renderer: Renderer,\n        generateClassName: generateClassName\n      }, options);\n\n      if (!options.selector && this.classes[name]) {\n        options.selector = '.' + (0, _escape2['default'])(this.classes[name]);\n      }\n\n      this.raw[name] = decl;\n\n      var rule = (0, _createRule2['default'])(name, decl, options);\n\n      var className = void 0;\n\n      if (!options.selector && rule instanceof _StyleRule2['default']) {\n        className = generateClassName(rule, sheet);\n        rule.selector = '.' + (0, _escape2['default'])(className);\n      }\n\n      this.register(rule, className);\n\n      var index = options.index === undefined ? this.index.length : options.index;\n      this.index.splice(index, 0, rule);\n\n      return rule;\n    }\n\n    /**\n     * Get a rule.\n     */\n\n  }, {\n    key: 'get',\n    value: function get(name) {\n      return this.map[name];\n    }\n\n    /**\n     * Delete a rule.\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(rule) {\n      this.unregister(rule);\n      this.index.splice(this.indexOf(rule), 1);\n    }\n\n    /**\n     * Get index of a rule.\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(rule) {\n      return this.index.indexOf(rule);\n    }\n\n    /**\n     * Run `onProcessRule()` plugins on every rule.\n     */\n\n  }, {\n    key: 'process',\n    value: function process() {\n      var plugins = this.options.jss.plugins;\n      // We need to clone array because if we modify the index somewhere else during a loop\n      // we end up with very hard-to-track-down side effects.\n\n      this.index.slice(0).forEach(plugins.onProcessRule, plugins);\n    }\n\n    /**\n     * Register a rule in `.map` and `.classes` maps.\n     */\n\n  }, {\n    key: 'register',\n    value: function register(rule, className) {\n      this.map[rule.key] = rule;\n      if (rule instanceof _StyleRule2['default']) {\n        this.map[rule.selector] = rule;\n        if (className) this.classes[rule.key] = className;\n      }\n    }\n\n    /**\n     * Unregister a rule.\n     */\n\n  }, {\n    key: 'unregister',\n    value: function unregister(rule) {\n      delete this.map[rule.key];\n      if (rule instanceof _StyleRule2['default']) {\n        delete this.map[rule.selector];\n        delete this.classes[rule.key];\n      }\n    }\n\n    /**\n     * Update the function values with a new data.\n     */\n\n  }, {\n    key: 'link',\n\n\n    /**\n     * Link renderable rules with CSSRuleList.\n     */\n    value: function link(cssRules) {\n      var map = this.options.sheet.renderer.getUnescapedKeysMap(this.index);\n\n      for (var i = 0; i < cssRules.length; i++) {\n        var cssRule = cssRules[i];\n        var _key = this.options.sheet.renderer.getKey(cssRule);\n        if (map[_key]) _key = map[_key];\n        var rule = this.map[_key];\n        if (rule) (0, _linkRule2['default'])(rule, cssRule);\n      }\n    }\n\n    /**\n     * Convert rules to a CSS string.\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString(options) {\n      var str = '';\n      var sheet = this.options.sheet;\n\n      var link = sheet ? sheet.options.link : false;\n\n      for (var index = 0; index < this.index.length; index++) {\n        var rule = this.index[index];\n        var css = rule.toString(options);\n\n        // No need to render an empty rule.\n        if (!css && !link) continue;\n\n        if (str) str += '\\n';\n        str += css;\n      }\n\n      return str;\n    }\n  }]);\n\n  return RuleList;\n}();\n\nexports['default'] = RuleList;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/RuleList.js?");

/***/ }),

/***/ "./node_modules/jss/lib/SheetsManager.js":
/*!***********************************************!*\
  !*** ./node_modules/jss/lib/SheetsManager.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * SheetsManager is like a WeakMap which is designed to count StyleSheet\n * instances and attach/detach automatically.\n */\nvar SheetsManager = function () {\n  function SheetsManager() {\n    _classCallCheck(this, SheetsManager);\n\n    this.sheets = [];\n    this.refs = [];\n    this.keys = [];\n  }\n\n  _createClass(SheetsManager, [{\n    key: 'get',\n    value: function get(key) {\n      var index = this.keys.indexOf(key);\n      return this.sheets[index];\n    }\n  }, {\n    key: 'add',\n    value: function add(key, sheet) {\n      var sheets = this.sheets,\n          refs = this.refs,\n          keys = this.keys;\n\n      var index = sheets.indexOf(sheet);\n\n      if (index !== -1) return index;\n\n      sheets.push(sheet);\n      refs.push(0);\n      keys.push(key);\n\n      return sheets.length - 1;\n    }\n  }, {\n    key: 'manage',\n    value: function manage(key) {\n      var index = this.keys.indexOf(key);\n      var sheet = this.sheets[index];\n      if (this.refs[index] === 0) sheet.attach();\n      this.refs[index]++;\n      if (!this.keys[index]) this.keys.splice(index, 0, key);\n      return sheet;\n    }\n  }, {\n    key: 'unmanage',\n    value: function unmanage(key) {\n      var index = this.keys.indexOf(key);\n      if (index === -1) {\n        // eslint-ignore-next-line no-console\n        (0, _warning2['default'])(false, \"SheetsManager: can't find sheet to unmanage\");\n        return;\n      }\n      if (this.refs[index] > 0) {\n        this.refs[index]--;\n        if (this.refs[index] === 0) this.sheets[index].detach();\n      }\n    }\n  }, {\n    key: 'size',\n    get: function get() {\n      return this.keys.length;\n    }\n  }]);\n\n  return SheetsManager;\n}();\n\nexports['default'] = SheetsManager;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/SheetsManager.js?");

/***/ }),

/***/ "./node_modules/jss/lib/SheetsRegistry.js":
/*!************************************************!*\
  !*** ./node_modules/jss/lib/SheetsRegistry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Sheets registry to access them all at one place.\n */\nvar SheetsRegistry = function () {\n  function SheetsRegistry() {\n    _classCallCheck(this, SheetsRegistry);\n\n    this.registry = [];\n  }\n\n  _createClass(SheetsRegistry, [{\n    key: 'add',\n\n\n    /**\n     * Register a Style Sheet.\n     */\n    value: function add(sheet) {\n      var registry = this.registry;\n      var index = sheet.options.index;\n\n\n      if (registry.indexOf(sheet) !== -1) return;\n\n      if (registry.length === 0 || index >= this.index) {\n        registry.push(sheet);\n        return;\n      }\n\n      // Find a position.\n      for (var i = 0; i < registry.length; i++) {\n        if (registry[i].options.index > index) {\n          registry.splice(i, 0, sheet);\n          return;\n        }\n      }\n    }\n\n    /**\n     * Reset the registry.\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.registry = [];\n    }\n\n    /**\n     * Remove a Style Sheet.\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(sheet) {\n      var index = this.registry.indexOf(sheet);\n      this.registry.splice(index, 1);\n    }\n\n    /**\n     * Convert all attached sheets to a CSS string.\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString(options) {\n      return this.registry.filter(function (sheet) {\n        return sheet.attached;\n      }).map(function (sheet) {\n        return sheet.toString(options);\n      }).join('\\n');\n    }\n  }, {\n    key: 'index',\n\n\n    /**\n     * Current highest index number.\n     */\n    get: function get() {\n      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;\n    }\n  }]);\n\n  return SheetsRegistry;\n}();\n\nexports['default'] = SheetsRegistry;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/SheetsRegistry.js?");

/***/ }),

/***/ "./node_modules/jss/lib/StyleSheet.js":
/*!********************************************!*\
  !*** ./node_modules/jss/lib/StyleSheet.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _linkRule = __webpack_require__(/*! ./utils/linkRule */ \"./node_modules/jss/lib/utils/linkRule.js\");\n\nvar _linkRule2 = _interopRequireDefault(_linkRule);\n\nvar _RuleList = __webpack_require__(/*! ./RuleList */ \"./node_modules/jss/lib/RuleList.js\");\n\nvar _RuleList2 = _interopRequireDefault(_RuleList);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable-next-line no-use-before-define */\nvar StyleSheet = function () {\n  function StyleSheet(styles, options) {\n    var _this = this;\n\n    _classCallCheck(this, StyleSheet);\n\n    this.update = function (name, data) {\n      if (typeof name === 'string') {\n        _this.rules.update(name, data);\n      } else {\n        _this.rules.update(name);\n      }\n      return _this;\n    };\n\n    this.attached = false;\n    this.deployed = false;\n    this.linked = false;\n    this.classes = {};\n    this.options = _extends({}, options, {\n      sheet: this,\n      parent: this,\n      classes: this.classes\n    });\n    this.renderer = new options.Renderer(this);\n    this.rules = new _RuleList2['default'](this.options);\n\n    for (var _name in styles) {\n      this.rules.add(_name, styles[_name]);\n    }\n\n    this.rules.process();\n  }\n\n  /**\n   * Attach renderable to the render tree.\n   */\n\n\n  _createClass(StyleSheet, [{\n    key: 'attach',\n    value: function attach() {\n      if (this.attached) return this;\n      if (!this.deployed) this.deploy();\n      this.renderer.attach();\n      if (!this.linked && this.options.link) this.link();\n      this.attached = true;\n      return this;\n    }\n\n    /**\n     * Remove renderable from render tree.\n     */\n\n  }, {\n    key: 'detach',\n    value: function detach() {\n      if (!this.attached) return this;\n      this.renderer.detach();\n      this.attached = false;\n      return this;\n    }\n\n    /**\n     * Add a rule to the current stylesheet.\n     * Will insert a rule also after the stylesheet has been rendered first time.\n     */\n\n  }, {\n    key: 'addRule',\n    value: function addRule(name, decl, options) {\n      var queue = this.queue;\n\n      // Plugins can create rules.\n      // In order to preserve the right order, we need to queue all `.addRule` calls,\n      // which happen after the first `rules.add()` call.\n\n      if (this.attached && !queue) this.queue = [];\n\n      var rule = this.rules.add(name, decl, options);\n      this.options.jss.plugins.onProcessRule(rule);\n\n      if (this.attached) {\n        if (!this.deployed) return rule;\n        // Don't insert rule directly if there is no stringified version yet.\n        // It will be inserted all together when .attach is called.\n        if (queue) queue.push(rule);else {\n          this.insertRule(rule);\n          if (this.queue) {\n            this.queue.forEach(this.insertRule, this);\n            this.queue = undefined;\n          }\n        }\n        return rule;\n      }\n\n      // We can't add rules to a detached style node.\n      // We will redeploy the sheet once user will attach it.\n      this.deployed = false;\n\n      return rule;\n    }\n\n    /**\n     * Insert rule into the StyleSheet\n     */\n\n  }, {\n    key: 'insertRule',\n    value: function insertRule(rule) {\n      var renderable = this.renderer.insertRule(rule);\n      if (renderable && this.options.link) (0, _linkRule2['default'])(rule, renderable);\n    }\n\n    /**\n     * Create and add rules.\n     * Will render also after Style Sheet was rendered the first time.\n     */\n\n  }, {\n    key: 'addRules',\n    value: function addRules(styles, options) {\n      var added = [];\n      for (var _name2 in styles) {\n        added.push(this.addRule(_name2, styles[_name2], options));\n      }\n      return added;\n    }\n\n    /**\n     * Get a rule by name.\n     */\n\n  }, {\n    key: 'getRule',\n    value: function getRule(name) {\n      return this.rules.get(name);\n    }\n\n    /**\n     * Delete a rule by name.\n     * Returns `true`: if rule has been deleted from the DOM.\n     */\n\n  }, {\n    key: 'deleteRule',\n    value: function deleteRule(name) {\n      var rule = this.rules.get(name);\n\n      if (!rule) return false;\n\n      this.rules.remove(rule);\n\n      if (this.attached && rule.renderable) {\n        return this.renderer.deleteRule(rule.renderable);\n      }\n\n      return true;\n    }\n\n    /**\n     * Get index of a rule.\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(rule) {\n      return this.rules.indexOf(rule);\n    }\n\n    /**\n     * Deploy pure CSS string to a renderable.\n     */\n\n  }, {\n    key: 'deploy',\n    value: function deploy() {\n      this.renderer.deploy();\n      this.deployed = true;\n      return this;\n    }\n\n    /**\n     * Link renderable CSS rules from sheet with their corresponding models.\n     */\n\n  }, {\n    key: 'link',\n    value: function link() {\n      var cssRules = this.renderer.getRules();\n\n      // Is undefined when VirtualRenderer is used.\n      if (cssRules) this.rules.link(cssRules);\n      this.linked = true;\n      return this;\n    }\n\n    /**\n     * Update the function values with a new data.\n     */\n\n  }, {\n    key: 'toString',\n\n\n    /**\n     * Convert rules to a CSS string.\n     */\n    value: function toString(options) {\n      return this.rules.toString(options);\n    }\n  }]);\n\n  return StyleSheet;\n}();\n\nexports['default'] = StyleSheet;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/StyleSheet.js?");

/***/ }),

/***/ "./node_modules/jss/lib/index.js":
/*!***************************************!*\
  !*** ./node_modules/jss/lib/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = exports.createGenerateClassName = exports.sheets = exports.RuleList = exports.SheetsManager = exports.SheetsRegistry = exports.toCssValue = exports.getDynamicStyles = undefined;\n\nvar _getDynamicStyles = __webpack_require__(/*! ./utils/getDynamicStyles */ \"./node_modules/jss/lib/utils/getDynamicStyles.js\");\n\nObject.defineProperty(exports, 'getDynamicStyles', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_getDynamicStyles)['default'];\n  }\n});\n\nvar _toCssValue = __webpack_require__(/*! ./utils/toCssValue */ \"./node_modules/jss/lib/utils/toCssValue.js\");\n\nObject.defineProperty(exports, 'toCssValue', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_toCssValue)['default'];\n  }\n});\n\nvar _SheetsRegistry = __webpack_require__(/*! ./SheetsRegistry */ \"./node_modules/jss/lib/SheetsRegistry.js\");\n\nObject.defineProperty(exports, 'SheetsRegistry', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_SheetsRegistry)['default'];\n  }\n});\n\nvar _SheetsManager = __webpack_require__(/*! ./SheetsManager */ \"./node_modules/jss/lib/SheetsManager.js\");\n\nObject.defineProperty(exports, 'SheetsManager', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_SheetsManager)['default'];\n  }\n});\n\nvar _RuleList = __webpack_require__(/*! ./RuleList */ \"./node_modules/jss/lib/RuleList.js\");\n\nObject.defineProperty(exports, 'RuleList', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_RuleList)['default'];\n  }\n});\n\nvar _sheets = __webpack_require__(/*! ./sheets */ \"./node_modules/jss/lib/sheets.js\");\n\nObject.defineProperty(exports, 'sheets', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_sheets)['default'];\n  }\n});\n\nvar _createGenerateClassName = __webpack_require__(/*! ./utils/createGenerateClassName */ \"./node_modules/jss/lib/utils/createGenerateClassName.js\");\n\nObject.defineProperty(exports, 'createGenerateClassName', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_createGenerateClassName)['default'];\n  }\n});\n\nvar _Jss = __webpack_require__(/*! ./Jss */ \"./node_modules/jss/lib/Jss.js\");\n\nvar _Jss2 = _interopRequireDefault(_Jss);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Creates a new instance of Jss.\n */\nvar create = exports.create = function create(options) {\n  return new _Jss2['default'](options);\n};\n\n/**\n * A global Jss instance.\n */\nexports['default'] = create();\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/index.js?");

/***/ }),

/***/ "./node_modules/jss/lib/plugins/functions.js":
/*!***************************************************!*\
  !*** ./node_modules/jss/lib/plugins/functions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _RuleList = __webpack_require__(/*! ../RuleList */ \"./node_modules/jss/lib/RuleList.js\");\n\nvar _RuleList2 = _interopRequireDefault(_RuleList);\n\nvar _StyleRule = __webpack_require__(/*! ../rules/StyleRule */ \"./node_modules/jss/lib/rules/StyleRule.js\");\n\nvar _StyleRule2 = _interopRequireDefault(_StyleRule);\n\nvar _createRule = __webpack_require__(/*! ../utils/createRule */ \"./node_modules/jss/lib/utils/createRule.js\");\n\nvar _createRule2 = _interopRequireDefault(_createRule);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// A symbol replacement.\nvar now = Date.now();\n\nvar fnValuesNs = 'fnValues' + now;\nvar fnStyleNs = 'fnStyle' + ++now;\n\nexports['default'] = {\n  onCreateRule: function onCreateRule(name, decl, options) {\n    if (typeof decl !== 'function') return null;\n    var rule = (0, _createRule2['default'])(name, {}, options);\n    rule[fnStyleNs] = decl;\n    return rule;\n  },\n  onProcessStyle: function onProcessStyle(style, rule) {\n    var fn = {};\n    for (var prop in style) {\n      var value = style[prop];\n      if (typeof value !== 'function') continue;\n      delete style[prop];\n      fn[prop] = value;\n    }\n    rule = rule;\n    rule[fnValuesNs] = fn;\n    return style;\n  },\n  onUpdate: function onUpdate(data, rule) {\n    // It is a rules container like for e.g. ConditionalRule.\n    if (rule.rules instanceof _RuleList2['default']) {\n      rule.rules.update(data);\n      return;\n    }\n    if (!(rule instanceof _StyleRule2['default'])) return;\n\n    rule = rule;\n\n    // If we have a fn values map, it is a rule with function values.\n    if (rule[fnValuesNs]) {\n      for (var prop in rule[fnValuesNs]) {\n        rule.prop(prop, rule[fnValuesNs][prop](data));\n      }\n    }\n\n    rule = rule;\n\n    var fnStyle = rule[fnStyleNs];\n\n    // If we have a style function, the entire rule is dynamic and style object\n    // will be returned from that function.\n    if (fnStyle) {\n      var style = fnStyle(data);\n      for (var _prop in style) {\n        rule.prop(_prop, style[_prop]);\n      }\n    }\n  }\n};\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/plugins/functions.js?");

/***/ }),

/***/ "./node_modules/jss/lib/plugins/observables.js":
/*!*****************************************************!*\
  !*** ./node_modules/jss/lib/plugins/observables.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _StyleRule = __webpack_require__(/*! ../rules/StyleRule */ \"./node_modules/jss/lib/rules/StyleRule.js\");\n\nvar _StyleRule2 = _interopRequireDefault(_StyleRule);\n\nvar _createRule = __webpack_require__(/*! ../utils/createRule */ \"./node_modules/jss/lib/utils/createRule.js\");\n\nvar _createRule2 = _interopRequireDefault(_createRule);\n\nvar _isObservable = __webpack_require__(/*! ../utils/isObservable */ \"./node_modules/jss/lib/utils/isObservable.js\");\n\nvar _isObservable2 = _interopRequireDefault(_isObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports['default'] = {\n  onCreateRule: function onCreateRule(name, decl, options) {\n    if (!(0, _isObservable2['default'])(decl)) return null;\n\n    // Cast `decl` to `Observable`, since it passed the type guard.\n    var style$ = decl;\n\n    var rule = (0, _createRule2['default'])(name, {}, options);\n\n    // TODO\n    // Call `stream.subscribe()` returns a subscription, which should be explicitly\n    // unsubscribed from when we know this sheet is no longer needed.\n    style$.subscribe(function (style) {\n      for (var prop in style) {\n        rule.prop(prop, style[prop]);\n      }\n    });\n\n    return rule;\n  },\n  onProcessRule: function onProcessRule(rule) {\n    if (!(rule instanceof _StyleRule2['default'])) return;\n    var styleRule = rule;\n    var style = styleRule.style;\n\n    var _loop = function _loop(prop) {\n      var value = style[prop];\n      if (!(0, _isObservable2['default'])(value)) return 'continue';\n      delete style[prop];\n      value.subscribe({\n        next: function next(nextValue) {\n          styleRule.prop(prop, nextValue);\n        }\n      });\n    };\n\n    for (var prop in style) {\n      var _ret = _loop(prop);\n\n      if (_ret === 'continue') continue;\n    }\n  }\n};\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/plugins/observables.js?");

/***/ }),

/***/ "./node_modules/jss/lib/plugins/rules.js":
/*!***********************************************!*\
  !*** ./node_modules/jss/lib/plugins/rules.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SimpleRule = __webpack_require__(/*! ../rules/SimpleRule */ \"./node_modules/jss/lib/rules/SimpleRule.js\");\n\nvar _SimpleRule2 = _interopRequireDefault(_SimpleRule);\n\nvar _KeyframesRule = __webpack_require__(/*! ../rules/KeyframesRule */ \"./node_modules/jss/lib/rules/KeyframesRule.js\");\n\nvar _KeyframesRule2 = _interopRequireDefault(_KeyframesRule);\n\nvar _ConditionalRule = __webpack_require__(/*! ../rules/ConditionalRule */ \"./node_modules/jss/lib/rules/ConditionalRule.js\");\n\nvar _ConditionalRule2 = _interopRequireDefault(_ConditionalRule);\n\nvar _FontFaceRule = __webpack_require__(/*! ../rules/FontFaceRule */ \"./node_modules/jss/lib/rules/FontFaceRule.js\");\n\nvar _FontFaceRule2 = _interopRequireDefault(_FontFaceRule);\n\nvar _ViewportRule = __webpack_require__(/*! ../rules/ViewportRule */ \"./node_modules/jss/lib/rules/ViewportRule.js\");\n\nvar _ViewportRule2 = _interopRequireDefault(_ViewportRule);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar classes = {\n  '@charset': _SimpleRule2['default'],\n  '@import': _SimpleRule2['default'],\n  '@namespace': _SimpleRule2['default'],\n  '@keyframes': _KeyframesRule2['default'],\n  '@media': _ConditionalRule2['default'],\n  '@supports': _ConditionalRule2['default'],\n  '@font-face': _FontFaceRule2['default'],\n  '@viewport': _ViewportRule2['default'],\n  '@-ms-viewport': _ViewportRule2['default']\n\n  /**\n   * Generate plugins which will register all rules.\n   */\n};\nvar plugins = Object.keys(classes).map(function (key) {\n  // https://jsperf.com/indexof-vs-substr-vs-regex-at-the-beginning-3\n  var re = new RegExp('^' + key);\n  var RuleClass = classes[key];\n  var onCreateRule = function onCreateRule(name, decl, options) {\n    return re.test(name) ? new RuleClass(name, decl, options) : null;\n  };\n  return { onCreateRule: onCreateRule };\n});\n\nexports['default'] = plugins;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/plugins/rules.js?");

/***/ }),

/***/ "./node_modules/jss/lib/renderers/DomRenderer.js":
/*!*******************************************************!*\
  !*** ./node_modules/jss/lib/renderers/DomRenderer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _sheets = __webpack_require__(/*! ../sheets */ \"./node_modules/jss/lib/sheets.js\");\n\nvar _sheets2 = _interopRequireDefault(_sheets);\n\nvar _StyleRule = __webpack_require__(/*! ../rules/StyleRule */ \"./node_modules/jss/lib/rules/StyleRule.js\");\n\nvar _StyleRule2 = _interopRequireDefault(_StyleRule);\n\nvar _toCssValue = __webpack_require__(/*! ../utils/toCssValue */ \"./node_modules/jss/lib/utils/toCssValue.js\");\n\nvar _toCssValue2 = _interopRequireDefault(_toCssValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Cache the value from the first time a function is called.\n */\nvar memoize = function memoize(fn) {\n  var value = void 0;\n  return function () {\n    if (!value) value = fn();\n    return value;\n  };\n};\n\n/**\n * Get a style property value.\n */\nfunction getPropertyValue(cssRule, prop) {\n  try {\n    return cssRule.style.getPropertyValue(prop);\n  } catch (err) {\n    // IE may throw if property is unknown.\n    return '';\n  }\n}\n\n/**\n * Set a style property.\n */\nfunction setProperty(cssRule, prop, value) {\n  try {\n    var cssValue = value;\n\n    if (Array.isArray(value)) {\n      cssValue = (0, _toCssValue2['default'])(value, true);\n\n      if (value[value.length - 1] === '!important') {\n        cssRule.style.setProperty(prop, cssValue, 'important');\n        return true;\n      }\n    }\n\n    cssRule.style.setProperty(prop, cssValue);\n  } catch (err) {\n    // IE may throw if property is unknown.\n    return false;\n  }\n  return true;\n}\n\n/**\n * Remove a style property.\n */\nfunction removeProperty(cssRule, prop) {\n  try {\n    cssRule.style.removeProperty(prop);\n  } catch (err) {\n    (0, _warning2['default'])(false, '[JSS] DOMException \"%s\" was thrown. Tried to remove property \"%s\".', err.message, prop);\n  }\n}\n\nvar CSSRuleTypes = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7\n\n  /**\n   * Get the CSS Rule key.\n   */\n\n};var getKey = function () {\n  var extractKey = function extractKey(cssText) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return cssText.substr(from, cssText.indexOf('{') - 1);\n  };\n\n  return function (cssRule) {\n    if (cssRule.type === CSSRuleTypes.STYLE_RULE) return cssRule.selectorText;\n    if (cssRule.type === CSSRuleTypes.KEYFRAMES_RULE) {\n      var name = cssRule.name;\n\n      if (name) return '@keyframes ' + name;\n\n      // There is no rule.name in the following browsers:\n      // - IE 9\n      // - Safari 7.1.8\n      // - Mobile Safari 9.0.0\n      var cssText = cssRule.cssText;\n\n      return '@' + extractKey(cssText, cssText.indexOf('keyframes'));\n    }\n\n    // Conditionals.\n    return extractKey(cssRule.cssText);\n  };\n}();\n\n/**\n * Set the selector.\n */\nfunction setSelector(cssRule, selectorText) {\n  cssRule.selectorText = selectorText;\n\n  // Return false if setter was not successful.\n  // Currently works in chrome only.\n  return cssRule.selectorText === selectorText;\n}\n\n/**\n * Gets the `head` element upon the first call and caches it.\n */\nvar getHead = memoize(function () {\n  return document.head || document.getElementsByTagName('head')[0];\n});\n\n/**\n * Gets a map of rule keys, where the property is an unescaped key and value\n * is a potentially escaped one.\n * It is used to identify CSS rules and the corresponding JSS rules. As an identifier\n * for CSSStyleRule we normally use `selectorText`. Though if original selector text\n * contains escaped code points e.g. `:not(#\\\\20)`, CSSOM will compile it to `:not(# )`\n * and so CSS rule's `selectorText` won't match JSS rule selector.\n *\n * https://www.w3.org/International/questions/qa-escapes#cssescapes\n */\nvar getUnescapedKeysMap = function () {\n  var style = void 0;\n  var isAttached = false;\n\n  return function (rules) {\n    var map = {};\n    // https://github.com/facebook/flow/issues/2696\n    if (!style) style = document.createElement('style');\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      if (!(rule instanceof _StyleRule2['default'])) continue;\n      var selector = rule.selector;\n      // Only unescape selector over CSSOM if it contains a back slash.\n\n      if (selector && selector.indexOf('\\\\') !== -1) {\n        // Lazilly attach when needed.\n        if (!isAttached) {\n          getHead().appendChild(style);\n          isAttached = true;\n        }\n        style.textContent = selector + ' {}';\n        var _style = style,\n            sheet = _style.sheet;\n\n        if (sheet) {\n          var cssRules = sheet.cssRules;\n\n          if (cssRules) map[cssRules[0].selectorText] = rule.key;\n        }\n      }\n    }\n    if (isAttached) {\n      getHead().removeChild(style);\n      isAttached = false;\n    }\n    return map;\n  };\n}();\n\n/**\n * Find attached sheet with an index higher than the passed one.\n */\nfunction findHigherSheet(registry, options) {\n  for (var i = 0; i < registry.length; i++) {\n    var sheet = registry[i];\n    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {\n      return sheet;\n    }\n  }\n  return null;\n}\n\n/**\n * Find attached sheet with the highest index.\n */\nfunction findHighestSheet(registry, options) {\n  for (var i = registry.length - 1; i >= 0; i--) {\n    var sheet = registry[i];\n    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {\n      return sheet;\n    }\n  }\n  return null;\n}\n\n/**\n * Find a comment with \"jss\" inside.\n */\nfunction findCommentNode(text) {\n  var head = getHead();\n  for (var i = 0; i < head.childNodes.length; i++) {\n    var node = head.childNodes[i];\n    if (node.nodeType === 8 && node.nodeValue.trim() === text) {\n      return node;\n    }\n  }\n  return null;\n}\n\n/**\n * Find a node before which we can insert the sheet.\n */\nfunction findPrevNode(options) {\n  var registry = _sheets2['default'].registry;\n\n\n  if (registry.length > 0) {\n    // Try to insert before the next higher sheet.\n    var sheet = findHigherSheet(registry, options);\n    if (sheet) return sheet.renderer.element;\n\n    // Otherwise insert after the last attached.\n    sheet = findHighestSheet(registry, options);\n    if (sheet) return sheet.renderer.element.nextElementSibling;\n  }\n\n  // Try to find a comment placeholder if registry is empty.\n  var insertionPoint = options.insertionPoint;\n\n  if (insertionPoint && typeof insertionPoint === 'string') {\n    var comment = findCommentNode(insertionPoint);\n    if (comment) return comment.nextSibling;\n    // If user specifies an insertion point and it can't be found in the document -\n    // bad specificity issues may appear.\n    (0, _warning2['default'])(insertionPoint === 'jss', '[JSS] Insertion point \"%s\" not found.', insertionPoint);\n  }\n\n  return null;\n}\n\n/**\n * Insert style element into the DOM.\n */\nfunction insertStyle(style, options) {\n  var insertionPoint = options.insertionPoint;\n\n  var prevNode = findPrevNode(options);\n\n  if (prevNode) {\n    var parentNode = prevNode.parentNode;\n\n    if (parentNode) parentNode.insertBefore(style, prevNode);\n    return;\n  }\n\n  // Works with iframes and any node types.\n  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {\n    // https://stackoverflow.com/questions/41328728/force-casting-in-flow\n    var insertionPointElement = insertionPoint;\n    var _parentNode = insertionPointElement.parentNode;\n\n    if (_parentNode) _parentNode.insertBefore(style, insertionPointElement.nextSibling);else (0, _warning2['default'])(false, '[JSS] Insertion point is not in the DOM.');\n    return;\n  }\n\n  getHead().insertBefore(style, prevNode);\n}\n\n/**\n * Read jss nonce setting from the page if the user has set it.\n */\nvar getNonce = memoize(function () {\n  var node = document.querySelector('meta[property=\"csp-nonce\"]');\n  return node ? node.getAttribute('content') : null;\n});\n\nvar DomRenderer = function () {\n  function DomRenderer(sheet) {\n    _classCallCheck(this, DomRenderer);\n\n    this.getPropertyValue = getPropertyValue;\n    this.setProperty = setProperty;\n    this.removeProperty = removeProperty;\n    this.setSelector = setSelector;\n    this.getKey = getKey;\n    this.getUnescapedKeysMap = getUnescapedKeysMap;\n    this.hasInsertedRules = false;\n\n    // There is no sheet when the renderer is used from a standalone StyleRule.\n    if (sheet) _sheets2['default'].add(sheet);\n\n    this.sheet = sheet;\n\n    var _ref = this.sheet ? this.sheet.options : {},\n        media = _ref.media,\n        meta = _ref.meta,\n        element = _ref.element;\n\n    this.element = element || document.createElement('style');\n    this.element.setAttribute('data-jss', '');\n    if (media) this.element.setAttribute('media', media);\n    if (meta) this.element.setAttribute('data-meta', meta);\n    var nonce = getNonce();\n    if (nonce) this.element.setAttribute('nonce', nonce);\n  }\n\n  /**\n   * Insert style element into render tree.\n   */\n\n\n  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696\n\n\n  _createClass(DomRenderer, [{\n    key: 'attach',\n    value: function attach() {\n      // In the case the element node is external and it is already in the DOM.\n      if (this.element.parentNode || !this.sheet) return;\n\n      // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`\n      // browsers remove those rules.\n      // TODO figure out if its a bug and if it is known.\n      // Workaround is to redeploy the sheet before attaching as a string.\n      if (this.hasInsertedRules) {\n        this.deploy();\n        this.hasInsertedRules = false;\n      }\n\n      insertStyle(this.element, this.sheet.options);\n    }\n\n    /**\n     * Remove style element from render tree.\n     */\n\n  }, {\n    key: 'detach',\n    value: function detach() {\n      this.element.parentNode.removeChild(this.element);\n    }\n\n    /**\n     * Inject CSS string into element.\n     */\n\n  }, {\n    key: 'deploy',\n    value: function deploy() {\n      if (!this.sheet) return;\n      this.element.textContent = '\\n' + this.sheet.toString() + '\\n';\n    }\n\n    /**\n     * Insert a rule into element.\n     */\n\n  }, {\n    key: 'insertRule',\n    value: function insertRule(rule, index) {\n      var sheet = this.element.sheet;\n      var cssRules = sheet.cssRules;\n\n      var str = rule.toString();\n      if (!index) index = cssRules.length;\n\n      if (!str) return false;\n\n      try {\n        sheet.insertRule(str, index);\n      } catch (err) {\n        (0, _warning2['default'])(false, '[JSS] Can not insert an unsupported rule \\n\\r%s', rule);\n        return false;\n      }\n      this.hasInsertedRules = true;\n\n      return cssRules[index];\n    }\n\n    /**\n     * Delete a rule.\n     */\n\n  }, {\n    key: 'deleteRule',\n    value: function deleteRule(cssRule) {\n      var sheet = this.element.sheet;\n\n      var index = this.indexOf(cssRule);\n      if (index === -1) return false;\n      sheet.deleteRule(index);\n      return true;\n    }\n\n    /**\n     * Get index of a CSS Rule.\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(cssRule) {\n      var cssRules = this.element.sheet.cssRules;\n\n      for (var _index = 0; _index < cssRules.length; _index++) {\n        if (cssRule === cssRules[_index]) return _index;\n      }\n      return -1;\n    }\n\n    /**\n     * Generate a new CSS rule and replace the existing one.\n     */\n\n  }, {\n    key: 'replaceRule',\n    value: function replaceRule(cssRule, rule) {\n      var index = this.indexOf(cssRule);\n      var newCssRule = this.insertRule(rule, index);\n      this.element.sheet.deleteRule(index);\n      return newCssRule;\n    }\n\n    /**\n     * Get all rules elements.\n     */\n\n  }, {\n    key: 'getRules',\n    value: function getRules() {\n      return this.element.sheet.cssRules;\n    }\n  }]);\n\n  return DomRenderer;\n}();\n\nexports['default'] = DomRenderer;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/renderers/DomRenderer.js?");

/***/ }),

/***/ "./node_modules/jss/lib/renderers/VirtualRenderer.js":
/*!***********************************************************!*\
  !*** ./node_modules/jss/lib/renderers/VirtualRenderer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable class-methods-use-this */\n\n/**\n * Rendering backend to do nothing in nodejs.\n */\nvar VirtualRenderer = function () {\n  function VirtualRenderer() {\n    _classCallCheck(this, VirtualRenderer);\n  }\n\n  _createClass(VirtualRenderer, [{\n    key: 'setProperty',\n    value: function setProperty() {\n      return true;\n    }\n  }, {\n    key: 'getPropertyValue',\n    value: function getPropertyValue() {\n      return '';\n    }\n  }, {\n    key: 'removeProperty',\n    value: function removeProperty() {}\n  }, {\n    key: 'setSelector',\n    value: function setSelector() {\n      return true;\n    }\n  }, {\n    key: 'getKey',\n    value: function getKey() {\n      return '';\n    }\n  }, {\n    key: 'attach',\n    value: function attach() {}\n  }, {\n    key: 'detach',\n    value: function detach() {}\n  }, {\n    key: 'deploy',\n    value: function deploy() {}\n  }, {\n    key: 'insertRule',\n    value: function insertRule() {\n      return false;\n    }\n  }, {\n    key: 'deleteRule',\n    value: function deleteRule() {\n      return true;\n    }\n  }, {\n    key: 'replaceRule',\n    value: function replaceRule() {\n      return false;\n    }\n  }, {\n    key: 'getRules',\n    value: function getRules() {}\n  }, {\n    key: 'indexOf',\n    value: function indexOf() {\n      return -1;\n    }\n  }]);\n\n  return VirtualRenderer;\n}();\n\nexports['default'] = VirtualRenderer;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/renderers/VirtualRenderer.js?");

/***/ }),

/***/ "./node_modules/jss/lib/rules/ConditionalRule.js":
/*!*******************************************************!*\
  !*** ./node_modules/jss/lib/rules/ConditionalRule.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _RuleList = __webpack_require__(/*! ../RuleList */ \"./node_modules/jss/lib/RuleList.js\");\n\nvar _RuleList2 = _interopRequireDefault(_RuleList);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Conditional rule for @media, @supports\n */\nvar ConditionalRule = function () {\n  function ConditionalRule(key, styles, options) {\n    _classCallCheck(this, ConditionalRule);\n\n    this.type = 'conditional';\n    this.isProcessed = false;\n\n    this.key = key;\n    this.options = options;\n    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));\n\n    for (var name in styles) {\n      this.rules.add(name, styles[name]);\n    }\n\n    this.rules.process();\n  }\n\n  /**\n   * Get a rule.\n   */\n\n\n  _createClass(ConditionalRule, [{\n    key: 'getRule',\n    value: function getRule(name) {\n      return this.rules.get(name);\n    }\n\n    /**\n     * Get index of a rule.\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(rule) {\n      return this.rules.indexOf(rule);\n    }\n\n    /**\n     * Create and register rule, run plugins.\n     */\n\n  }, {\n    key: 'addRule',\n    value: function addRule(name, style, options) {\n      var rule = this.rules.add(name, style, options);\n      this.options.jss.plugins.onProcessRule(rule);\n      return rule;\n    }\n\n    /**\n     * Generates a CSS string.\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };\n\n      var inner = this.rules.toString(options);\n      return inner ? this.key + ' {\\n' + inner + '\\n}' : '';\n    }\n  }]);\n\n  return ConditionalRule;\n}();\n\nexports['default'] = ConditionalRule;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/rules/ConditionalRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/rules/FontFaceRule.js":
/*!****************************************************!*\
  !*** ./node_modules/jss/lib/rules/FontFaceRule.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _toCss = __webpack_require__(/*! ../utils/toCss */ \"./node_modules/jss/lib/utils/toCss.js\");\n\nvar _toCss2 = _interopRequireDefault(_toCss);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FontFaceRule = function () {\n  function FontFaceRule(key, style, options) {\n    _classCallCheck(this, FontFaceRule);\n\n    this.type = 'font-face';\n    this.isProcessed = false;\n\n    this.key = key;\n    this.style = style;\n    this.options = options;\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n\n\n  _createClass(FontFaceRule, [{\n    key: 'toString',\n    value: function toString(options) {\n      if (Array.isArray(this.style)) {\n        var str = '';\n        for (var index = 0; index < this.style.length; index++) {\n          str += (0, _toCss2['default'])(this.key, this.style[index]);\n          if (this.style[index + 1]) str += '\\n';\n        }\n        return str;\n      }\n\n      return (0, _toCss2['default'])(this.key, this.style, options);\n    }\n  }]);\n\n  return FontFaceRule;\n}();\n\nexports['default'] = FontFaceRule;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/rules/FontFaceRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/rules/KeyframesRule.js":
/*!*****************************************************!*\
  !*** ./node_modules/jss/lib/rules/KeyframesRule.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _RuleList = __webpack_require__(/*! ../RuleList */ \"./node_modules/jss/lib/RuleList.js\");\n\nvar _RuleList2 = _interopRequireDefault(_RuleList);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Rule for @keyframes\n */\nvar KeyframesRule = function () {\n  function KeyframesRule(key, frames, options) {\n    _classCallCheck(this, KeyframesRule);\n\n    this.type = 'keyframes';\n    this.isProcessed = false;\n\n    this.key = key;\n    this.options = options;\n    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));\n\n    for (var name in frames) {\n      this.rules.add(name, frames[name], _extends({}, this.options, {\n        parent: this,\n        selector: name\n      }));\n    }\n\n    this.rules.process();\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n\n\n  _createClass(KeyframesRule, [{\n    key: 'toString',\n    value: function toString() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };\n\n      var inner = this.rules.toString(options);\n      if (inner) inner += '\\n';\n      return this.key + ' {\\n' + inner + '}';\n    }\n  }]);\n\n  return KeyframesRule;\n}();\n\nexports['default'] = KeyframesRule;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/rules/KeyframesRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/rules/SimpleRule.js":
/*!**************************************************!*\
  !*** ./node_modules/jss/lib/rules/SimpleRule.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SimpleRule = function () {\n  function SimpleRule(key, value, options) {\n    _classCallCheck(this, SimpleRule);\n\n    this.type = 'simple';\n    this.isProcessed = false;\n\n    this.key = key;\n    this.value = value;\n    this.options = options;\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  _createClass(SimpleRule, [{\n    key: 'toString',\n    value: function toString(options) {\n      if (Array.isArray(this.value)) {\n        var str = '';\n        for (var index = 0; index < this.value.length; index++) {\n          str += this.key + ' ' + this.value[index] + ';';\n          if (this.value[index + 1]) str += '\\n';\n        }\n        return str;\n      }\n\n      return this.key + ' ' + this.value + ';';\n    }\n  }]);\n\n  return SimpleRule;\n}();\n\nexports['default'] = SimpleRule;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/rules/SimpleRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/rules/StyleRule.js":
/*!*************************************************!*\
  !*** ./node_modules/jss/lib/rules/StyleRule.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _toCss = __webpack_require__(/*! ../utils/toCss */ \"./node_modules/jss/lib/utils/toCss.js\");\n\nvar _toCss2 = _interopRequireDefault(_toCss);\n\nvar _toCssValue = __webpack_require__(/*! ../utils/toCssValue */ \"./node_modules/jss/lib/utils/toCssValue.js\");\n\nvar _toCssValue2 = _interopRequireDefault(_toCssValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StyleRule = function () {\n  function StyleRule(key, style, options) {\n    _classCallCheck(this, StyleRule);\n\n    this.type = 'style';\n    this.isProcessed = false;\n    var sheet = options.sheet,\n        Renderer = options.Renderer,\n        selector = options.selector;\n\n    this.key = key;\n    this.options = options;\n    this.style = style;\n    if (selector) this.selectorText = selector;\n    this.renderer = sheet ? sheet.renderer : new Renderer();\n  }\n\n  /**\n   * Set selector string.\n   * Attention: use this with caution. Most browsers didn't implement\n   * selectorText setter, so this may result in rerendering of entire Style Sheet.\n   */\n\n\n  _createClass(StyleRule, [{\n    key: 'prop',\n\n\n    /**\n     * Get or set a style property.\n     */\n    value: function prop(name, value) {\n      // It's a getter.\n      if (value === undefined) return this.style[name];\n\n      // Don't do anything if the value has not changed.\n      if (this.style[name] === value) return this;\n\n      value = this.options.jss.plugins.onChangeValue(value, name, this);\n\n      var isEmpty = value == null || value === false;\n      var isDefined = name in this.style;\n\n      // Value is empty and wasn't defined before.\n      if (isEmpty && !isDefined) return this;\n\n      // We are going to remove this value.\n      var remove = isEmpty && isDefined;\n\n      if (remove) delete this.style[name];else this.style[name] = value;\n\n      // Renderable is defined if StyleSheet option `link` is true.\n      if (this.renderable) {\n        if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, value);\n        return this;\n      }\n\n      var sheet = this.options.sheet;\n\n      if (sheet && sheet.attached) {\n        (0, _warning2['default'])(false, 'Rule is not linked. Missing sheet option \"link: true\".');\n      }\n      return this;\n    }\n\n    /**\n     * Apply rule to an element inline.\n     */\n\n  }, {\n    key: 'applyTo',\n    value: function applyTo(renderable) {\n      var json = this.toJSON();\n      for (var prop in json) {\n        this.renderer.setProperty(renderable, prop, json[prop]);\n      }return this;\n    }\n\n    /**\n     * Returns JSON representation of the rule.\n     * Fallbacks are not supported.\n     * Useful for inline styles.\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var json = {};\n      for (var prop in this.style) {\n        var value = this.style[prop];\n        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = (0, _toCssValue2['default'])(value);\n      }\n      return json;\n    }\n\n    /**\n     * Generates a CSS string.\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString(options) {\n      var sheet = this.options.sheet;\n\n      var link = sheet ? sheet.options.link : false;\n      var opts = link ? _extends({}, options, { allowEmpty: true }) : options;\n      return (0, _toCss2['default'])(this.selector, this.style, opts);\n    }\n  }, {\n    key: 'selector',\n    set: function set(selector) {\n      if (selector === this.selectorText) return;\n\n      this.selectorText = selector;\n\n      if (!this.renderable) return;\n\n      var hasChanged = this.renderer.setSelector(this.renderable, selector);\n\n      // If selector setter is not implemented, rerender the rule.\n      if (!hasChanged && this.renderable) {\n        var renderable = this.renderer.replaceRule(this.renderable, this);\n        if (renderable) this.renderable = renderable;\n      }\n    }\n\n    /**\n     * Get selector string.\n     */\n    ,\n    get: function get() {\n      return this.selectorText;\n    }\n  }]);\n\n  return StyleRule;\n}();\n\nexports['default'] = StyleRule;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/rules/StyleRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/rules/ViewportRule.js":
/*!****************************************************!*\
  !*** ./node_modules/jss/lib/rules/ViewportRule.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _toCss = __webpack_require__(/*! ../utils/toCss */ \"./node_modules/jss/lib/utils/toCss.js\");\n\nvar _toCss2 = _interopRequireDefault(_toCss);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ViewportRule = function () {\n  function ViewportRule(key, style, options) {\n    _classCallCheck(this, ViewportRule);\n\n    this.type = 'viewport';\n    this.isProcessed = false;\n\n    this.key = key;\n    this.style = style;\n    this.options = options;\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n\n\n  _createClass(ViewportRule, [{\n    key: 'toString',\n    value: function toString(options) {\n      return (0, _toCss2['default'])(this.key, this.style, options);\n    }\n  }]);\n\n  return ViewportRule;\n}();\n\nexports['default'] = ViewportRule;\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/rules/ViewportRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/sheets.js":
/*!****************************************!*\
  !*** ./node_modules/jss/lib/sheets.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SheetsRegistry = __webpack_require__(/*! ./SheetsRegistry */ \"./node_modules/jss/lib/SheetsRegistry.js\");\n\nvar _SheetsRegistry2 = _interopRequireDefault(_SheetsRegistry);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * This is a global sheets registry. Only DomRenderer will add sheets to it.\n * On the server one should use an own SheetsRegistry instance and add the\n * sheets to it, because you need to make sure to create a new registry for\n * each request in order to not leak sheets across requests.\n */\nexports['default'] = new _SheetsRegistry2['default']();\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/sheets.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/cloneStyle.js":
/*!**************************************************!*\
  !*** ./node_modules/jss/lib/utils/cloneStyle.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports['default'] = cloneStyle;\n\nvar _isObservable = __webpack_require__(/*! ./isObservable */ \"./node_modules/jss/lib/utils/isObservable.js\");\n\nvar _isObservable2 = _interopRequireDefault(_isObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar isArray = Array.isArray;\nfunction cloneStyle(style) {\n  // Support empty values in case user ends up with them by accident.\n  if (style == null) return style;\n\n  // Support string value for SimpleRule.\n  var typeOfStyle = typeof style === 'undefined' ? 'undefined' : _typeof(style);\n\n  if (typeOfStyle === 'string' || typeOfStyle === 'number' || typeOfStyle === 'function') {\n    return style;\n  }\n\n  // Support array for FontFaceRule.\n  if (isArray(style)) return style.map(cloneStyle);\n\n  // Support Observable styles.  Observables are immutable, so we don't need to\n  // copy them.\n  if ((0, _isObservable2['default'])(style)) return style;\n\n  var newStyle = {};\n  for (var name in style) {\n    var value = style[name];\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      newStyle[name] = cloneStyle(value);\n      continue;\n    }\n    newStyle[name] = value;\n  }\n\n  return newStyle;\n}\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/cloneStyle.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/createGenerateClassName.js":
/*!***************************************************************!*\
  !*** ./node_modules/jss/lib/utils/createGenerateClassName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _StyleSheet = __webpack_require__(/*! ../StyleSheet */ \"./node_modules/jss/lib/StyleSheet.js\");\n\nvar _StyleSheet2 = _interopRequireDefault(_StyleSheet);\n\nvar _moduleId = __webpack_require__(/*! ./moduleId */ \"./node_modules/jss/lib/utils/moduleId.js\");\n\nvar _moduleId2 = _interopRequireDefault(_moduleId);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar maxRules = 1e10;\n\n\nvar env = \"development\";\n\n/**\n * Returns a function which generates unique class names based on counters.\n * When new generator function is created, rule counter is reseted.\n * We need to reset the rule counter for SSR for each request.\n */\n\nexports['default'] = function () {\n  var ruleCounter = 0;\n  var defaultPrefix = env === 'production' ? 'c' : '';\n\n  return function (rule, sheet) {\n    ruleCounter += 1;\n\n    if (ruleCounter > maxRules) {\n      (0, _warning2['default'])(false, '[JSS] You might have a memory leak. Rule counter is at %s.', ruleCounter);\n    }\n\n    var prefix = defaultPrefix;\n    var jssId = '';\n\n    if (sheet) {\n      prefix = sheet.options.classNamePrefix || defaultPrefix;\n      if (sheet.options.jss.id != null) jssId += sheet.options.jss.id;\n    }\n\n    if (env === 'production') {\n      return '' + prefix + _moduleId2['default'] + jssId + ruleCounter;\n    }\n\n    return prefix + rule.key + '-' + _moduleId2['default'] + (jssId && '-' + jssId) + '-' + ruleCounter;\n  };\n};\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/createGenerateClassName.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/createRule.js":
/*!**************************************************!*\
  !*** ./node_modules/jss/lib/utils/createRule.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = createRule;\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _StyleRule = __webpack_require__(/*! ../rules/StyleRule */ \"./node_modules/jss/lib/rules/StyleRule.js\");\n\nvar _StyleRule2 = _interopRequireDefault(_StyleRule);\n\nvar _cloneStyle = __webpack_require__(/*! ../utils/cloneStyle */ \"./node_modules/jss/lib/utils/cloneStyle.js\");\n\nvar _cloneStyle2 = _interopRequireDefault(_cloneStyle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Create a rule instance.\n */\nfunction createRule() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unnamed';\n  var decl = arguments[1];\n  var options = arguments[2];\n  var jss = options.jss;\n\n  var declCopy = (0, _cloneStyle2['default'])(decl);\n\n  var rule = jss.plugins.onCreateRule(name, declCopy, options);\n  if (rule) return rule;\n\n  // It is an at-rule and it has no instance.\n  if (name[0] === '@') {\n    (0, _warning2['default'])(false, '[JSS] Unknown at-rule %s', name);\n  }\n\n  return new _StyleRule2['default'](name, declCopy, options);\n}\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/createRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/escape.js":
/*!**********************************************!*\
  !*** ./node_modules/jss/lib/utils/escape.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar CSS = global.CSS;\n\nvar env = \"development\";\n\nvar escapeRegex = /([[\\].#*$><+~=|^:(),\"'`])/g;\n\nexports['default'] = function (str) {\n  // We don't need to escape it in production, because we are not using user's\n  // input for selectors, we are generating a valid selector.\n  if (env === 'production') return str;\n\n  if (!CSS || !CSS.escape) {\n    return str.replace(escapeRegex, '\\\\$1');\n  }\n\n  return CSS.escape(str);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/global.js */ \"../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/escape.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/getDynamicStyles.js":
/*!********************************************************!*\
  !*** ./node_modules/jss/lib/utils/getDynamicStyles.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports['default'] = getDynamicStyles;\n/**\n * Extracts a styles object with only props that contain function values.\n */\nfunction getDynamicStyles(styles) {\n  var to = null;\n\n  for (var key in styles) {\n    var value = styles[key];\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\n    if (type === 'function') {\n      if (!to) to = {};\n      to[key] = value;\n    } else if (type === 'object' && value !== null && !Array.isArray(value)) {\n      var extracted = getDynamicStyles(value);\n      if (extracted) {\n        if (!to) to = {};\n        to[key] = extracted;\n      }\n    }\n  }\n\n  return to;\n}\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/getDynamicStyles.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/isObservable.js":
/*!****************************************************!*\
  !*** ./node_modules/jss/lib/utils/isObservable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _symbolObservable = __webpack_require__(/*! symbol-observable */ \"./node_modules/symbol-observable/es/index.js\");\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports['default'] = function (value) {\n  return value && value[_symbolObservable2['default']] && value === value[_symbolObservable2['default']]();\n};\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/isObservable.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/linkRule.js":
/*!************************************************!*\
  !*** ./node_modules/jss/lib/utils/linkRule.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = linkRule;\n/**\n * Link rule with CSSStyleRule and nested rules with corresponding nested cssRules if both exists.\n */\nfunction linkRule(rule, cssRule) {\n  rule.renderable = cssRule;\n  if (rule.rules && cssRule.cssRules) rule.rules.link(cssRule.cssRules);\n}\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/linkRule.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/moduleId.js":
/*!************************************************!*\
  !*** ./node_modules/jss/lib/utils/moduleId.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ns = '2f1acc6c3a606b082e5eef5e54414ffb';\nif (global[ns] == null) global[ns] = 0;\n\n// Bundle may contain multiple JSS versions at the same time. In order to identify\n// the current version with just one short number and use it for classes generation\n// we use a counter. Also it is more accurate, because user can manually reevaluate\n// the module.\nexports['default'] = global[ns]++;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/global.js */ \"../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/moduleId.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/toCss.js":
/*!*********************************************!*\
  !*** ./node_modules/jss/lib/utils/toCss.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = toCss;\n\nvar _toCssValue = __webpack_require__(/*! ./toCssValue */ \"./node_modules/jss/lib/utils/toCssValue.js\");\n\nvar _toCssValue2 = _interopRequireDefault(_toCssValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Indent a string.\n * http://jsperf.com/array-join-vs-for\n */\nfunction indentStr(str, indent) {\n  var result = '';\n  for (var index = 0; index < indent; index++) {\n    result += '  ';\n  }return result + str;\n}\n\n/**\n * Converts a Rule to CSS string.\n */\n\nfunction toCss(selector, style) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var result = '';\n\n  if (!style) return result;\n\n  var _options$indent = options.indent,\n      indent = _options$indent === undefined ? 0 : _options$indent;\n  var fallbacks = style.fallbacks;\n\n\n  indent++;\n\n  // Apply fallbacks first.\n  if (fallbacks) {\n    // Array syntax {fallbacks: [{prop: value}]}\n    if (Array.isArray(fallbacks)) {\n      for (var index = 0; index < fallbacks.length; index++) {\n        var fallback = fallbacks[index];\n        for (var prop in fallback) {\n          var value = fallback[prop];\n          if (value != null) {\n            result += '\\n' + indentStr(prop + ': ' + (0, _toCssValue2['default'])(value) + ';', indent);\n          }\n        }\n      }\n    } else {\n      // Object syntax {fallbacks: {prop: value}}\n      for (var _prop in fallbacks) {\n        var _value = fallbacks[_prop];\n        if (_value != null) {\n          result += '\\n' + indentStr(_prop + ': ' + (0, _toCssValue2['default'])(_value) + ';', indent);\n        }\n      }\n    }\n  }\n\n  for (var _prop2 in style) {\n    var _value2 = style[_prop2];\n    if (_value2 != null && _prop2 !== 'fallbacks') {\n      result += '\\n' + indentStr(_prop2 + ': ' + (0, _toCssValue2['default'])(_value2) + ';', indent);\n    }\n  }\n\n  // Allow empty style in this case, because properties will be added dynamically.\n  if (!result && !options.allowEmpty) return result;\n\n  indent--;\n  result = indentStr(selector + ' {' + result + '\\n', indent) + indentStr('}', indent);\n\n  return result;\n}\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/toCss.js?");

/***/ }),

/***/ "./node_modules/jss/lib/utils/toCssValue.js":
/*!**************************************************!*\
  !*** ./node_modules/jss/lib/utils/toCssValue.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = toCssValue;\nvar join = function join(value, by) {\n  var result = '';\n  for (var i = 0; i < value.length; i++) {\n    // Remove !important from the value, it will be readded later.\n    if (value[i] === '!important') break;\n    if (result) result += by;\n    result += value[i];\n  }\n  return result;\n};\n\n/**\n * Converts array values to string.\n *\n * `margin: [['5px', '10px']]` > `margin: 5px 10px;`\n * `border: ['1px', '2px']` > `border: 1px, 2px;`\n * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`\n * `color: ['red', !important]` > `color: red !important;`\n */\nfunction toCssValue(value) {\n  var ignoreImportant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!Array.isArray(value)) return value;\n\n  var cssValue = '';\n\n  // Support space separated values via `[['5px', '10px']]`.\n  if (Array.isArray(value[0])) {\n    for (var i = 0; i < value.length; i++) {\n      if (value[i] === '!important') break;\n      if (cssValue) cssValue += ', ';\n      cssValue += join(value[i], ' ');\n    }\n  } else cssValue = join(value, ', ');\n\n  // Add !important, because it was ignored.\n  if (!ignoreImportant && value[value.length - 1] === '!important') {\n    cssValue += ' !important';\n  }\n\n  return cssValue;\n}\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/jss/lib/utils/toCssValue.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./node_modules/symbol-observable/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-observable/es/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ \"./node_modules/symbol-observable/es/ponyfill.js\");\n/* global window */\n\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {}\n\nvar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(root);\n/* harmony default export */ __webpack_exports__[\"default\"] = (result);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/global.js */ \"../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/harmony-module.js */ \"../../../../.nvm/versions/node/v8.11.2/lib/node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/symbol-observable/es/index.js?");

/***/ }),

/***/ "./node_modules/symbol-observable/es/ponyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-observable/es/ponyfill.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return symbolObservablePonyfill; });\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/symbol-observable/es/ponyfill.js?");

/***/ }),

/***/ "./node_modules/ttf-loader/lib/create-font-family.js":
/*!***********************************************************!*\
  !*** ./node_modules/ttf-loader/lib/create-font-family.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse { var i, a; }\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _stringify = __webpack_require__(1);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _jss = __webpack_require__(2);\n\nvar _jss2 = _interopRequireDefault(_jss);\n\nvar _v = __webpack_require__(3);\n\nvar _v2 = _interopRequireDefault(_v);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar fontType = {\n  eot: 0,\n  woff: 1,\n  ttf: 2,\n  svg: 3\n};\n\nvar createUrl = function createUrl(_ref) {\n  var url = _ref.url,\n      hash = _ref.hash,\n      format = _ref.format,\n      _ref$afterHash = _ref.afterHash,\n      afterHash = _ref$afterHash === undefined ? '' : _ref$afterHash;\n  return 'url(\"' + url + (hash ? '?' + hash : '') + afterHash + '\")' + (format ? ' format(\"' + format + '\")' : '');\n};\n\nvar createUrlParamters = function createUrlParamters(_ref2) {\n  var type = _ref2.type,\n      url = _ref2.url,\n      hash = _ref2.hash;\n\n  var format = void 0;\n  var afterHash = void 0;\n\n  switch (type) {\n    case fontType.eot:\n      {\n        format = 'embedded-opentype';\n        afterHash = '?#iefix';\n        break;\n      }\n    case fontType.woff:\n      {\n        format = 'woff';\n        break;\n      }\n    case fontType.ttf:\n      {\n        format = 'truetype';\n        break;\n      }\n    case fontType.svg:\n      {\n        format = 'svg';\n        afterHash = '#font-loader';\n        break;\n      }\n    default:\n      return undefined;\n  }\n\n  return {\n    url: url,\n    hash: hash,\n    format: format,\n    afterHash: afterHash\n  };\n};\n\nvar getUrl = function getUrl(param) {\n  return createUrl(createUrlParamters(param));\n};\n\nvar createFontFamily = function createFontFamily(_ref3) {\n  var eot = _ref3.eot,\n      woff = _ref3.woff,\n      ttf = _ref3.ttf,\n      svg = _ref3.svg,\n      hash = _ref3.hash;\n\n  var fontName = 'font-' + (0, _v2.default)();\n\n  _jss2.default.createStyleSheet({\n    '@font-face': {\n      'font-family': (0, _stringify2.default)(fontName),\n      src: [{\n        url: eot,\n        type: fontType.eot\n      }, {\n        url: woff,\n        type: fontType.woff\n      }, {\n        url: ttf,\n        type: fontType.ttf\n      }, {\n        url: svg,\n        type: fontType.svg\n      }].filter(function (_ref4) {\n        var url = _ref4.url;\n        return url !== undefined;\n      }).map(function (_ref5) {\n        var url = _ref5.url,\n            type = _ref5.type;\n        return getUrl({ url: url, type: type, hash: hash });\n      }).join(', ')\n    }\n  }).attach();\n\n  return fontName;\n};\n\nmodule.exports = createFontFamily;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ \"./node_modules/babel-runtime/core-js/json/stringify.js\");\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! jss */ \"./node_modules/jss/lib/index.js\");\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! uuid/v4 */ \"./node_modules/uuid/v4.js\");\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=create-font-family.js.map\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/ttf-loader/lib/create-font-family.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/uuid/lib/bytesToUuid.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/uuid/lib/rng-browser.js?");

/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/uuid/v4.js?");

/***/ }),

/***/ "./node_modules/warning/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/warning/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function() {};\n\nif (true) {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n\n\n//# sourceURL=webpack://flairVisualizations/./node_modules/warning/browser.js?");

/***/ }),

/***/ "./styles/stylesheets/screen.css":
/*!***************************************!*\
  !*** ./styles/stylesheets/screen.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./screen.css */ \"./node_modules/css-loader/dist/cjs.js!./styles/stylesheets/screen.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack://flairVisualizations/./styles/stylesheets/screen.css?");

/***/ })

/******/ });